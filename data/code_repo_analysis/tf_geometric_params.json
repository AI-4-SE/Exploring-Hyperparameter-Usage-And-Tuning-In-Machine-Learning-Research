{
    "demo/demo_asap.py": {
        "sklearn": {
            "train_test_split_39": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_122": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_112": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_44": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_74": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(64, activation=tf.nn.relu), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_96": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack(outputs, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_116": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_131": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_141": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_90": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tfg.nn.mean_pool(h, node_graph_index), tfg.nn.max_pool(h, node_graph_index)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GradientTape_129": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_96": {
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_75": {
                "units": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_76": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_77": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "one_hot_133": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_dgi.py": {
        "sklearn": {
            "LogisticRegression_122": {
                "variable": {
                    "value": "cls",
                    "type": "variable",
                    "possible_values": []
                },
                "C": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                },
                "max_iter": {
                    "value": "500",
                    "type": "int",
                    "possible_values": []
                }
            },
            "f1_score_125": {
                "variable": {
                    "value": "micro_f1",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y[test_index]",
                            "Subscript"
                        ],
                        [
                            "graph.y[test_index]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls.predict(test_X)",
                            "Call"
                        ],
                        [
                            "tf.argmax(model(test_X), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "f1_score_140": {
                "variable": {
                    "value": "micro_f1",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y[test_index]",
                            "Subscript"
                        ],
                        [
                            "graph.y[test_index]",
                            "Subscript"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls.predict(test_X)",
                            "Call"
                        ],
                        [
                            "tf.argmax(model(test_X), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Dropout_18": {
                "variable": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "Adam_80": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_131": {
                "variable": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(num_classes, activation='softmax')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_139": {
                "variable": {
                    "value": "pred_Y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model(test_X)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Variable_48": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_51": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "input_shapes[1][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shuffle_72": {
                "variable": {
                    "value": "perm_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.range(0, tf.shape(graph.x)[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_73": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "perm_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.shuffle(tf.range(0, tf.shape(graph.x)[0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_91": {
                "variable": {
                    "value": "pos_graph_h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(pos_h, axis=0, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_96": {
                "variable": {
                    "value": "pos_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pos_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bilinear_model([pos_h, pos_graph_h], training=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.ones_like(pos_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_101": {
                "variable": {
                    "value": "neg_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "neg_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bilinear_model([neg_h, pos_graph_h], training=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.zeros_like(neg_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_107": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pos_losses + neg_losses",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "GradientTape_85": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_138": {
                "indices": {
                    "value": "train_Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y[train_index]",
                            "Subscript"
                        ],
                        [
                            "graph.y[train_index]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_55": {
                "input_tensor": {
                    "value": "self.dense(a) * b",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_91": {
                "input_tensor": {
                    "value": "pos_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encode(graph, permutation=False, training=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Dense_132": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                },
                "activation": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Adam_134": {
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "PReLU_30": {
                "alpha_initializer": {
                    "value": "tf.keras.initializers.Constant(value=0.25)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_98": {
                "input": {
                    "value": "pos_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bilinear_model([pos_h, pos_graph_h], training=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_103": {
                "input": {
                    "value": "neg_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bilinear_model([neg_h, pos_graph_h], training=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_72": {
                "input": {
                    "value": "graph.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Constant_30": {
                "value": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "demo/demo_diff_pool.py": {
        "sklearn": {
            "train_test_split_44": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_145": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_135": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_49": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_102": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_117": {
                "variable": {
                    "value": "graph_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "graph_h_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_139": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(graph_h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_153": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(graph_h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_163": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_151": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dropout_103": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_104": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_155": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_distributed_mean_pool.py": {
        "sklearn": {
            "train_test_split_41": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "MirroredStrategy_90": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_116": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(y_true, tf.int32)",
                            "Call"
                        ],
                        [
                            "y_true",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_117": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([x, edge_index, node_graph_index])",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(y_true, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_143": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(corrects, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_144": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_46": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dropout_67": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.4",
                            "float"
                        ]
                    ]
                }
            },
            "Dense_68": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_74": {
                "variable": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(node_graph_index, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_121": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(y_true, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_140": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([x, edge_index, node_graph_index])",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Adam_125": {
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_144": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(corrects, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_119": {
                "indices": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(y_true, tf.int32)",
                            "Call"
                        ],
                        [
                            "y_true",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "equal_141": {
                "x": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_graph_generator(test_graphs, batch_size, shuffle=False, infinite=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_103": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_102": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "demo/demo_gin.py": {
        "sklearn": {
            "train_test_split_43": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.003",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_143": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "corrects_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_144": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_48": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_86": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[keras.layers.Dense(128, activation=tf.nn.relu), keras.layers.Dropout(0.3), keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_107": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "hidden_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_125": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_130": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_141": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GradientTape_123": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_144": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(corrects_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_142": {
                "x": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_76": {
                "layers": {
                    "value": "[keras.layers.Dense(units, activation=tf.nn.relu), keras.layers.Dense(units), keras.layers.BatchNormalization(), keras.layers.Activation(tf.nn.relu)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Dense_87": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_88": {
                "rate": {
                    "value": "0.3",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_89": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_127": {
                "indices": {
                    "value": "batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Dense_77": {
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": [
                        [
                            "units",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_78": {
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": [
                        [
                            "units",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "BatchNormalization_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Activation_80": {
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "demo/demo_graph_sage.py": {
        "sklearn": {
            "f1_score_76": {
                "y_true": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "y_true",
                            "Method Argument"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate(y_preds, axis=0)",
                            "Call"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Sequential_42": {
                "variable": {
                    "value": "fc",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[keras.layers.Dropout(0.3), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Adam_96": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_61": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.convert_to_tensor(graph.y, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_43": {
                "rate": {
                    "value": "0.3",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_44": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_graphs[0].y.shape[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "l2_loss_67": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_69": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=tf.convert_to_tensor(graph.y, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_63": {
                "value": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_69": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "GradientTape_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "demo/demo_mean_pool.py": {
        "sklearn": {
            "train_test_split_37": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_108": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_98": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_42": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dropout_69": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.4",
                            "float"
                        ]
                    ]
                }
            },
            "Dense_70": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "argmax_102": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_116": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_126": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_118": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_min_cut_pool.py": {
        "sklearn": {
            "train_test_split_43": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_181": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_171": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_48": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_92": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(units, activation=tf.nn.relu if i < len(mlp_units_list) - 1 else None) for (i, units) in enumerate(mlp_units_list)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Sequential_119": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_148": {
                "variable": {
                    "value": "graph_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "graph_h_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_175": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True, return_losses=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(graph_h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_189": {
                "variable": {
                    "value": "cls_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True, return_losses=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(graph_h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_193": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cls_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_135": {
                "variable": {
                    "value": "graph_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tfg.nn.mean_pool(pooled_h, pooled_node_graph_index), tfg.nn.max_pool(pooled_h, pooled_node_graph_index)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "add_n_154": {
                "variable": {
                    "value": "cut_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "mean_cut_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_155": {
                "variable": {
                    "value": "orth_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "mean_orth_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "GradientTape_187": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_93": {
                "units": {
                    "value": "units",
                    "type": "variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu if i < len(mlp_units_list) - 1 else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Dropout_120": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_121": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_191": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_sag_pool_h.py": {
        "sklearn": {
            "train_test_split_43": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_132": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.0005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_122": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_48": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_83": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(128, activation=tf.nn.relu), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(64, activation=tf.nn.relu), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_106": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack(outputs, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_126": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_141": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_151": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_100": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tfg.nn.mean_pool(h, node_graph_index), tfg.nn.max_pool(h, node_graph_index)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GradientTape_139": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_106": {
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_84": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_85": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_86": {
                "units": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_87": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "one_hot_143": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_set2set.py": {
        "sklearn": {
            "train_test_split_40": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_110": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.0005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_100": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_45": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Sequential_72": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(64, activation=tf.nn.relu), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_104": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_118": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ],
                        [
                            "self.mlp(h, training=training)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_128": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_116": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_73": {
                "units": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_74": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_75": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "one_hot_120": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_sort_pool.py": {
        "sklearn": {
            "train_test_split_44": {
                "variable": {
                    "value": "(train_graphs, test_graphs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "graphs",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Adam_125": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.0005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Accuracy_115": {
                "variable": {
                    "value": "accuracy_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_49": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Conv1D_77": {
                "variable": {
                    "value": "self.conv1d",
                    "type": "Attribute",
                    "possible_values": []
                },
                "filters": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Flatten_78": {
                "variable": {
                    "value": "self.flatten",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_80": {
                "variable": {
                    "value": "self.mlp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[tf.keras.layers.Dense(128, activation=tf.nn.relu), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_119": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_134": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(train_batch_graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(test_batch_graph)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(train_batch_graph.y, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_138": {
                "variable": {
                    "value": "mean_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.one_hot(train_batch_graph.y, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_132": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dense_81": {
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_82": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_84": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "one_hot_136": {
                "indices": {
                    "value": "train_batch_graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([graph.y[0] for graph in graphs]) + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/utils/graph_utils.py": {
        "sklearn": {
            "train_test_split_511": {
                "variable": {
                    "value": "(train_indices, test_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "list(range(num_unique_edges))",
                    "type": "Call",
                    "possible_values": []
                },
                "test_size": {
                    "value": "test_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "test_size",
                            "Method Argument"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "is_tensor_13": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_15": {
                "variable": {
                    "value": "num_nodes_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_17": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_45": {
                "variable": {
                    "value": "edge_hash_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_nodes * row + col",
                            "BinOp"
                        ],
                        [
                            "edge_hash.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_hash, tf.int64)",
                            "Call"
                        ],
                        [
                            "convert_edge_index_to_edge_hash(edge_index)",
                            "Call"
                        ],
                        [
                            "edge_hash",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_50": {
                "variable": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_nodes * row + col",
                            "BinOp"
                        ],
                        [
                            "edge_hash.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_hash, tf.int64)",
                            "Call"
                        ],
                        [
                            "convert_edge_index_to_edge_hash(edge_index)",
                            "Call"
                        ],
                        [
                            "edge_hash",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_51": {
                "variable": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floordiv_53": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_nodes * row + col",
                            "BinOp"
                        ],
                        [
                            "edge_hash.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_hash, tf.int64)",
                            "Call"
                        ],
                        [
                            "convert_edge_index_to_edge_hash(edge_index)",
                            "Call"
                        ],
                        [
                            "edge_hash",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "floormod_54": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_nodes * row + col",
                            "BinOp"
                        ],
                        [
                            "edge_hash.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_hash, tf.int64)",
                            "Call"
                        ],
                        [
                            "convert_edge_index_to_edge_hash(edge_index)",
                            "Call"
                        ],
                        [
                            "edge_hash",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_56": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_57": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_79": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unique_86": {
                "variable": {
                    "value": "(unique_edge_hash, unique_index)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_nodes * row + col",
                            "BinOp"
                        ],
                        [
                            "edge_hash.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_hash, tf.int64)",
                            "Call"
                        ],
                        [
                            "convert_edge_index_to_edge_hash(edge_index)",
                            "Call"
                        ],
                        [
                            "edge_hash",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_135": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_min_140": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_141": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_143": {
                "variable": {
                    "value": "upper_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_164": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "not_equal_180": {
                "variable": {
                    "value": "non_self_loop_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "upper_edge_index[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "upper_edge_index[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "argsort_214": {
                "variable": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "Method Argument"
                        ]
                    ]
                },
                "stable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "gather_215": {
                "variable": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(source_index, stable=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_216": {
                "variable": {
                    "value": "permed_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(source_index, stable=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_219": {
                "variable": {
                    "value": "target_ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_targets]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "segment_sum_220": {
                "variable": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "target_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([num_targets], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sorted_source_index, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_221": {
                "variable": {
                    "value": "max_num_targets_for_sources",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_226": {
                "variable": {
                    "value": "num_targets_before",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([1], dtype=tf.int32), tf.math.cumsum(num_targets_for_sources)[:-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_244": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_seen_sources, k, tf.shape(x)[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_245": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sorted_source_index, target_index_for_source]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_246": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([num_seen_sources, k, tf.shape(x)[-1]], dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(h, index, permed_x)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([sorted_source_index, target_index_for_source], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "permed_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(permed_x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_251": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_252": {
                "variable": {
                    "value": "edge_weight_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "not_equal_255": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floormod(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_max(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "col + tf.expand_dims(node_graph_index, axis=-1) * num_clusters",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "boolean_mask_257": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(target_index_for_source, k)",
                            "Call"
                        ],
                        [
                            "tf.not_equal(row, col)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "meshgrid_272": {
                "variable": {
                    "value": "(row, col)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(num_nodes)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(num_nodes)",
                    "type": "Call",
                    "possible_values": []
                },
                "indexing": {
                    "value": "ij",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_273": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_274": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floormod(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_max(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "col + tf.expand_dims(node_graph_index, axis=-1) * num_clusters",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[1]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_275": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_276": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dense_adj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_adj",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "not_equal_278": {
                "variable": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "boolean_mask_279": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.not_equal(edge_weight, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(row_mask, col_mask)",
                            "Call"
                        ],
                        [
                            "edge_mask.numpy()",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_280": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.not_equal(edge_weight, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(row_mask, col_mask)",
                            "Call"
                        ],
                        [
                            "edge_mask.numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_300": {
                "variable": {
                    "value": "dense_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "dense_assign",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_assign",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "meshgrid_308": {
                "variable": {
                    "value": "(row, col)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(num_nodes)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(num_clusters)",
                    "type": "Call",
                    "possible_values": []
                },
                "indexing": {
                    "value": "ij",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_314": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_315": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floormod(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_max(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "col + tf.expand_dims(node_graph_index, axis=-1) * num_clusters",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[1]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_316": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_318": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dense_assign",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_assign",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_349": {
                "variable": {
                    "value": "diagnal_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(num_nodes, dtype=tf.int32)] * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_350": {
                "variable": {
                    "value": "updated_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[edge_index, diagnal_edge_index]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_422": {
                "variable": {
                    "value": "start_node_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_union_to_numpy(start_node_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "start_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_454": {
                "variable": {
                    "value": "is_edge_index_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_455": {
                "variable": {
                    "value": "is_edge_weight_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_537": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "maximum_539": {
                "variable": {
                    "value": "max_node_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_max(edge_index)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(node_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scatter_nd_540": {
                "variable": {
                    "value": "node_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(node_index, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.ones_like(node_index)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[max_node_index + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_541": {
                "variable": {
                    "value": "node_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "node_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(node_index, axis=-1), tf.ones_like(node_index), [max_node_index + 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(node_mask, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_543": {
                "variable": {
                    "value": "row_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "node_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(node_index, axis=-1), tf.ones_like(node_index), [max_node_index + 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(node_mask, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_544": {
                "variable": {
                    "value": "col_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "node_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(node_index, axis=-1), tf.ones_like(node_index), [max_node_index + 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(node_mask, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floormod(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_max(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "col + tf.expand_dims(node_graph_index, axis=-1) * num_clusters",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "logical_and_545": {
                "variable": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "row_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(node_mask, row)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "col_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(node_mask, col)",
                            "Call"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_557": {
                "variable": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_756": {
                "variable": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pow_757": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_758": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_773": {
                "variable": {
                    "value": "sampled_edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neg_edge_index[:, random_indices].astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.stack([start_node_index, end_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "np.array(sampled_edges, dtype=np.int32).T",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.array(sampled_edge_index).T",
                            "Attribute"
                        ],
                        [
                            "sampled_edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_774": {
                "variable": {
                    "value": "sampled_node_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(sampled_node_index, sampled_edge_index.dtype)",
                            "Call"
                        ],
                        [
                            "np.unique(np.reshape(sampled_edge_index, [-1]))",
                            "Call"
                        ],
                        [
                            "np.concatenate([central_node_index, non_central_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_782": {
                "variable": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(sampled_node_index, sampled_edge_index.dtype)",
                            "Call"
                        ],
                        [
                            "np.unique(np.reshape(sampled_edge_index, [-1]))",
                            "Call"
                        ],
                        [
                            "np.concatenate([central_node_index, non_central_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "sampled_edge_index.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "StaticHashTable_784": {
                "variable": {
                    "value": "node_index_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.lookup.KeyValueTensorInitializer(keys=sampled_node_index, values=tf.range(0, tf.shape(sampled_node_index)[0]))",
                    "type": "Call",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_794": {
                "variable": {
                    "value": "reindexed_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[reindexed_row, reindexed_col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_25": {
                "variable": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(edge_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "num_nodes.numpy()",
                            "Call"
                        ],
                        [
                            "tf.cast(num_nodes, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.shape(dense_adj)[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ],
                        [
                            "num_nodes",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_83": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_138": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_167": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_182": {
                "input_tensor": {
                    "value": "non_self_loop_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.not_equal(upper_edge_index[0], upper_edge_index[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_183": {
                "variable": {
                    "value": "non_self_loop_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "upper_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "merge_duplicated_edge(upper_edge_index, edge_props, merge_modes)",
                            "Call"
                        ],
                        [
                            "upper_edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index, edge_props, merge_modes)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index, [edge_weight], merge_modes=['max'])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "non_self_loop_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.not_equal(upper_edge_index[0], upper_edge_index[1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_184": {
                "variable": {
                    "value": "pure_lower_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[non_self_loop_edge_index[1], non_self_loop_edge_index[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_188": {
                "variable": {
                    "value": "updated_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[upper_edge_index, pure_lower_edge_index]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_259": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(target_index_for_source, k)",
                            "Call"
                        ],
                        [
                            "tf.not_equal(row, col)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_356": {
                "variable": {
                    "value": "diagnal_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill([num_nodes], fill_weight)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_357": {
                "variable": {
                    "value": "updated_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[edge_weight, diagnal_edge_weight]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_403": {
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_448": {
                "variable": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neg_edge_index[:, random_indices].astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.stack([start_node_index, end_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "np.array(sampled_edges, dtype=np.int32).T",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.array(sampled_edge_index).T",
                            "Attribute"
                        ],
                        [
                            "sampled_edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_476": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_502": {
                "variable": {
                    "value": "is_edge_index_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_503": {
                "variable": {
                    "value": "is_edge_weight_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_562": {
                "variable": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(deg)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_618": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "row.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_620": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_748": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(edge_index)[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_777": {
                "variable": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neg_edge_index[:, random_indices].astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.stack([start_node_index, end_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "np.array(sampled_edges, dtype=np.int32).T",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.array(sampled_edge_index).T",
                            "Attribute"
                        ],
                        [
                            "sampled_edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_780": {
                "variable": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(sampled_node_index, sampled_edge_index.dtype)",
                            "Call"
                        ],
                        [
                            "np.unique(np.reshape(sampled_edge_index, [-1]))",
                            "Call"
                        ],
                        [
                            "np.concatenate([central_node_index, non_central_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "executing_eagerly_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_218": {
                "input": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sorted_source_index, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_224": {
                "input": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_231": {
                "params": {
                    "value": "num_targets_before",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros([1], dtype=tf.int32), tf.math.cumsum(num_targets_for_sources)[:-1]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sorted_source_index, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_271": {
                "input": {
                    "value": "dense_adj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_adj",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_352": {
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_481": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_516": {
                "variable": {
                    "value": "undirected_train_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "undirected_train_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "upper_edge_index[:, train_indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(undirected_train_edge_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_517": {
                "variable": {
                    "value": "undirected_test_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "undirected_test_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "upper_edge_index[:, test_indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(undirected_test_edge_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_539": {
                "input_tensor": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(sampled_node_index, central_node_index, non_central_node_index)",
                            "Tuple"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_540": {
                "input": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(sampled_node_index, central_node_index, non_central_node_index)",
                            "Tuple"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_540": {
                "input": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(sampled_node_index, central_node_index, non_central_node_index)",
                            "Tuple"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pow_571": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_572": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_587": {
                "variable": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(deg_inv)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_759": {
                "x": {
                    "value": "tf.math.is_inf(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.is_nan(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_760": {
                "input": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_764": {
                "params": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_max_23": {
                "input_tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_103": {
                "variable": {
                    "value": "edge_prop_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(edge_props, merge_modes)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_prop)",
                            "Call"
                        ],
                        [
                            "zip(edge_props, upper_edge_props, merge_modes)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_104": {
                "variable": {
                    "value": "edge_prop",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(edge_props, merge_modes)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_prop)",
                            "Call"
                        ],
                        [
                            "zip(edge_props, upper_edge_props, merge_modes)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_227": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_239": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "target_index_for_source",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, num_targets) - tf.gather(num_targets_before, sorted_source_index)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(target_index_for_source, mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max_num_targets_for_sources",
                            "variable"
                        ],
                        [
                            "max_num_targets_for_sources",
                            "variable"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_240": {
                "variable": {
                    "value": "target_index_for_source",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_index_for_source",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, num_targets) - tf.gather(num_targets_before, sorted_source_index)",
                            "BinOp"
                        ],
                        [
                            "tf.boolean_mask(target_index_for_source, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(target_index_for_source, k)",
                            "Call"
                        ],
                        [
                            "tf.not_equal(row, col)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_241": {
                "variable": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(sorted_source_index, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(target_index_for_source, k)",
                            "Call"
                        ],
                        [
                            "tf.not_equal(row, col)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_242": {
                "variable": {
                    "value": "permed_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "permed_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(permed_x, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(target_index_for_source, k)",
                            "Call"
                        ],
                        [
                            "tf.not_equal(row, col)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_312": {
                "input": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "fill_356": {
                "dims": {
                    "value": "[num_nodes]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "fill_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "float"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_359": {
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(edge_weight, mask, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_weight.numpy()",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_adj, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_weight, edge_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_assign, [-1])",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight[unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_weight)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_weight, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "tf.gather(deg_inv, row) - edge_weight",
                            "BinOp"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tmp",
                            "variable"
                        ],
                        [
                            "tf.ones(row.shape[0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_404": {
                "value": {
                    "value": "sampled_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "neg_edge_index[:, random_indices].astype(np.int32)",
                            "Call"
                        ],
                        [
                            "np.stack([start_node_index, end_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "np.array(sampled_edges, dtype=np.int32).T",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(sampled_edge_index)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.array(sampled_edge_index).T",
                            "Attribute"
                        ],
                        [
                            "sampled_edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_524": {
                "variable": {
                    "value": "undirected_train_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "undirected_train_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "upper_edge_weight[train_indices]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.convert_to_tensor(undirected_train_edge_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_525": {
                "variable": {
                    "value": "undirected_test_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "undirected_test_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "upper_edge_weight[test_indices]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.convert_to_tensor(undirected_test_edge_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_563": {
                "x": {
                    "value": "tf.math.is_inf(deg)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.is_nan(deg)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_564": {
                "input": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_567": {
                "params": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "is_inf_759": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_759": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "KeyValueTensorInitializer_785": {
                "keys": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(sampled_node_index, sampled_edge_index.dtype)",
                            "Call"
                        ],
                        [
                            "np.unique(np.reshape(sampled_edge_index, [-1]))",
                            "Call"
                        ],
                        [
                            "np.concatenate([central_node_index, non_central_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "values": {
                    "value": "tf.range(0, tf.shape(sampled_node_index)[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "boolean_mask_198": {
                "variable": {
                    "value": "pure_lower_edge_prop",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "upper_edge_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(edge_props, upper_edge_props, merge_modes)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "non_self_loop_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.not_equal(upper_edge_index[0], upper_edge_index[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_199": {
                "variable": {
                    "value": "updated_edge_prop",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[upper_edge_prop, pure_lower_edge_prop]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_228": {
                "x": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_244": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_inf_563": {
                "x": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_563": {
                "x": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_573": {
                "x": {
                    "value": "tf.math.is_inf(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.is_nan(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_574": {
                "input": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_578": {
                "params": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "logical_or_588": {
                "x": {
                    "value": "tf.math.is_inf(deg_inv)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.is_nan(deg_inv)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_589": {
                "input": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_593": {
                "params": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.math.floordiv(edge_hash, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_min(edge_index, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_nodes), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.meshgrid(tf.range(num_nodes), tf.range(num_clusters), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "sampled_edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "executing_eagerly_118": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_inf_573": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_573": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_inf_588": {
                "x": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_588": {
                "x": {
                    "value": "deg_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg), tf.math.is_nan(deg)), tf.zeros_like(deg), deg)",
                            "Call"
                        ],
                        [
                            "1.0 / deg",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv), tf.math.is_nan(deg_inv)), tf.zeros_like(deg_inv), deg_inv)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_748": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(edge_index, tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, mask, axis=1)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_upper(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, np.int32)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "edge_index[:, unique_edge_index]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(edge_index, dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=normed_edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "add_self_loop_edge(edge_index, num_nodes, edge_weight=edge_weight, fill_weight=fill_weight)",
                            "Call"
                        ],
                        [
                            "remove_self_loop_edge(self.edge_index, self.edge_weight)",
                            "Call"
                        ],
                        [
                            "get_laplacian(self.edge_index, self.num_nodes, edge_weight, normalization_type)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "range_787": {},
            "shape_116": {
                "input": {
                    "value": "unique_edge_hash",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique(edge_hash)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_200": {
                "x": {
                    "value": "edge_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(edge_props, merge_modes)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(edge_prop)",
                            "Call"
                        ],
                        [
                            "zip(edge_props, upper_edge_props, merge_modes)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_787": {
                "input": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(sampled_node_index, sampled_edge_index.dtype)",
                            "Call"
                        ],
                        [
                            "np.unique(np.reshape(sampled_edge_index, [-1]))",
                            "Call"
                        ],
                        [
                            "np.concatenate([central_node_index, non_central_node_index], axis=0)",
                            "Call"
                        ],
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "benchmarks/node_classification/bench_node_cls_early_stop_appnp.py": {
        "tensorflow": {
            "Adam_85": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_47": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_48": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_49": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_56": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_57": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vals]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "gather_66": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_67": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_68": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_70": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_71": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_55": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_71": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_51": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "benchmarks/node_classification/bench_node_cls_early_stop_gat.py": {
        "tensorflow": {
            "Adam_143": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.005",
                            "float"
                        ]
                    ]
                }
            },
            "gather_105": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_106": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_107": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_114": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_115": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vals]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "gather_124": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_125": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_126": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_128": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_129": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_83": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.6",
                            "float"
                        ],
                        [
                            "0.6",
                            "float"
                        ],
                        [
                            "0.7",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_113": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_121": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_129": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_148": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_109": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max(graph.y) + 1",
                            "BinOp"
                        ],
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "benchmarks/node_classification/bench_node_cls_early_stop_gcn.py": {
        "tensorflow": {
            "Adam_94": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.01",
                            "float"
                        ]
                    ]
                }
            },
            "gather_56": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_57": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_58": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_65": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_66": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vals]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "gather_75": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_76": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_77": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_79": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_80": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_34": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_64": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_72": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_80": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_99": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_60": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "benchmarks/node_classification/bench_node_cls_early_stop_sgc.py": {
        "tensorflow": {
            "Adam_81": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2",
                            "float"
                        ]
                    ]
                }
            },
            "gather_43": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_44": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_45": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_52": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_53": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vals]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "gather_62": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_63": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_64": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_66": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_67": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_51": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_59": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_67": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_47": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "benchmarks/node_classification/bench_node_cls_early_stop_ssgc.py": {
        "tensorflow": {
            "Adam_101": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_63": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_64": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_65": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_72": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_73": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vals]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "gather_82": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_83": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "current_test_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "current_test_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_84": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_86": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_87": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_41": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_71": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GradientTape_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_87": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_67": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, current_test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_appnp.py": {
        "tensorflow": {
            "Adam_90": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.01",
                            "float"
                        ]
                    ]
                }
            },
            "gather_52": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_53": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_54": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_80": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_81": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_83": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_85": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_86": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_26": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_60": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_62": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_67": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_56": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_62": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_chebynet.py": {
        "tensorflow": {
            "Sequential_17": {
                "variable": {
                    "value": "fc",
                    "type": "variable",
                    "possible_values": []
                },
                "layers": {
                    "value": "[keras.layers.Dropout(0.5), keras.layers.Dense(num_classes)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Adam_48": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_35": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_36": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_37": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_66": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_67": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_69": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_71": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_72": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_18": {
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Dense_19": {
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "l2_loss_43": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_45": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_72": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_39": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_45": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_checkpoint.py": {
        "tensorflow": {
            "Adam_73": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Checkpoint_92": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "GATModel()",
                            "Call"
                        ]
                    ]
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.optimizers.Adam(learning_rate=0.005)",
                            "Call"
                        ]
                    ]
                }
            },
            "Checkpoint_110": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "model": {
                    "value": "restored_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "GATModel()",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_48": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_49": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_50": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_64": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_65": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_66": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_68": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_69": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_24": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.6",
                            "float"
                        ]
                    ]
                }
            },
            "latest_checkpoint_120": {
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'./models'",
                            "str"
                        ]
                    ]
                }
            },
            "l2_loss_56": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_69": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_52": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_58": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_distributed_gcn.py": {
        "tensorflow": {
            "MirroredStrategy_52": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_62": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(y_true, tf.int32)",
                            "Call"
                        ],
                        [
                            "y_true",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_63": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([graph.x, graph.edge_index])",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "train_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_64": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(y_true, tf.int32)",
                            "Call"
                        ],
                        [
                            "y_true",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "train_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_65": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, train_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_82": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([graph.x, graph.edge_index])",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_83": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_85": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, train_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_86": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(masked_labels, y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_87": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.equal(masked_labels, y_pred), tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "Dropout_26": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "reduce_mean_70": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "Adam_74": {
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "equal_86": {
                "x": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, train_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_67": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(y_true, train_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "L1L2_24": {
                "l2": {
                    "value": "l2_coef",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0005",
                            "float"
                        ]
                    ]
                }
            },
            "L1L2_25": {
                "l2": {
                    "value": "l2_coef",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0005",
                            "float"
                        ]
                    ]
                }
            },
            "TensorShape_47": {
                "dims": {
                    "value": "[2, None]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "demo/demo_drop_edge_gcn.py": {
        "tensorflow": {
            "Adam_89": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0005",
                            "float"
                        ]
                    ]
                }
            },
            "gather_63": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_64": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_65": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_79": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_80": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_82": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_84": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_85": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_32": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_71": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_73": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_85": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_67": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_73": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_elegant_api.py": {
        "tensorflow": {}
    },
    "demo/demo_gae.py": {
        "tensorflow": {
            "Dropout_37": {
                "variable": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2",
                            "float"
                        ]
                    ]
                }
            },
            "Adam_96": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_55": {
                "variable": {
                    "value": "embedded_row",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encode(train_graph, training=True)",
                            "Call"
                        ],
                        [
                            "encode(train_graph)",
                            "Call"
                        ],
                        [
                            "embedded",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_56": {
                "variable": {
                    "value": "embedded_col",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encode(train_graph, training=True)",
                            "Call"
                        ],
                        [
                            "encode(train_graph)",
                            "Call"
                        ],
                        [
                            "embedded",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "embedded_row * embedded_col",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_65": {
                "variable": {
                    "value": "pos_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pos_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_graph.edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_edge_index)",
                            "Call"
                        ],
                        [
                            "pos_edge_logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.ones_like(pos_edge_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_70": {
                "variable": {
                    "value": "neg_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "neg_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "neg_edge_logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.zeros_like(neg_edge_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_84": {
                "variable": {
                    "value": "pos_edge_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_graph.edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_edge_index)",
                            "Call"
                        ],
                        [
                            "pos_edge_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_85": {
                "variable": {
                    "value": "neg_edge_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "neg_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "neg_edge_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_87": {
                "variable": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones_like(pos_edge_scores), tf.zeros_like(neg_edge_scores)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_88": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pos_edge_scores, neg_edge_scores]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AUC_90": {
                "variable": {
                    "value": "auc_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "input_tensor": {
                    "value": "neg_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(logits=neg_edge_logits, labels=tf.zeros_like(neg_edge_logits))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_99": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_like_67": {
                "input": {
                    "value": "pos_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_graph.edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_edge_index)",
                            "Call"
                        ],
                        [
                            "pos_edge_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_like_72": {
                "input": {
                    "value": "neg_edge_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predict_edge(embedded, train_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "predict_edge(embedded, undirected_test_neg_edge_index)",
                            "Call"
                        ],
                        [
                            "neg_edge_logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_87": {
                "input": {
                    "value": "pos_edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(pos_edge_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_87": {
                "input": {
                    "value": "neg_edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(neg_edge_logits)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_gat.py": {
        "tensorflow": {
            "Adam_90": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_53": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_54": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_55": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_81": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_82": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_83": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_85": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_86": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_31": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.6",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_61": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_63": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_57": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_63": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_gcn.py": {
        "tensorflow": {
            "Adam_65": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.01",
                            "float"
                        ]
                    ]
                }
            },
            "gather_52": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_53": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_54": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_83": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_84": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_86": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_88": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_89": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_24": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_60": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_62": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=masked_logits, labels=masked_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_70": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_89": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_62": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_save_and_load_model.py": {
        "tensorflow": {
            "Adam_73": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_48": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_49": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_50": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_64": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_65": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_66": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_68": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_69": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_24": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.6",
                            "float"
                        ]
                    ]
                }
            },
            "latest_checkpoint_114": {
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'./models'",
                            "str"
                        ]
                    ]
                }
            },
            "l2_loss_56": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_69": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_52": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_58": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_sgc.py": {
        "tensorflow": {
            "Adam_58": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_31": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_32": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_34": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, mask)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_48": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_49": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_51": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_53": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_54": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_40": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_42": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_54": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_36": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, mask)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_42": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_sparse_node_features.py": {
        "tensorflow": {}
    },
    "demo/demo_ssgc.py": {
        "tensorflow": {
            "Adam_90": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.005",
                            "float"
                        ]
                    ]
                }
            },
            "gather_52": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_53": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_54": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_80": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gather_81": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "test_index",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_83": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, test_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_85": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_86": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_26": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_60": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_62": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_67": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_56": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, test_index)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_62": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "demo/demo_tagcn.py": {
        "tensorflow": {
            "Adam_77": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_51": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_52": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_53": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, mask)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.one_hot(masked_labels, depth=num_classes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_67": {
                "variable": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "forward(graph, training=True)",
                            "Call"
                        ],
                        [
                            "forward(graph)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_68": {
                "variable": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "graph.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_70": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(logits, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(logits, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_72": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(masked_logits, axis=-1, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_73": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(corrects, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_24": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "l2_loss_59": {
                "t": {
                    "value": "kernel_var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_61": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=masked_logits, labels=tf.one_hot(masked_labels, depth=num_classes))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_73": {
                "x": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(y_pred, masked_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_55": {
                "indices": {
                    "value": "masked_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(graph.y, mask_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(graph.y, mask)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "graph.y.max() + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "add_n_61": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(kernel_var) for kernel_var in kernel_vars]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/__init__.py": {
        "tensorflow": {
            "enable_eager_execution_10": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/data/dataset.py": {
        "tensorflow": {}
    },
    "tf_geometric/data/graph.py": {
        "tensorflow": {
            "argsort_344": {
                "variable": {
                    "value": "node_sort_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.node_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_345": {
                "variable": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.node_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "node_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.node_graph_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_346": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "node_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.node_graph_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "argsort_352": {
                "variable": {
                    "value": "edge_sort_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.edge_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_353": {
                "variable": {
                    "value": "edge_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.edge_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "edge_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.edge_graph_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_354": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.edge_index",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "edge_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.edge_graph_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_368": {
                "variable": {
                    "value": "num_nodes_list",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.ones([batch_graph.num_nodes])",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "batch_graph.node_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_graphs",
                            "Call"
                        ],
                        [
                            "batch_graph.num_graphs",
                            "Attribute"
                        ]
                    ]
                }
            },
            "concat_370": {
                "variable": {
                    "value": "num_nodes_before_graph",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([1]), tf.math.cumsum(num_nodes_list)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_376": {
                "variable": {
                    "value": "num_edges_list",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.ones([batch_graph.num_edges])",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "batch_graph.edge_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_graphs",
                            "Call"
                        ],
                        [
                            "batch_graph.num_graphs",
                            "Attribute"
                        ]
                    ]
                }
            },
            "concat_377": {
                "variable": {
                    "value": "num_edges_before_graph",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([1]), tf.math.cumsum(num_edges_list)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_115": {
                "x": {
                    "value": "self.edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_116": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_266": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight], merge_modes=[merge_mode])",
                            "Call"
                        ],
                        [
                            "self.edge_index",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.gather(self.edge_index, edge_sort_index, axis=1)",
                            "Call"
                        ],
                        [
                            "batch_graph.edge_index[:, num_edges_before_graph[i]:num_edges_before_graph[i + 1]] - num_nodes_before_graph[i]",
                            "BinOp"
                        ],
                        [
                            "BatchGraph.build_edge_index(graphs)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight, self.edge_graph_index], merge_modes=[merge_mode, 'max'])",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_271": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight], merge_modes=[merge_mode])",
                            "Call"
                        ],
                        [
                            "self.edge_index",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.gather(self.edge_index, edge_sort_index, axis=1)",
                            "Call"
                        ],
                        [
                            "batch_graph.edge_index[:, num_edges_before_graph[i]:num_edges_before_graph[i + 1]] - num_nodes_before_graph[i]",
                            "BinOp"
                        ],
                        [
                            "BatchGraph.build_edge_index(graphs)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight, self.edge_graph_index], merge_modes=[merge_mode, 'max'])",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_edge_mask_by_node_index(edge_index, sampled_node_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_277": {
                "variable": {
                    "value": "new_node_range",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_279": {
                "variable": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill([max_sampled_node_index + 1], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_280": {
                "variable": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([max_sampled_node_index + 1], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(reverse_index, tf.expand_dims(sampled_node_index, axis=-1), new_node_range)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(sampled_node_index, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "new_node_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(num_sampled_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_283": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([max_sampled_node_index + 1], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(reverse_index, tf.expand_dims(sampled_node_index, axis=-1), new_node_range)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(reverse_index, row)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_284": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([max_sampled_node_index + 1], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(reverse_index, tf.expand_dims(sampled_node_index, axis=-1), new_node_range)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(reverse_index, col)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_286": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_338": {
                "x": {
                    "value": "self.node_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_350": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.y",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "node_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.node_graph_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_359": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.edge_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "edge_sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(self.edge_graph_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_429": {
                "x": {
                    "value": "graphs[0].edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_432": {
                "variable": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "node_graph_index_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_433": {
                "variable": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.node_graph_index",
                            "Attribute"
                        ],
                        [
                            "sample_common_data(node_graph_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.node_graph_index, node_sort_index)",
                            "Call"
                        ],
                        [
                            "BatchGraph.build_node_graph_index(graphs)",
                            "Call"
                        ],
                        [
                            "tf.concat(node_graph_index_list, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(node_graph_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.concatenate(node_graph_index_list, axis=0)",
                            "Call"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_444": {
                "x": {
                    "value": "graphs[0].edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_447": {
                "variable": {
                    "value": "edge_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "edge_graph_index_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_448": {
                "variable": {
                    "value": "edge_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.edge_graph_index",
                            "Attribute"
                        ],
                        [
                            "sample_by_edge_mask(edge_graph_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.edge_graph_index, edge_sort_index)",
                            "Call"
                        ],
                        [
                            "BatchGraph.build_edge_graph_index(graphs)",
                            "Call"
                        ],
                        [
                            "tf.concat(edge_graph_index_list, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_graph_index, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.concatenate(edge_graph_index_list, axis=0)",
                            "Call"
                        ],
                        [
                            "edge_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_460": {
                "x": {
                    "value": "first_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_list[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "is_tensor_478": {
                "x": {
                    "value": "graphs[0].edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_43": {
                "x": {
                    "value": "self.edge_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_44": {
                "variable": {
                    "value": "self.edge_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_75": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(x).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "x.astype(np.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(x)",
                            "Call"
                        ],
                        [
                            "x.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.x",
                            "Attribute"
                        ],
                        [
                            "sample_common_data(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.x, node_sort_index)",
                            "Call"
                        ],
                        [
                            "tf.sparse.slice(batch_graph.x, [num_nodes_before_graph[i], 0], [num_nodes_before_graph[i + 1] - num_nodes_before_graph[i], tf.shape(batch_graph.x)[-1]])",
                            "Call"
                        ],
                        [
                            "batch_graph.x[num_nodes_before_graph[i]:num_nodes_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_x(graphs)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_124": {
                "pred": {
                    "value": "shape[0] == 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "return_empty_num_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "return_empty_num_edges",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "return_common_num_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "return_common_num_edges",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_242": {
                "variable": {
                    "value": "data_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_268": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight], merge_modes=[merge_mode])",
                            "Call"
                        ],
                        [
                            "self.edge_index",
                            "Attribute"
                        ],
                        [
                            "tf.convert_to_tensor(edge_index, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(edge_index, edge_mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([row, col], axis=0)",
                            "Call"
                        ],
                        [
                            "edge_index.numpy()",
                            "Call"
                        ],
                        [
                            "tf.gather(self.edge_index, edge_sort_index, axis=1)",
                            "Call"
                        ],
                        [
                            "batch_graph.edge_index[:, num_edges_before_graph[i]:num_edges_before_graph[i + 1]] - num_nodes_before_graph[i]",
                            "BinOp"
                        ],
                        [
                            "BatchGraph.build_edge_index(graphs)",
                            "Call"
                        ],
                        [
                            "convert_edge_to_directed(self.edge_index, [self.edge_weight, self.edge_graph_index], merge_modes=[merge_mode, 'max'])",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_368": {
                "shape": {
                    "value": "[batch_graph.num_nodes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_376": {
                "shape": {
                    "value": "[batch_graph.num_edges]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_385": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "batch_graph.x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "begin": {
                    "value": "[num_nodes_before_graph[i], 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[num_nodes_before_graph[i + 1] - num_nodes_before_graph[i], tf.shape(batch_graph.x)[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_479": {
                "values": {
                    "value": "edge_index_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_487": {
                "x": {
                    "value": "graphs[0].edge_weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_500": {
                "x": {
                    "value": "graphs[0].y",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_54": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(x).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "x.astype(np.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(x)",
                            "Call"
                        ],
                        [
                            "x.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.x",
                            "Attribute"
                        ],
                        [
                            "sample_common_data(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.x, node_sort_index)",
                            "Call"
                        ],
                        [
                            "tf.sparse.slice(batch_graph.x, [num_nodes_before_graph[i], 0], [num_nodes_before_graph[i + 1] - num_nodes_before_graph[i], tf.shape(batch_graph.x)[-1]])",
                            "Call"
                        ],
                        [
                            "batch_graph.x[num_nodes_before_graph[i]:num_nodes_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_x(graphs)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_55": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(x).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "x.astype(np.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(x)",
                            "Call"
                        ],
                        [
                            "x.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.x",
                            "Attribute"
                        ],
                        [
                            "sample_common_data(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.x, node_sort_index)",
                            "Call"
                        ],
                        [
                            "tf.sparse.slice(batch_graph.x, [num_nodes_before_graph[i], 0], [num_nodes_before_graph[i + 1] - num_nodes_before_graph[i], tf.shape(batch_graph.x)[-1]])",
                            "Call"
                        ],
                        [
                            "batch_graph.x[num_nodes_before_graph[i]:num_nodes_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_x(graphs)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_64": {
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(edge_weight).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_weight, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.edge_weight",
                            "Attribute"
                        ],
                        [
                            "sample_by_edge_mask(edge_weight)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.gather(self.edge_weight, edge_sort_index)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "batch_graph.edge_weight[num_edges_before_graph[i]:num_edges_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_edge_weight(graphs)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_65": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(edge_weight).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(edge_weight, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.edge_weight",
                            "Attribute"
                        ],
                        [
                            "sample_by_edge_mask(edge_weight)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.gather(self.edge_weight, edge_sort_index)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "batch_graph.edge_weight[num_edges_before_graph[i]:num_edges_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_edge_weight(graphs)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "is_tensor_74": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(x).astype(np.int32)",
                            "Call"
                        ],
                        [
                            "x.astype(np.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.int32)",
                            "Call"
                        ],
                        [
                            "np.array(x)",
                            "Call"
                        ],
                        [
                            "x.astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "self.x",
                            "Attribute"
                        ],
                        [
                            "sample_common_data(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(self.x, node_sort_index)",
                            "Call"
                        ],
                        [
                            "tf.sparse.slice(batch_graph.x, [num_nodes_before_graph[i], 0], [num_nodes_before_graph[i + 1] - num_nodes_before_graph[i], tf.shape(batch_graph.x)[-1]])",
                            "Call"
                        ],
                        [
                            "batch_graph.x[num_nodes_before_graph[i]:num_nodes_before_graph[i + 1]]",
                            "Subscript"
                        ],
                        [
                            "BatchGraph.build_x(graphs)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_275": {
                "input_tensor": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_276": {
                "input": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "fill_279": {
                "dims": {
                    "value": "[max_sampled_node_index + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_280": {
                "input": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "is_tensor_292": {
                "variable": {
                    "value": "data_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_293": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "edge_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_edge_mask_by_node_index(edge_index, sampled_node_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_339": {
                "input_tensor": {
                    "value": "self.node_graph_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_488": {
                "values": {
                    "value": "[graph.edge_weight for graph in graphs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_501": {
                "values": {
                    "value": "[graph.y for graph in graphs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_tensor_170": {
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_171": {
                "value": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_247": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(self, key)",
                            "Call"
                        ],
                        [
                            "convert_union_to_numpy(data)",
                            "Call"
                        ],
                        [
                            "data[sampled_node_index]",
                            "Subscript"
                        ],
                        [
                            "sparse_gather_sub(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.gather(data, sampled_node_index)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(data, edge_mask)",
                            "Call"
                        ],
                        [
                            "data.numpy()",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "sampled_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sampled_node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "fill_431": {
                "dims": {
                    "value": "[graph.num_nodes]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i in range(batch_graph.num_graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_446": {
                "dims": {
                    "value": "[graph.num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i in range(batch_graph.num_graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ],
                        [
                            "i in enumerate(graphs)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_464": {
                "values": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "x_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[graph.x for graph in graphs]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "concat_466": {
                "values": {
                    "value": "x_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[graph.x for graph in graphs]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_388": {
                "input": {
                    "value": "batch_graph.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_371": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cumsum_372": {
                "x": {
                    "value": "num_nodes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(tf.ones([batch_graph.num_nodes]), batch_graph.node_graph_index, num_graphs)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_378": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cumsum_379": {
                "x": {
                    "value": "num_edges_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(tf.ones([batch_graph.num_edges]), batch_graph.edge_graph_index, num_graphs)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/layers/conv/appnp.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/chebynet.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/gat.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/gcn.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/gin.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/graph_sage.py": {
        "tensorflow": {
            "LSTM_391": {
                "variable": {
                    "value": "self.lstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "kernel_units",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.units // 2",
                            "BinOp"
                        ],
                        [
                            "self.units",
                            "Attribute"
                        ],
                        [
                            "self.units // 2",
                            "BinOp"
                        ],
                        [
                            "self.units",
                            "Attribute"
                        ],
                        [
                            "self.units // 2",
                            "BinOp"
                        ],
                        [
                            "self.units",
                            "Attribute"
                        ],
                        [
                            "self.units // 2",
                            "BinOp"
                        ],
                        [
                            "self.units",
                            "Attribute"
                        ],
                        [
                            "self.units // 2",
                            "BinOp"
                        ],
                        [
                            "self.units",
                            "Attribute"
                        ]
                    ]
                },
                "return_sequences": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.kernel_regularizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.bias_regularizer",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/layers/conv/le_conv.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/sgc.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/ssgc.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/conv/tagcn.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/kernel/map_reduce.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/asap.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/common_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/diff_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/min_cut_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/sag_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/pool/set2set.py": {
        "tensorflow": {
            "LSTM_26": {
                "variable": {
                    "value": "self.lstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "num_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_shape[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "return_sequences": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "return_state": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/layers/pool/sort_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/layers/sampling/drop_edge.py": {
        "tensorflow": {}
    },
    "tf_geometric/nn/conv/appnp.py": {
        "tensorflow": {
            "sparse_dense_matmul_67": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "dropout_78": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dense_drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_81": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "last_dense_drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/chebynet.py": {
        "tensorflow": {
            "ones_89": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_dense_matmul_101": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "T0_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.sparse.to_dense(T0_x)",
                            "Call"
                        ],
                        [
                            "T1_x",
                            "variable"
                        ]
                    ]
                },
                "b": {
                    "value": "kernels[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_87": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "remove_self_loop_edge(edge_index, edge_weight)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_dense_108": {
                "variable": {
                    "value": "dense_x",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.to_dense()",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_dense_119": {
                "variable": {
                    "value": "T0_x",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "T0_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.sparse.to_dense(T0_x)",
                            "Call"
                        ],
                        [
                            "T1_x",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/gat.py": {
        "tensorflow": {
            "gather_56": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(x, query_kernel)",
                            "Call"
                        ],
                        [
                            "x @ query_kernel",
                            "BinOp"
                        ],
                        [
                            "Q + query_bias",
                            "BinOp"
                        ],
                        [
                            "query_activation(Q)",
                            "Call"
                        ],
                        [
                            "tf.gather(Q, row)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_65": {
                "variable": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(x, key_kernel)",
                            "Call"
                        ],
                        [
                            "x @ key_kernel",
                            "BinOp"
                        ],
                        [
                            "K + key_bias",
                            "BinOp"
                        ],
                        [
                            "key_activation(K)",
                            "Call"
                        ],
                        [
                            "tf.gather(K, col)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_73": {
                "variable": {
                    "value": "Q_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(Q, num_heads, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_74": {
                "variable": {
                    "value": "K_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(K, num_heads, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_76": {
                "variable": {
                    "value": "qk_edge_index_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[edge_index + i * num_nodes for i in range(num_heads)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_78": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(tf.shape(Q_)[-1], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_dense_matmul_50": {
                "variable": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "query_kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_kernel",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_dense_matmul_59": {
                "variable": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "key_kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "key_kernel",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_dense_matmul_68": {
                "variable": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_88": {
                "variable": {
                    "value": "V_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(V, num_heads, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_91": {
                "variable": {
                    "value": "edge_index_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "add_self_loop_edge(edge_index, num_nodes)",
                            "Call"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_117": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(h_, num_heads, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_73": {
                "value": {
                    "value": "Q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(x, query_kernel)",
                            "Call"
                        ],
                        [
                            "x @ query_kernel",
                            "BinOp"
                        ],
                        [
                            "Q + query_bias",
                            "BinOp"
                        ],
                        [
                            "query_activation(Q)",
                            "Call"
                        ],
                        [
                            "tf.gather(Q, row)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_heads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_74": {
                "value": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(x, key_kernel)",
                            "Call"
                        ],
                        [
                            "x @ key_kernel",
                            "BinOp"
                        ],
                        [
                            "K + key_bias",
                            "BinOp"
                        ],
                        [
                            "key_activation(K)",
                            "Call"
                        ],
                        [
                            "tf.gather(K, col)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_heads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_78": {
                "x": {
                    "value": "tf.shape(Q_)[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_79": {
                "input_tensor": {
                    "value": "Q_ * K_",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_88": {
                "value": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(x, kernel)",
                            "Call"
                        ],
                        [
                            "x @ kernel",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_heads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_117": {
                "value": {
                    "value": "h_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_att_adj @ V_",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_heads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_78": {
                "input": {
                    "value": "Q_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(tf.split(Q, num_heads, axis=-1), axis=0)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/gcn.py": {
        "tensorflow": {
            "pow_52": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "deg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_adj.segment_sum(axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-0.5",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_53": {
                "variable": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tfs.diags(deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_dense_matmul_203": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_or_54": {
                "x": {
                    "value": "tf.math.is_inf(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.is_nan(deg_inv_sqrt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_55": {
                "input": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tfs.diags(deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_inf_54": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tfs.diags(deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_54": {
                "x": {
                    "value": "deg_inv_sqrt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(deg, -0.5)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.logical_or(tf.math.is_inf(deg_inv_sqrt), tf.math.is_nan(deg_inv_sqrt)), tf.zeros_like(deg_inv_sqrt), deg_inv_sqrt)",
                            "Call"
                        ],
                        [
                            "tfs.diags(deg_inv_sqrt)",
                            "Call"
                        ]
                    ]
                }
            },
            "executing_eagerly_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/nn/conv/gin.py": {
        "tensorflow": {
            "shape_31": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/graph_sage.py": {
        "tensorflow": {
            "gather_35": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_36": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_90": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_91": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_144": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_145": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_194": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_195": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_257": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_258": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "argsort_315": {
                "variable": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "direction": {
                    "value": "ASCENDING",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_316": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(row, axis=-1, direction='ASCENDING')",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_317": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(row, axis=-1, direction='ASCENDING')",
                            "Call"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_319": {
                "variable": {
                    "value": "degree",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.ones([num_edges], dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_max_321": {
                "variable": {
                    "value": "num_sampled_neighbors",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "degree",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(tf.ones([num_edges], dtype=tf.int32), row, num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_322": {
                "variable": {
                    "value": "num_edges_before_row",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([1], dtype=tf.int32), tf.math.cumsum(degree)[:-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_325": {
                "variable": {
                    "value": "neighbor_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "(num_nodes, num_sampled_neighbors)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_326": {
                "variable": {
                    "value": "neighbor_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "neighbor_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.fill((num_nodes, num_sampled_neighbors), num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(neighbor_matrix, tf.stack([row, matrix_col_index], axis=1), col)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([row, matrix_col_index], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "edge_index[1]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(col, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_332": {
                "variable": {
                    "value": "padded_x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, tf.zeros([1, tf.shape(x)[-1]], x.dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_334": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "padded_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, tf.zeros([1, tf.shape(x)[-1]], x.dtype)], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "neighbor_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.fill((num_nodes, num_sampled_neighbors), num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(neighbor_matrix, tf.stack([row, matrix_col_index], axis=1), col)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_337": {
                "variable": {
                    "value": "reduced_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "neighbor_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm(neighbor_x, training=training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_47": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, neighbor_msg]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_58": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "h + neighbor_mlp_bias",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "reduced_msg @ kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_102": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, neighbor_msg]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_113": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "h + neighbor_mlp_bias",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "reduced_msg @ kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_140": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "l2_normalize_159": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "h + neighbor_mlp_bias",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, neighbor_msg], axis=1)",
                            "Call"
                        ],
                        [
                            "x + neighbor_msg",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "reduced_msg @ kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(h, axis=-1)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ],
                        [
                            "neighbor_x @ neighbor_mlp_kernel",
                            "BinOp"
                        ],
                        [
                            "activation(h)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_191": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_212": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[from_x, from_neighbor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_223": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "output + bias",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighs], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighs",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_254": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_274": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[from_x, from_neighs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_285": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "output + bias",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighs], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighs",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_343": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[from_x, from_neighbor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "l2_normalize_354": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "output + bias",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighs], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighs",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([from_x, from_neighbor], axis=1)",
                            "Call"
                        ],
                        [
                            "from_x + from_neighbor",
                            "BinOp"
                        ],
                        [
                            "activation(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(output, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_31": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_86": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_136": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_137": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_187": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_188": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_250": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_251": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_310": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_311": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_319": {
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_323": {
                "params": {
                    "value": "num_edges_before_row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros([1], dtype=tf.int32), tf.math.cumsum(degree)[:-1]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "edge_index[0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(row, sort_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_328": {
                "values": {
                    "value": "[row, matrix_col_index]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_322": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_332": {
                "shape": {
                    "value": "[1, tf.shape(x)[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cumsum_322": {
                "x": {
                    "value": "degree",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(tf.ones([num_edges], dtype=tf.int32), row, num_nodes)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_332": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x @ self_kernel",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/le_conv.py": {
        "tensorflow": {
            "gather_42": {
                "variable": {
                    "value": "repeated_aggr_self_h",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "aggr_self_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ aggr_self_kernel",
                            "BinOp"
                        ],
                        [
                            "aggr_self_h + aggr_self_bias",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_43": {
                "variable": {
                    "value": "repeated_aggr_neighbor_h",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "aggr_neighbor_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x @ aggr_neighbor_kernel",
                            "BinOp"
                        ],
                        [
                            "aggr_neighbor_h + aggr_neighbor_bias",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_45": {
                "variable": {
                    "value": "aggr_h",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "repeated_aggr_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(repeated_aggr_self_h - repeated_aggr_neighbor_h) * tf.expand_dims(edge_weight, axis=-1)",
                            "BinOp"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_25": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(edge_index)[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_27": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_44": {
                "input": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([tf.shape(edge_index)[1]], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "edge_weight",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_25": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/sgc.py": {
        "tensorflow": {
            "sparse_dense_matmul_32": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/ssgc.py": {
        "tensorflow": {
            "sparse_dense_matmul_73": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "normed_sparse_adj @ h",
                            "BinOp"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "dropout_84": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "normed_sparse_adj @ h",
                            "BinOp"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dense_drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_87": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "normed_sparse_adj @ h",
                            "BinOp"
                        ],
                        [
                            "tf.sparse.sparse_dense_matmul(h, kernel)",
                            "Call"
                        ],
                        [
                            "h @ kernel",
                            "BinOp"
                        ],
                        [
                            "h + bias",
                            "BinOp"
                        ],
                        [
                            "dense_activation(h)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, last_dense_drop_rate)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(h, dense_drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "last_dense_drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/conv/tagcn.py": {
        "tensorflow": {
            "concat_42": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_dense_33": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.to_dense(x)",
                            "Call"
                        ],
                        [
                            "x.to_dense()",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/kernel/map_reduce.py": {
        "tensorflow": {
            "gather_62": {
                "variable": {
                    "value": "repeated_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_63": {
                "variable": {
                    "value": "neighbor_x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_12": {
                "shape": {
                    "value": "[neighbor_x.shape[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_16": {
                "data": {
                    "value": "neighbor_msg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mapper(repeated_x, neighbor_x, edge_weight=edge_weight)",
                            "Call"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_mean_28": {
                "data": {
                    "value": "neighbor_msg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mapper(repeated_x, neighbor_x, edge_weight=edge_weight)",
                            "Call"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_41": {
                "variable": {
                    "value": "max_neighbor_msg",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "neighbor_msg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mapper(repeated_x, neighbor_x, edge_weight=edge_weight)",
                            "Call"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ],
                        [
                            "neighbor_msg",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_57": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_68": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_34": {
                "input_tensor": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_40": {
                "input_tensor": {
                    "value": "node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ],
                        [
                            "node_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/kernel/segment.py": {
        "tensorflow": {
            "argsort_7": {
                "variable": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_8": {
                "variable": {
                    "value": "sorted_segment_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(segment_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_9": {
                "variable": {
                    "value": "sorted_data",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(index)",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(segment_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_14": {
                "variable": {
                    "value": "pad_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[[num_paddings], tf.shape(data)[1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_18": {
                "variable": {
                    "value": "pads",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "pad_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([[num_paddings], tf.shape(data)[1:]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "reduced_data.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_19": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[reduced_data, pads]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsorted_segment_max_27": {
                "variable": {
                    "value": "max_values",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(index)",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(index) + 1",
                            "BinOp"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_28": {
                "variable": {
                    "value": "gathered_max_values",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "max_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_max(data, segment_ids, num_segments=num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_29": {
                "variable": {
                    "value": "exp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "data - tf.stop_gradient(gathered_max_values)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_31": {
                "variable": {
                    "value": "gathered_denominator",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "denominator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(exp, segment_ids, num_segments=num_segments) + 1e-08",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_37": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_40": {
                "data": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(index)",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(index) + 1",
                            "BinOp"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_30": {
                "data": {
                    "value": "exp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(data - tf.stop_gradient(gathered_max_values))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_ids",
                            "Method Argument"
                        ],
                        [
                            "segment_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(index) + 1",
                            "BinOp"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "num_segments",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_12": {
                "input": {
                    "value": "reduced_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_op(sorted_data, sorted_segment_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_29": {
                "input": {
                    "value": "gathered_max_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(max_values, segment_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_39": {
                "input_tensor": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_16": {
                "input": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(index)",
                            "Call"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/pool/asap.py": {
        "tensorflow": {
            "gather_67": {
                "variable": {
                    "value": "repeated_attention_query",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "attention_query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "aggregate_neighbors(attention_h, edge_index_with_self_loop, None, mapper=identity_mapper, reducer=max_reducer, updater=identity_updater, num_nodes=num_nodes)",
                            "Call"
                        ],
                        [
                            "attention_query @ attention_query_kernel + attention_query_bias",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "row_with_self_loop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index_with_self_loop[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_68": {
                "variable": {
                    "value": "repeated_attention_h",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "attention_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gcn(x, edge_index, edge_weight, attention_gcn_kernel, attention_gcn_bias, cache=cache)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "col_with_self_loop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index_with_self_loop[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_70": {
                "variable": {
                    "value": "attention_score_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[repeated_attention_query, repeated_attention_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "leaky_relu_72": {
                "variable": {
                    "value": "attention_score",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "attention_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "attention_score_h @ attention_score_kernel + attention_score_bias",
                            "BinOp"
                        ],
                        [
                            "tf.nn.leaky_relu(attention_score, alpha=0.2)",
                            "Call"
                        ]
                    ]
                },
                "alpha": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "gather_94": {
                "variable": {
                    "value": "topk_node_score",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "node_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "le_conv(cluster_h, edge_index, edge_weight, le_conv_self_kernel, le_conv_self_bias, le_conv_aggr_self_kernel, le_conv_aggr_self_bias, le_conv_aggr_neighbor_kernel, le_conv_aggr_neighbor_bias, activation=None)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "topk_pool(node_graph_index, node_score, k=k, ratio=ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_102": {
                "variable": {
                    "value": "cluster_reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill([num_nodes], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_103": {
                "variable": {
                    "value": "cluster_reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "cluster_reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([num_nodes], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(cluster_reverse_index, tf.expand_dims(topk_node_index, axis=-1), tf.range(num_clusters))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(topk_node_index, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.range(num_clusters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_110": {
                "variable": {
                    "value": "assign_row",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "cluster_reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([num_nodes], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(cluster_reverse_index, tf.expand_dims(topk_node_index, axis=-1), tf.range(num_clusters))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row_with_self_loop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index_with_self_loop[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "greater_equal_111": {
                "variable": {
                    "value": "assign_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "assign_row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(cluster_reverse_index, row_with_self_loop)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(assign_row, assign_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_113": {
                "variable": {
                    "value": "assign_row",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assign_row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(cluster_reverse_index, row_with_self_loop)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(assign_row, assign_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "assign_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(assign_row, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_114": {
                "variable": {
                    "value": "assign_col",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "col_with_self_loop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index_with_self_loop[1]",
                            "Subscript"
                        ]
                    ]
                },
                "mask": {
                    "value": "assign_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(assign_row, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_115": {
                "variable": {
                    "value": "assign_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[assign_row, assign_col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_117": {
                "variable": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "normed_attention_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_softmax(attention_score, row_with_self_loop, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(normed_attention_score, rate=drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "assign_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(assign_row, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_118": {
                "variable": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(normed_attention_score, assign_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(assign_edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(assign_edge_weight)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stop_gradient_119": {
                "variable": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(normed_attention_score, assign_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(assign_edge_weight, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(assign_edge_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_129": {
                "variable": {
                    "value": "pooled_node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "topk_pool(node_graph_index, node_score, k=k, ratio=ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_76": {
                "variable": {
                    "value": "normed_attention_score",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "normed_attention_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_softmax(attention_score, row_with_self_loop, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(normed_attention_score, rate=drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "drop_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_45": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_80": {
                "tensor": {
                    "value": "normed_attention_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_softmax(attention_score, row_with_self_loop, num_nodes)",
                            "Call"
                        ],
                        [
                            "tf.compat.v2.nn.dropout(normed_attention_score, rate=drop_rate)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_98": {
                "params": {
                    "value": "cluster_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "aggregate_neighbors(x, edge_index_with_self_loop, tf.reshape(normed_attention_score, [-1]), gcn_mapper, sum_reducer, identity_updater, num_nodes=num_nodes)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "topk_pool(node_graph_index, node_score, k=k, ratio=ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_100": {
                "input": {
                    "value": "topk_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "topk_pool(node_graph_index, node_score, k=k, ratio=ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_102": {
                "dims": {
                    "value": "[num_nodes]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_105": {
                "input": {
                    "value": "topk_node_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "topk_pool(node_graph_index, node_score, k=k, ratio=ratio)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/nn/pool/cluster_pool.py": {
        "tensorflow": {
            "shape_29": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/pool/common_pool.py": {
        "tensorflow": {
            "unsorted_segment_sum_11": {
                "variable": {
                    "value": "sum_x",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_18": {
                "variable": {
                    "value": "sum_x",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_44": {
                "variable": {
                    "value": "max_x",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_min_51": {
                "variable": {
                    "value": "min_x",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_9": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_12": {
                "x": {
                    "value": "tf.expand_dims(num_nodes_of_graphs, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_17": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_12": {
                "input": {
                    "value": "num_nodes_of_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_count(node_graph_index, num_segments=num_graphs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_26": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_34": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_43": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_50": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/pool/diff_pool.py": {
        "tensorflow": {
            "shape_27": {
                "variable": {
                    "value": "dense_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "dense_assign",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_assign",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_50": {
                "variable": {
                    "value": "pooled_node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(tf.expand_dims(tf.range(num_graphs), axis=-1), [1, num_clusters])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_92": {
                "variable": {
                    "value": "assign_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "assign_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assign_gnn([x, edge_index, edge_weight], training=training)",
                            "Call"
                        ],
                        [
                            "assign_gnn([x, edge_index, edge_weight], training=training, cache=cache)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_40": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_80": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_50": {
                "input": {
                    "value": "tf.expand_dims(tf.range(num_graphs), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_clusters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_82": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_83": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_36": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_39": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_50": {
                "input": {
                    "value": "tf.range(num_graphs)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_79": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/pool/min_cut_pool.py": {
        "tensorflow": {
            "sparse_dense_matmul_10": {
                "variable": {
                    "value": "STAT",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "transposed_S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "transposed_S",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.sparse.to_dense(transposed_A)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_11": {
                "variable": {
                    "value": "diag",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "transposed_S * STAT",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_13": {
                "variable": {
                    "value": "diag",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "diag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.reduce_sum(transposed_S * STAT, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(diag, [-1, num_clusters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_clusters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_14": {
                "variable": {
                    "value": "trace",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "diag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.reduce_sum(transposed_S * STAT, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(diag, [-1, num_clusters])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_20": {
                "variable": {
                    "value": "dense_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "dense_assign",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_assign",
                            "Method Argument"
                        ],
                        [
                            "dense_assign",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_29": {
                "variable": {
                    "value": "degree",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "normed_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, add_self_loop=False, cache=cache)",
                            "Call"
                        ],
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, cache=cache)",
                            "Call"
                        ],
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, add_self_loop=False, cache=cache)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_nodes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[0]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "SparseTensor_37": {
                "variable": {
                    "value": "transposed_sparse_assign_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.cast(tf.stack([assign_col, assign_row], axis=1), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "values": {
                    "value": "assign_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "convert_dense_assign_to_edge(dense_assign, node_graph_index, num_nodes=num_nodes, num_clusters=num_clusters)",
                            "Call"
                        ],
                        [
                            "convert_dense_assign_to_edge(dense_assign, node_graph_index, num_nodes=num_nodes, num_clusters=num_clusters)",
                            "Call"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "[num_clusters * num_graphs, num_nodes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reorder_42": {
                "variable": {
                    "value": "transposed_sparse_assign_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "transposed_sparse_assign_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.SparseTensor(indices=tf.cast(tf.stack([assign_col, assign_row], axis=1), dtype=tf.int64), values=assign_edge_weight, dense_shape=[num_clusters * num_graphs, num_nodes])",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(transposed_sparse_assign_probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "SparseTensor_45": {
                "variable": {
                    "value": "transposed_sparse_adj",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.cast(tf.transpose(edge_index, [1, 0]), dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "values": {
                    "value": "normed_edge_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, add_self_loop=False, cache=cache)",
                            "Call"
                        ],
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, cache=cache)",
                            "Call"
                        ],
                        [
                            "adj_norm_edge(edge_index, num_nodes, edge_weight, add_self_loop=False, cache=cache)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "[num_nodes, num_nodes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reorder_51": {
                "variable": {
                    "value": "transposed_sparse_adj",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "transposed_sparse_adj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.SparseTensor(indices=tf.cast(tf.transpose(edge_index, [1, 0]), dtype=tf.int64), values=normed_edge_weight, dense_shape=[num_nodes, num_nodes])",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(transposed_sparse_adj)",
                            "Call"
                        ]
                    ]
                }
            },
            "SparseTensor_54": {
                "variable": {
                    "value": "transposed_sparse_degree",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([tf.range(0, num_nodes, dtype=tf.int64), tf.range(0, num_nodes, dtype=tf.int64)], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "values": {
                    "value": "degree",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.unsorted_segment_sum(normed_edge_weight, row, num_segments=num_nodes)",
                            "Call"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "[num_nodes, num_nodes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reorder_59": {
                "variable": {
                    "value": "transposed_sparse_degree",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "transposed_sparse_degree",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.SparseTensor(indices=tf.stack([tf.range(0, num_nodes, dtype=tf.int64), tf.range(0, num_nodes, dtype=tf.int64)], axis=1), values=degree, dense_shape=[num_nodes, num_nodes])",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(transposed_sparse_degree)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_69": {
                "variable": {
                    "value": "cut_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-intra_edge_sum / (all_edge_sum + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_74": {
                "variable": {
                    "value": "sparse_assign_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "transposed_sparse_assign_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.SparseTensor(indices=tf.cast(tf.stack([assign_col, assign_row], axis=1), dtype=tf.int64), values=assign_edge_weight, dense_shape=[num_clusters * num_graphs, num_nodes])",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(transposed_sparse_assign_probs)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_dense_matmul_76": {
                "variable": {
                    "value": "STS",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_a": {
                    "value": "transposed_sparse_assign_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.SparseTensor(indices=tf.cast(tf.stack([assign_col, assign_row], axis=1), dtype=tf.int64), values=assign_edge_weight, dense_shape=[num_clusters * num_graphs, num_nodes])",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(transposed_sparse_assign_probs)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.sparse.to_dense(sparse_assign_probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "STS",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "STS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(transposed_sparse_assign_probs, tf.sparse.to_dense(sparse_assign_probs))",
                            "Call"
                        ],
                        [
                            "STS @ tf.tile(tf.eye(num_clusters, dtype=tf.float32), [num_graphs, 1])",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(STS, [-1, num_clusters, num_clusters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_clusters, num_clusters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "norm_82": {
                "variable": {
                    "value": "norm_STS",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "STS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(transposed_sparse_assign_probs, tf.sparse.to_dense(sparse_assign_probs))",
                            "Call"
                        ],
                        [
                            "STS @ tf.tile(tf.eye(num_clusters, dtype=tf.float32), [num_graphs, 1])",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(STS, [-1, num_clusters, num_clusters])",
                            "Call"
                        ]
                    ]
                },
                "ord": {
                    "value": "euclidean",
                    "type": "str",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-2, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_89": {
                "variable": {
                    "value": "orth_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.norm(deviation, ord='euclidean', axis=[-2, -1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_112": {
                "variable": {
                    "value": "dense_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "dense_assign",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_assign",
                            "Method Argument"
                        ],
                        [
                            "dense_assign",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_140": {
                "variable": {
                    "value": "pooled_node_graph_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(tf.expand_dims(tf.range(num_graphs), axis=-1), [1, num_clusters])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_204": {
                "variable": {
                    "value": "assign_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "assign_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assign_gnn([x, edge_index, gnn_edge_weight], training=training)",
                            "Call"
                        ],
                        [
                            "assign_gnn([x, edge_index, gnn_edge_weight], training=training, cache=cache)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_125": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_184": {
                "variable": {
                    "value": "edge_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_edges]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_dense_10": {
                "sp_input": {
                    "value": "transposed_A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "transposed_A",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_23": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_dense_76": {
                "sp_input": {
                    "value": "sparse_assign_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.transpose(transposed_sparse_assign_probs, [1, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_78": {
                "input": {
                    "value": "tf.eye(num_clusters, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_graphs, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "norm_89": {
                "tensor": {
                    "value": "deviation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "normed_STS - tf.eye(tf.shape(normed_STS)[1], batch_shape=[tf.shape(STS)[0]]) / tf.sqrt(tf.cast(num_clusters, tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "ord": {
                    "value": "euclidean",
                    "type": "str",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_140": {
                "input": {
                    "value": "tf.expand_dims(tf.range(num_graphs), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_clusters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_186": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_187": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_38": {
                "x": {
                    "value": "tf.stack([assign_col, assign_row], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_47": {
                "x": {
                    "value": "tf.transpose(edge_index, [1, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_55": {
                "values": {
                    "value": "[tf.range(0, num_nodes, dtype=tf.int64), tf.range(0, num_nodes, dtype=tf.int64)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "eye_78": {
                "num_rows": {
                    "value": "num_clusters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_shape[1]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[1]",
                            "Subscript"
                        ],
                        [
                            "num_clusters",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_clusters",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "eye_86": {
                "num_rows": {
                    "value": "tf.shape(normed_STS)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "batch_shape": {
                    "value": "[tf.shape(STS)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_86": {
                "x": {
                    "value": "tf.cast(num_clusters, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_121": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ],
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_124": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_140": {
                "input": {
                    "value": "tf.range(num_graphs)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_183": {
                "input": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_38": {
                "values": {
                    "value": "[assign_col, assign_row]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_47": {
                "a": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ],
                        [
                            "edge_index",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_87": {
                "x": {
                    "value": "num_clusters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense_shape[1]",
                            "Subscript"
                        ],
                        [
                            "dense_shape[1]",
                            "Subscript"
                        ],
                        [
                            "num_clusters",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "num_clusters",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_55": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_86": {
                "input": {
                    "value": "STS",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.sparse_dense_matmul(transposed_sparse_assign_probs, tf.sparse.to_dense(sparse_assign_probs))",
                            "Call"
                        ],
                        [
                            "STS @ tf.tile(tf.eye(num_clusters, dtype=tf.float32), [num_graphs, 1])",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(STS, [-1, num_clusters, num_clusters])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/nn/pool/sag_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/nn/pool/set2set.py": {
        "tensorflow": {
            "zeros_25": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_graphs, lstm_units * 2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_30": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([num_graphs, lstm_units * 2], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(h, axis=0)",
                            "Call"
                        ],
                        [
                            "lstm(h, initial_state=initial_state, training=training)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(h, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([h, att_h], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_33": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([num_graphs, lstm_units * 2], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(h, axis=0)",
                            "Call"
                        ],
                        [
                            "lstm(h, initial_state=initial_state, training=training)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(h, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([h, att_h], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_35": {
                "variable": {
                    "value": "repeated_h",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([num_graphs, lstm_units * 2], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(h, axis=0)",
                            "Call"
                        ],
                        [
                            "lstm(h, initial_state=initial_state, training=training)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(h, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([h, att_h], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_37": {
                "variable": {
                    "value": "att_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x * repeated_h",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_39": {
                "variable": {
                    "value": "att_h",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "x * normed_att_score",
                    "type": "BinOp",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_graphs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(node_graph_index) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_40": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[h, att_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_21": {
                "input_tensor": {
                    "value": "node_graph_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "node_graph_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_23": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_26": {
                "shape": {
                    "value": "[1, lstm_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/nn/pool/sort_pool.py": {
        "tensorflow": {}
    },
    "tf_geometric/nn/pool/topk_pool.py": {
        "tensorflow": {
            "reshape_34": {
                "variable": {
                    "value": "sorted_score",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sorted_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "score",
                            "variable"
                        ],
                        [
                            "tf.gather(score, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sorted_score, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_37": {
                "variable": {
                    "value": "target_ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_targets]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "segment_sum_38": {
                "variable": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "target_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([num_targets], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "variable"
                        ],
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_40": {
                "variable": {
                    "value": "num_cols",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_45": {
                "variable": {
                    "value": "min_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sorted_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "score",
                            "variable"
                        ],
                        [
                            "tf.gather(score, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sorted_score, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_47": {
                "variable": {
                    "value": "num_targets_before",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([1], dtype=tf.int32), tf.math.cumsum(num_targets_for_sources)[:-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_54": {
                "variable": {
                    "value": "score_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill([num_seen_sources, num_cols], min_score - 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_55": {
                "variable": {
                    "value": "score_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sorted_source_index, target_index_for_source]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_56": {
                "variable": {
                    "value": "score_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "score_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([num_seen_sources, num_cols], min_score - 1.0), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(score_matrix, score_index, sorted_score)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "score_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([sorted_source_index, target_index_for_source], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "sorted_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "score",
                            "variable"
                        ],
                        [
                            "tf.gather(score, source_index_perm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sorted_score, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "argsort_58": {
                "variable": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "score_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([num_seen_sources, num_cols], min_score - 1.0), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(score_matrix, score_index, sorted_score)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "direction": {
                    "value": "DESCENDING",
                    "type": "str",
                    "possible_values": []
                }
            },
            "meshgrid_71": {
                "variable": {
                    "value": "(row, col)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(num_seen_sources)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(tf.reduce_max(node_k))",
                    "type": "Call",
                    "possible_values": []
                },
                "indexing": {
                    "value": "ij",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_72": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(row, k_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_73": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(col, k_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_74": {
                "variable": {
                    "value": "repeated_k",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "node_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(tf.cast(tf.fill([num_seen_sources], k), dtype=tf.int32), num_targets_for_sources)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.math.ceil(tf.cast(num_targets_for_sources, dtype=tf.float32) * tf.cast(ratio, dtype=tf.float32)), dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(row, k_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_75": {
                "variable": {
                    "value": "k_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(col, k_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "repeated_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(node_k, row)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_77": {
                "variable": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(row, k_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "k_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(col, repeated_k)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_78": {
                "variable": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(col, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(col, k_mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "k_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(col, repeated_k)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_80": {
                "variable": {
                    "value": "sample_col_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sort_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(score_matrix, axis=-1, direction='DESCENDING')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([row, col], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argsort_30": {
                "variable": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_31": {
                "variable": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_32": {
                "variable": {
                    "value": "sorted_score",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "score",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_61": {
                "variable": {
                    "value": "node_k",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(tf.fill([num_seen_sources], k), dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_66": {
                "variable": {
                    "value": "node_k",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.ceil(tf.cast(num_targets_for_sources, dtype=tf.float32) * tf.cast(ratio, dtype=tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_36": {
                "input": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "variable"
                        ],
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_43": {
                "input": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_52": {
                "params": {
                    "value": "num_targets_before",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros([1], dtype=tf.int32), tf.math.cumsum(num_targets_for_sources)[:-1]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "sorted_source_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "source_index",
                            "variable"
                        ],
                        [
                            "tf.gather(source_index, source_index_perm)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_54": {
                "dims": {
                    "value": "[num_seen_sources, num_cols]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "min_score - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_80": {
                "values": {
                    "value": "[row, col]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_82": {
                "params": {
                    "value": "num_targets_before",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros([1], dtype=tf.int32), tf.math.cumsum(num_targets_for_sources)[:-1]], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(tf.range(num_seen_sources), tf.range(tf.reduce_max(node_k)), indexing='ij')",
                            "Call"
                        ],
                        [
                            "tf.reshape(row, [-1])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(row, k_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_87": {
                "params": {
                    "value": "source_index_perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(source_index)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "topk_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(num_targets_before, row) + sample_col_index",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_48": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_62": {
                "x": {
                    "value": "tf.fill([num_seen_sources], k)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ceil_67": {
                "x": {
                    "value": "tf.cast(num_targets_for_sources, dtype=tf.float32) * tf.cast(ratio, dtype=tf.float32)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_max_71": {
                "input_tensor": {
                    "value": "node_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(tf.cast(tf.fill([num_seen_sources], k), dtype=tf.int32), num_targets_for_sources)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.math.ceil(tf.cast(num_targets_for_sources, dtype=tf.float32) * tf.cast(ratio, dtype=tf.float32)), dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_49": {
                "x": {
                    "value": "num_targets_for_sources",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.segment_sum(target_ones, sorted_source_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_62": {
                "dims": {
                    "value": "[num_seen_sources]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_67": {
                "x": {
                    "value": "ratio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/nn/sampling/drop_edge.py": {
        "tensorflow": {
            "is_tensor_27": {
                "variable": {
                    "value": "edge_index_is_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_29": {
                "variable": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_33": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(row, col)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "boolean_mask_34": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(row, col))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(index, tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([index, index], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.range(0, tf.shape(row)[0]), tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_35": {
                "variable": {
                    "value": "dropped_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(row, col))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(index, tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([index, index], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.range(0, tf.shape(row)[0]), tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_36": {
                "variable": {
                    "value": "dropped_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dropped_edge_index, tf.gather(dropped_edge_index, [1, 0])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_37": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[index, index]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "boolean_mask_39": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.range(0, tf.shape(row)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_41": {
                "variable": {
                    "value": "dropped_edge_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(edge_index)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(row, col))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(index, tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([index, index], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.range(0, tf.shape(row)[0]), tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "is_tensor_44": {
                "x": {
                    "value": "edge_attrs[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_45": {
                "variable": {
                    "value": "edge_attrs[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "edge_attrs[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(row, col))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(index, tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([index, index], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.range(0, tf.shape(row)[0]), tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "less_33": {
                "x": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "greater_34": {
                "x": {
                    "value": "tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_40": {
                "x": {
                    "value": "tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_34": {
                "x": {
                    "value": "tf.ones_like(index, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_36": {
                "params": {
                    "value": "dropped_edge_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(edge_index, index, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([dropped_edge_index, tf.gather(dropped_edge_index, [1, 0])], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(edge_index, index, axis=-1)",
                            "Call"
                        ],
                        [
                            "dropped_edge_index.numpy()",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_40": {
                "x": {
                    "value": "tf.ones_like(row, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_34": {
                "input": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(row, col))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(index, tf.greater(tf.nn.dropout(tf.ones_like(index, dtype=tf.float32), rate), 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([index, index], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(tf.range(0, tf.shape(row)[0]), tf.greater(tf.nn.dropout(tf.ones_like(row, dtype=tf.float32), rate), 0))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_39": {
                "input": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_like_40": {
                "input": {
                    "value": "row",
                    "type": "variable",
                    "possible_values": [
                        [
                            "edge_index[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tf_geometric/utils/data_utils.py": {
        "tensorflow": {
            "get_file_16": {
                "fname": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "path",
                            "Method Argument"
                        ],
                        [
                            "path",
                            "Method Argument"
                        ],
                        [
                            "path",
                            "Method Argument"
                        ]
                    ]
                },
                "origin": {
                    "value": "url",
                    "type": "variable",
                    "possible_values": [
                        [
                            "urls",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/utils/tf_sparse_utils.py": {
        "tensorflow": {
            "shape_14": {
                "variable": {
                    "value": "dense_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sparse_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.to_sparse_tensor()",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "sparse_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scatter_nd_16": {
                "variable": {
                    "value": "index_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.expand_dims(sub_index, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.ones_like(sub_index)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[dense_shape[axis]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_17": {
                "variable": {
                    "value": "index_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "index_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(sub_index, axis=-1), tf.ones_like(sub_index), [dense_shape[axis]])",
                            "Call"
                        ],
                        [
                            "tf.cast(index_mask, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_19": {
                "variable": {
                    "value": "gather_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "index_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(tf.expand_dims(sub_index, axis=-1), tf.ones_like(sub_index), [dense_shape[axis]])",
                            "Call"
                        ],
                        [
                            "tf.cast(index_mask, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "gather_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_tensor.indices[:, axis]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "boolean_mask_21": {
                "variable": {
                    "value": "masked_values",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sparse_tensor.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "gather_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(index_mask, gather_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_22": {
                "variable": {
                    "value": "masked_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sparse_tensor.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mask": {
                    "value": "gather_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(index_mask, gather_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_24": {
                "variable": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill([tf.reduce_max(sub_index) + 1], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_25": {
                "variable": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([tf.reduce_max(sub_index) + 1], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(reverse_index, tf.expand_dims(sub_index, axis=-1), tf.range(tf.shape(sub_index)[0]))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.expand_dims(sub_index, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.range(tf.shape(sub_index)[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_29": {
                "variable": {
                    "value": "masked_gather_index",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "reverse_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill([tf.reduce_max(sub_index) + 1], -1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.tensor_scatter_nd_update(reverse_index, tf.expand_dims(sub_index, axis=-1), tf.range(tf.shape(sub_index)[0]))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "masked_gather_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "masked_indices[:, axis]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(reverse_index, masked_gather_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(masked_gather_index, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_30": {
                "variable": {
                    "value": "masked_gather_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "masked_gather_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "masked_indices[:, axis]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(reverse_index, masked_gather_index)",
                            "Call"
                        ],
                        [
                            "tf.cast(masked_gather_index, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_41": {
                "variable": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None]",
                            "List"
                        ],
                        [
                            "tf.cast(new_shape, tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_43": {
                "variable": {
                    "value": "new_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "new_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None]",
                            "List"
                        ],
                        [
                            "tf.stack(new_indices, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "SparseTensor_45": {
                "variable": {
                    "value": "new_sparse_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "new_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None]",
                            "List"
                        ],
                        [
                            "tf.stack(new_indices, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "values": {
                    "value": "masked_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(sparse_tensor.values, gather_mask)",
                            "Call"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None]",
                            "List"
                        ],
                        [
                            "tf.cast(new_shape, tf.int64)",
                            "Call"
                        ]
                    ]
                }
            },
            "reorder_50": {
                "variable": {
                    "value": "new_sparse_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "new_sparse_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.SparseTensor(indices=new_indices, values=masked_values, dense_shape=new_shape)",
                            "Call"
                        ],
                        [
                            "tf.sparse.reorder(new_sparse_tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_16": {
                "input": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_16": {
                "input": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "fill_24": {
                "dims": {
                    "value": "[tf.reduce_max(sub_index) + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_25": {
                "input": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_39": {
                "input": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_26": {
                "input": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_24": {
                "input_tensor": {
                    "value": "sub_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sub_index",
                            "Method Argument"
                        ],
                        [
                            "sub_index",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tf_geometric/utils/tf_utils.py": {
        "tensorflow": {}
    },
    "tf_geometric/utils/union_utils.py": {
        "tensorflow": {
            "is_tensor_10": {
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "is_tensor_24": {
                "x": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "Method Argument"
                        ],
                        [
                            "data",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "tutorial_intro.py": {
        "tensorflow": {
            "reshape_76": {
                "variable": {
                    "value": "node_score",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "node_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gcn_score_layer([batch_graph.x, batch_graph.edge_index, batch_graph.edge_weight])",
                            "Call"
                        ],
                        [
                            "tf.reshape(node_score, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_144": {
                "variable": {
                    "value": "gcn_w",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.truncated_normal([test_data[0].num_features, 20])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Dropout_122": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "rate": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "truncated_normal_144": {
                "shape": {
                    "value": "[test_data[0].num_features, 20]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    }
}