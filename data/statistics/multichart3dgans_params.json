{
    "convert_to_tfrecords.py": {
        "tensorflow": {
            "TFRecordWriter_112": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "tfr_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dst_dir, '{0}_{1}.tfrecord'.format(file_name_prefix, tfr_counter))",
                            "Call"
                        ],
                        [
                            "os.path.join(dst_dir, '{0}_{1}.tfrecord'.format(file_name_prefix, tfr_counter))",
                            "Call"
                        ],
                        [
                            "tfr_path",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Example_118": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'image_string': _bytes_feature(image_string)})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_130": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_134": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_130": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Int64List_134": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Features_119": {
                "feature": {
                    "value": "{'image_string': _bytes_feature(image_string)}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "data_loader/data_loader.py": {
        "tensorflow": {
            "placeholder_19": {
                "variable": {
                    "value": "self.filenames",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TFRecordDataset_20": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "self.filenames",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "decode_raw_26": {
                "variable": {
                    "value": "self.get_next",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_bytes": {
                    "value": "self.iterator.get_next()",
                    "type": "Call",
                    "possible_values": []
                },
                "out_type": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "parse_single_example_32": {
                "variable": {
                    "value": "parsed_features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_proto",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example_proto",
                            "Method Argument"
                        ]
                    ]
                },
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image_string': tf.FixedLenFeature((), tf.string, default_value='')}",
                            "Dict"
                        ]
                    ]
                }
            },
            "FixedLenFeature_31": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "evaluate_main.py": {
        "tensorflow": {
            "ConfigProto_21": {
                "variable": {
                    "value": "gpuconfig",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "log_device_placement": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_26": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "gpuconfig",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True, log_device_placement=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_37": {
                "value": {
                    "value": "noise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sess.run(model.noise)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "gan_main.py": {
        "tensorflow": {
            "ConfigProto_31": {
                "variable": {
                    "value": "gpuconfig",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "log_device_placement": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_39": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "gpuconfig",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True, log_device_placement=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_random_seed_36": {
                "seed": {
                    "value": "config.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "layers/conv_block.py": {
        "tensorflow": {
            "relu_35": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_37": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_58": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_60": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "avg_pool_65": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_24": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_31": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_64": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_68": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), output_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "periodic_padding(output, 0, 1, 0, 1, spatial_dim, data_format='NHWC', method=method)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(output, [spatial_dim * 2 + 1, spatial_dim * 2 + 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "output[:, :spatial_dim * 2, :spatial_dim * 2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_1'.format(name), input_dim, input_dim, filter_size, inputs, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('{0}_2'.format(name), input_dim, output_dim, filter_size, output, spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(output, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "layers/linear.py": {
        "tensorflow": {
            "get_variable_17": {
                "variable": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "weight_values.astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_13": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_20": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W', initializer=weight_values.astype('float32'))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_22": {
                "variable": {
                    "value": "reshaped_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, input_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_23": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "reshaped_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, input_dim])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W', initializer=weight_values.astype('float32'))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_24": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, tf.get_variable('b', initializer=np.zeros(output_dim, dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_27": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, tf.get_variable('b', initializer=np.zeros(output_dim, dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "tf.get_variable('b', initializer=np.zeros(output_dim, dtype='float32'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_24": {
                "values": {
                    "value": "tf.unstack(tf.shape(inputs))[:-1] + [output_dim]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_29": {
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "np.zeros(output_dim, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unstack_24": {
                "value": {
                    "value": "tf.shape(inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_24": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "layers/periodic_conv2d.py": {
        "tensorflow": {
            "get_variable_41": {
                "variable": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Filters",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "filter_values.astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_56": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "periodic_padding(inputs, pad_left, pad_right, pad_top, pad_bottom, spatial_dim, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Filters', initializer=filter_values.astype('float32'))",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, stride, stride]",
                            "List"
                        ],
                        [
                            "[1, stride, stride, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NCHW'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_21": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_65": {
                "variable": {
                    "value": "_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "np.zeros(output_dim, dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_66": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=inputs, filter=filters, strides=strides, padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('b', initializer=np.zeros(output_dim, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NCHW'",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "layers/periodic_padding.py": {
        "tensorflow": {
            "shape_48": {
                "variable": {
                    "value": "in_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_int32_49": {
                "variable": {
                    "value": "in_N",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_50": {
                "variable": {
                    "value": "in_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_51": {
                "variable": {
                    "value": "in_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_52": {
                "variable": {
                    "value": "in_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "slice_56": {
                "variable": {
                    "value": "bottom_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[in_N, in_depth, pad_bottom, in_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_57": {
                "variable": {
                    "value": "top_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, in_height - pad_top, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[in_N, in_depth, pad_top, in_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_59": {
                "variable": {
                    "value": "top_bottom_padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[top_padding, inputs, bottom_padding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "slice_64": {
                "variable": {
                    "value": "right_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "top_bottom_padded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([top_padding, inputs, bottom_padding], 2)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[in_N, in_depth, in_height, pad_right]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_65": {
                "variable": {
                    "value": "left_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "top_bottom_padded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([top_padding, inputs, bottom_padding], 2)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, in_width - pad_left]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[in_N, in_depth, in_height, pad_left]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_67": {
                "variable": {
                    "value": "inputs_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[left_padding, top_bottom_padded_input, right_padding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "div_122": {
                "variable": {
                    "value": "pad_left",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "k_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel.shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "div_123": {
                "variable": {
                    "value": "pad_top",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "k_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mod_133": {
                "variable": {
                    "value": "d_right",
                    "type": "variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "in_width - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "stride_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "strides[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "mod_134": {
                "variable": {
                    "value": "d_bottom",
                    "type": "variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "in_height - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "stride_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "strides[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "subtract_136": {
                "variable": {
                    "value": "pad_right",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "k_width // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "d_right",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.mod(spatial_dim - 1, stride)",
                            "Call"
                        ],
                        [
                            "tf.mod(in_width - 1, stride_width)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_137": {
                "variable": {
                    "value": "pad_bottom",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "k_height // 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "d_bottom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.mod(spatial_dim - 1, stride)",
                            "Call"
                        ],
                        [
                            "tf.mod(in_height - 1, stride_height)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_20": {
                "variable": {
                    "value": "tb_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_22": {
                "variable": {
                    "value": "rl_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "einsum_25": {
                "variable": {
                    "value": "tb_padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "cdij,abjk->abik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tb_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 0), dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 3), dtype='float32')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "einsum_26": {
                "variable": {
                    "value": "padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "cdij,abjk->cdik",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tb_padded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('cdij,abjk->abik', tb_pad, inputs)",
                            "Call"
                        ],
                        [
                            "tf.einsum('cijd,ajkb->aikb', tb_pad, inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "rl_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 0), dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 3), dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_45": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_71": {
                "variable": {
                    "value": "inputs_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([left_padding, top_bottom_padded_input, right_padding], 3)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs_pad, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_28": {
                "variable": {
                    "value": "tb_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_30": {
                "variable": {
                    "value": "rl_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "einsum_33": {
                "variable": {
                    "value": "tb_padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "cijd,ajkb->aikb",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tb_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 0), dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((pad_top, pad_bottom), (0, 0)), 'wrap'), 0), 3), dtype='float32')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "einsum_34": {
                "variable": {
                    "value": "padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "cijd,ajkb->cikd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tb_padded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('cdij,abjk->abik', tb_pad, inputs)",
                            "Call"
                        ],
                        [
                            "tf.einsum('cijd,ajkb->aikb', tb_pad, inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "rl_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 0), dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(np.pad(I, ((0, 0), (pad_left, pad_right)), 'wrap'), 0), 3), dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "layers/projection.py": {
        "tensorflow": {
            "shape_13": {
                "variable": {
                    "value": "in_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_int32_14": {
                "variable": {
                    "value": "in_N",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_15": {
                "variable": {
                    "value": "in_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_16": {
                "variable": {
                    "value": "in_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_17": {
                "variable": {
                    "value": "in_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stack_27": {
                "variable": {
                    "value": "rotations_stacked",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs_pad, inputs_90, inputs_180, inputs_270]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_32": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.slice(result, [0, 0, 0, 0], [in_N, in_height, in_width, in_depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "projected_boundary + inner_part",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[in_N, in_height, in_width, in_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_39": {
                "variable": {
                    "value": "tf_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([1, spatial_dim, spatial_dim, 1], dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_40": {
                "variable": {
                    "value": "tf_n_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "n_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "abs(mask - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_42": {
                "variable": {
                    "value": "boundary",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.slice(result, [0, 0, 0, 0], [in_N, in_height, in_width, in_depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "projected_boundary + inner_part",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_43": {
                "variable": {
                    "value": "inner_part",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.slice(result, [0, 0, 0, 0], [in_N, in_height, in_width, in_depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "projected_boundary + inner_part",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf_n_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(n_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_59": {
                "variable": {
                    "value": "inputs_rot90",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda Input: tf.image.rot90(Input)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_72": {
                "variable": {
                    "value": "in_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_int32_73": {
                "variable": {
                    "value": "in_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_74": {
                "variable": {
                    "value": "in_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_75": {
                "variable": {
                    "value": "in_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_76": {
                "variable": {
                    "value": "in_N",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_nd_80": {
                "variable": {
                    "value": "orig_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "[[center, center], [0, 0], [0, center]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_90": {
                "variable": {
                    "value": "updates_p",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.divide(tf.subtract(T_cones, cones_mean), epsilon + tf.sqrt(cones_variance)), [3, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "orig_cones",
                            "variable"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "model.gather_indices_p",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_91": {
                "variable": {
                    "value": "updates_m",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.divide(tf.subtract(T_cones, cones_mean), epsilon + tf.sqrt(cones_variance)), [3, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "orig_cones",
                            "variable"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "model.gather_indices_m",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_116": {
                "variable": {
                    "value": "triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "triplets_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(model.triplets_mat_reg, tf.concat([tf.ones([num_of_equations - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * tf.ones([num_of_params // 4, 1])], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.concat([fix_chart_equations, triplets_mat[4:, :]], axis=0)",
                            "Call"
                        ],
                        [
                            "model.triplets_mat",
                            "Attribute"
                        ],
                        [
                            "tf.expand_dims(triplets_mat, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_117": {
                "variable": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "triplets_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(model.triplets_mat_reg, tf.concat([tf.ones([num_of_equations - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * tf.ones([num_of_params // 4, 1])], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.concat([fix_chart_equations, triplets_mat[4:, :]], axis=0)",
                            "Call"
                        ],
                        [
                            "model.triplets_mat",
                            "Attribute"
                        ],
                        [
                            "tf.expand_dims(triplets_mat, 2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.scatter_nd(model.scatter_indices_p, updates_p, [num_of_equations, num_of_params, in_N])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_118": {
                "variable": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(triplets_mat, tf.scatter_nd(model.scatter_indices_p, updates_p, [num_of_equations, num_of_params, in_N]))",
                            "Call"
                        ],
                        [
                            "tf.subtract(batched_triplets_mat, tf.scatter_nd(model.scatter_indices_m, updates_m, tf.shape(batched_triplets_mat)))",
                            "Call"
                        ],
                        [
                            "tf.transpose(batched_triplets_mat, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.scatter_nd(model.scatter_indices_m, updates_m, tf.shape(batched_triplets_mat))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_119": {
                "variable": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(triplets_mat, tf.scatter_nd(model.scatter_indices_p, updates_p, [num_of_equations, num_of_params, in_N]))",
                            "Call"
                        ],
                        [
                            "tf.subtract(batched_triplets_mat, tf.scatter_nd(model.scatter_indices_m, updates_m, tf.shape(batched_triplets_mat)))",
                            "Call"
                        ],
                        [
                            "tf.transpose(batched_triplets_mat, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_123": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.transpose(x, [2, 1, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, num_of_params // 4, 4, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_152": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(S_temp, [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(S, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1]), [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(S, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_153": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(T, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(T, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_155": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(T_inputs, S)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(T, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(T, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_173": {
                "variable": {
                    "value": "in_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_174": {
                "variable": {
                    "value": "in_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_175": {
                "variable": {
                    "value": "in_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_176": {
                "variable": {
                    "value": "in_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_177": {
                "variable": {
                    "value": "in_N",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "in_shape[3]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_179": {
                "variable": {
                    "value": "num_of_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.shape(model.triplets_mat)[1] // 4",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_182": {
                "variable": {
                    "value": "ST_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(cones, S)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(T, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(T, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_184": {
                "variable": {
                    "value": "ST_cones_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ST_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(cones, S), T)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 3, num_of_charts, 3, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_186": {
                "variable": {
                    "value": "triplets_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(np.expand_dims(model.triplets_masks, 3), 4)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_188": {
                "variable": {
                    "value": "friends_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ST_cones_reshaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(ST_cones, [1, 3, num_of_charts, 3, -1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "triplets_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(model.triplets_masks, 3), 4), dtype='float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_189": {
                "variable": {
                    "value": "mean_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(friends_mat, [1, 2], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(triplets_masks, [1, 2], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_192": {
                "variable": {
                    "value": "projected_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reduce_sum(tf.multiply(triplets_masks, mean_masks), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(ST_cones)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_195": {
                "x": {
                    "value": "projected_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.reduce_sum(tf.multiply(triplets_masks, mean_masks), 0), tf.shape(ST_cones))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(T, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(T, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_196": {
                "variable": {
                    "value": "reduced_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[reduced_cones, tf.slice(reduced_cones, [2, 0, 0], [1, in_depth, in_N])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_197": {
                "variable": {
                    "value": "new_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[center, center], [0, 0], [0, center], [center, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "reduced_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(tf.divide(tf.subtract(projected_cones, T), S), cones)",
                            "Call"
                        ],
                        [
                            "tf.concat([reduced_cones, tf.slice(reduced_cones, [2, 0, 0], [1, in_depth, in_N])], 0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(T_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_199": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd([[center, center], [0, 0], [0, center], [center, 0]], reduced_cones, tf.shape(T_inputs))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_10": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_29": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rotations_stacked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([inputs_pad, inputs_90, inputs_180, inputs_270])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_45": {
                "variable": {
                    "value": "projected_boundary",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([boundary, tf.transpose(boundary, [0, 2, 1, 3])])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_53": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.slice(result, [0, 0, 0, 0], [in_N, in_height, in_width, in_depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(rotations_stacked, axis=0)",
                            "Call"
                        ],
                        [
                            "projected_boundary + inner_part",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_83": {
                "variable": {
                    "value": "T_cones",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "orig_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(inputs, [[center, center], [0, 0], [0, center]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[3, in_depth // 3, 3, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_84": {
                "variable": {
                    "value": "(cones_mean, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "T_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(orig_cones, [3, in_depth // 3, 3, in_N])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "moments_85": {
                "variable": {
                    "value": "(_, cones_variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "T_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(orig_cones, [3, in_depth // 3, 3, in_N])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "cones",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.divide(tf.subtract(T_cones, cones_mean), epsilon + tf.sqrt(cones_variance))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[3, in_depth, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_95": {
                "variable": {
                    "value": "num_of_equations",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "np.shape(model.triplets_mat_reg)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_96": {
                "variable": {
                    "value": "num_of_params",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "np.shape(model.triplets_mat_reg)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "multiply_97": {
                "variable": {
                    "value": "triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "model.triplets_mat_reg",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.concat([tf.ones([num_of_equations - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * tf.ones([num_of_params // 4, 1])], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scatter_nd_100": {
                "variable": {
                    "value": "fix_chart_equations",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[0, fixed_chart * 4], [1, fixed_chart * 4 + 1], [2, fixed_chart * 4 + 2], [3, fixed_chart * 4 + 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.ones(4, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4, num_of_params]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_103": {
                "variable": {
                    "value": "triplets_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fix_chart_equations, triplets_mat[4:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_104": {
                "variable": {
                    "value": "STD",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "model.STD",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, num_of_params // 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_105": {
                "variable": {
                    "value": "STD",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "STD",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(model.STD, [1, num_of_params // 4, 1])",
                            "Call"
                        ],
                        [
                            "tf.divide(STD, tf.gather_nd(STD, [[[0, fixed_chart, 0]]]))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.gather_nd(STD, [[[0, fixed_chart, 0]]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_106": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([tf.ones([1, 1, 1]), tf.zeros([1, num_of_equations - 1 - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * STD], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[in_N, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_111": {
                "variable": {
                    "value": "num_of_equations",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "np.shape(model.triplets_mat)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_int32_112": {
                "variable": {
                    "value": "num_of_params",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "np.shape(model.triplets_mat)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tile_114": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([tf.ones([1, 1, 1]), tf.zeros([1, num_of_equations - 1, 1])], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[in_N, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_127": {
                "variable": {
                    "value": "S_temp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.divide(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), epsilon + tf.sqrt(cones_variance))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_130": {
                "variable": {
                    "value": "S_fixed",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "S_temp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.divide(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), epsilon + tf.sqrt(cones_variance)), [1, 1, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "[[[0, fixed_chart, 0]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_131": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "S_temp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.divide(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), epsilon + tf.sqrt(cones_variance)), [1, 1, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, in_depth, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_132": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(S_temp, [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(S, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1]), [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(S, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "S_fixed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(S_temp, [[[0, fixed_chart, 0]]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 3 * num_of_params // 4, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_135": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]) - tf.multiply(S_temp, cones_mean), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(T, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N]), [1, 3 * num_of_params // 4, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(T, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "S_fixed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(S_temp, [[[0, fixed_chart, 0]]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_137": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, in_depth, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_138": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.slice(x, [0, 0, 1, 0], [1, num_of_params // 4, 3, in_N])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 3 * num_of_params // 4, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_146": {
                "variable": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 3, 1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_158": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(T_inputs, S), T)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.add(T_inputs, new_cones)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_168": {
                "variable": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 3, 1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_202": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(T_inputs, S), T)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.add(T_inputs, new_cones)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_31": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rotations_stacked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([inputs_pad, inputs_90, inputs_180, inputs_270])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_47": {
                "variable": {
                    "value": "projected_boundary",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([boundary, tf.transpose(boundary, [0, 2, 1, 3])])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_117": {
                "indices": {
                    "value": "model.scatter_indices_p",
                    "type": "Attribute",
                    "possible_values": []
                },
                "updates": {
                    "value": "updates_p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(cones, model.gather_indices_p)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[num_of_equations, num_of_params, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scatter_nd_118": {
                "indices": {
                    "value": "model.scatter_indices_m",
                    "type": "Attribute",
                    "possible_values": []
                },
                "updates": {
                    "value": "updates_m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(cones, model.gather_indices_m)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(batched_triplets_mat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_123": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matrix_solve_ls(batched_triplets_mat, b, l2_regularizer=model.config.ls_reg)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(x, [2, 1, 0]), [1, num_of_params // 4, 4, in_N])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_148": {
                "variable": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_155": {
                "x": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(S_temp, [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(S, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1]), [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(S, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_160": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(T_inputs, S), T)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.add(T_inputs, new_cones)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_170": {
                "variable": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_182": {
                "x": {
                    "value": "cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.divide(tf.subtract(T_cones, cones_mean), epsilon + tf.sqrt(cones_variance)), [3, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "orig_cones",
                            "variable"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(S_temp, [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(S, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1]), [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(S, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_189": {
                "input_tensor": {
                    "value": "friends_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(ST_cones_reshaped, triplets_masks)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_190": {
                "input_tensor": {
                    "value": "triplets_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(model.triplets_masks, 3), 4), dtype='float32')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_192": {
                "input_tensor": {
                    "value": "tf.multiply(triplets_masks, mean_masks)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_192": {
                "input": {
                    "value": "ST_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(cones, S), T)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_195": {
                "x": {
                    "value": "tf.subtract(projected_cones, T)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(S_temp, [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "tf.divide(S, S_fixed)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), [1, 1, 3, 1]), [1, in_depth, in_N])",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(S, 0)",
                            "Call"
                        ],
                        [
                            "solve_ST(model, T_inputs, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_197": {
                "input": {
                    "value": "T_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [2, 3, 1, 0])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 2, 3, 0])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_204": {
                "variable": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "results",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(T_inputs, S), T)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.add(T_inputs, new_cones)",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(results, [3, 0, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_45": {
                "values": {
                    "value": "[boundary, tf.transpose(boundary, [0, 2, 1, 3])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "rot90_59": {
                "image": {
                    "value": "Input",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "divide_86": {
                "x": {
                    "value": "tf.subtract(T_cones, cones_mean)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon + tf.sqrt(cones_variance)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_97": {
                "values": {
                    "value": "[tf.ones([num_of_equations - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * tf.ones([num_of_params // 4, 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_102": {
                "shape": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_105": {
                "params": {
                    "value": "STD",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(model.STD, [1, num_of_params // 4, 1])",
                            "Call"
                        ],
                        [
                            "tf.divide(STD, tf.gather_nd(STD, [[[0, fixed_chart, 0]]]))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "[[[0, fixed_chart, 0]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_106": {
                "values": {
                    "value": "[tf.ones([1, 1, 1]), tf.zeros([1, num_of_equations - 1 - num_of_params // 4, 1]), tf.sqrt(model.config.gamma) * STD]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_114": {
                "values": {
                    "value": "[tf.ones([1, 1, 1]), tf.zeros([1, num_of_equations - 1, 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_118": {
                "input": {
                    "value": "batched_triplets_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(triplets_mat, tf.scatter_nd(model.scatter_indices_p, updates_p, [num_of_equations, num_of_params, in_N]))",
                            "Call"
                        ],
                        [
                            "tf.subtract(batched_triplets_mat, tf.scatter_nd(model.scatter_indices_m, updates_m, tf.shape(batched_triplets_mat)))",
                            "Call"
                        ],
                        [
                            "tf.transpose(batched_triplets_mat, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_128": {
                "x": {
                    "value": "tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon + tf.sqrt(cones_variance)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_137": {
                "input": {
                    "value": "tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_138": {
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matrix_solve_ls(batched_triplets_mat, b, l2_regularizer=model.config.ls_reg)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(x, [2, 1, 0]), [1, num_of_params // 4, 4, in_N])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, num_of_params // 4, 3, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_192": {
                "x": {
                    "value": "triplets_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.expand_dims(np.expand_dims(model.triplets_masks, 3), 4), dtype='float32')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mean_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(tf.reduce_sum(friends_mat, [1, 2], keepdims=True), tf.reduce_sum(triplets_masks, [1, 2], keepdims=True))",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_196": {
                "input_": {
                    "value": "reduced_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(tf.divide(tf.subtract(projected_cones, T), S), cones)",
                            "Call"
                        ],
                        [
                            "tf.concat([reduced_cones, tf.slice(reduced_cones, [2, 0, 0], [1, in_depth, in_N])], 0)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[2, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, in_depth, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_47": {
                "values": {
                    "value": "[boundary, tf.transpose(boundary, [0, 2, 1, 3])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_86": {
                "x": {
                    "value": "T_cones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(orig_cones, [3, in_depth // 3, 3, in_N])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "cones_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(T_cones, axes=0, keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_128": {
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matrix_solve_ls(batched_triplets_mat, b, l2_regularizer=model.config.ls_reg)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(x, [2, 1, 0]), [1, num_of_params // 4, 4, in_N])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, num_of_params // 4, 1, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_133": {
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matrix_solve_ls(batched_triplets_mat, b, l2_regularizer=model.config.ls_reg)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(x, [2, 1, 0]), [1, num_of_params // 4, 4, in_N])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, num_of_params // 4, 3, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_133": {
                "x": {
                    "value": "S_temp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.divide(tf.slice(x, [0, 0, 0, 0], [1, num_of_params // 4, 1, in_N]), epsilon + tf.sqrt(cones_variance)), [1, 1, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "cones_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(T_cones, axes=0, keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_137": {
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matrix_solve_ls(batched_triplets_mat, b, l2_regularizer=model.config.ls_reg)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(x, [2, 1, 0]), [1, num_of_params // 4, 4, in_N])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1, num_of_params // 4, 1, in_N]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_45": {
                "a": {
                    "value": "boundary",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(result, tf_mask)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_86": {
                "x": {
                    "value": "cones_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(T_cones, axes=[0, 2], keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_98": {
                "shape": {
                    "value": "[num_of_params // 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_107": {
                "shape": {
                    "value": "[1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_107": {
                "shape": {
                    "value": "[1, num_of_equations - 1 - num_of_params // 4, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_114": {
                "shape": {
                    "value": "[1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_114": {
                "shape": {
                    "value": "[1, num_of_equations - 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_128": {
                "x": {
                    "value": "cones_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(T_cones, axes=[0, 2], keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_47": {
                "a": {
                    "value": "boundary",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(result, tf_mask)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_98": {
                "x": {
                    "value": "model.config.gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_107": {
                "x": {
                    "value": "model.config.gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "models/base_model.py": {
        "tensorflow": {
            "latest_checkpoint_27": {
                "variable": {
                    "value": "latest_checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.config.init_path",
                            "Attribute"
                        ],
                        [
                            "self.config.checkpoint_dir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_37": {
                "variable": {
                    "value": "self.cur_epoch_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "cur_epoch",
                    "type": "str",
                    "possible_values": []
                }
            },
            "assign_38": {
                "variable": {
                    "value": "self.increment_cur_epoch_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.cur_epoch_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.cur_epoch_tensor + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_44": {
                "variable": {
                    "value": "self.global_step_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "cur_epoch",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_43": {
                "name_or_scope": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "models/gan_model.py": {
        "tensorflow": {
            "reshape_135": {
                "variable": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.gradients(disc_interpolates, [interpolates])[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(interpolates)[0], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_136": {
                "variable": {
                    "value": "slopes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(gradients), reduction_indices=[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_137": {
                "variable": {
                    "value": "gradient_penalty",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(slopes - 1.0) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_307": {
                "variable": {
                    "value": "self.triplets_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "mat_content['triplets_mat'].toarray()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_310": {
                "variable": {
                    "value": "self.triplets_mat_reg",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "mat_content['triplets_mat'].toarray()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_332": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "self.config.max_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_25": {
                "variable": {
                    "value": "self.gen_opt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.config.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta1": {
                    "value": "self.config.beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta2": {
                    "value": "self.config.beta2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "gen_opt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AdamOptimizer_26": {
                "variable": {
                    "value": "self.disc_opt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.config.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta1": {
                    "value": "self.config.beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta2": {
                    "value": "self.config.beta2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "disc_opt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_29": {
                "variable": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.dataLoader.get_next",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_34": {
                "variable": {
                    "value": "batches",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.real_charts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.config.n_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_36": {
                "variable": {
                    "value": "noises",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.noise",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.config.n_gpus",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_87": {
                "variable": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_88": {
                "variable": {
                    "value": "N_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.arange(self.config.batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_90": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[N_indices, C_indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_91": {
                "variable": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([N_indices, C_indices], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_99": {
                "variable": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_100": {
                "variable": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.config.batch_size, self.config.depth_dim // 3, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_101": {
                "variable": {
                    "value": "(_, data_variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_102": {
                "variable": {
                    "value": "processed_real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.divide(real_charts, tf.sqrt(data_variance))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_106": {
                "variable": {
                    "value": "processed_real_charts",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_mean(real_charts, axis=[1, 2, 3], keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_167": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_168": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=0, values=grads)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(grad, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_230": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_231": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, depths[0], spatial[0], spatial[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_236": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_285": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_293": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_294": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, depths[ind + 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "leaky_relu_298": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_299": {
                "variable": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "layers.linear.Linear('output_FC', depths[ind + 1], 1, output)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_22": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_123": {
                "input_tensor": {
                    "value": "disc_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.discriminator(fake_charts)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_124": {
                "input_tensor": {
                    "value": "disc_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.discriminator(real_charts)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_136": {
                "input_tensor": {
                    "value": "tf.square(gradients)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "variable": {
                    "value": "expanded_g",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad_and_vars",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_187": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_188": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, depths[0], spatial[0], spatial[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_193": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_213": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.greater(self.cur_epoch_tensor, self.config.kick_projection)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "project_ST_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "project_ST_op",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : output",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_226": {
                "name_or_scope": {
                    "value": "generator",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "moments_247": {
                "variable": {
                    "value": "(data_mean, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "subtract_248": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "data_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(output, axes=[2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(output, axes=[2, 3], keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_262": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_270": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_271": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, depths[ind + 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "leaky_relu_273": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_274": {
                "variable": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "layers.linear.Linear('output_FC', depths[ind + 1], 1, output)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_280": {
                "name_or_scope": {
                    "value": "discriminator",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_69": {
                "inputs": {
                    "value": "self.disc_cost",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_70": {
                "inputs": {
                    "value": "self.gen_cost",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_99": {
                "input_tensor": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "divide_102": {
                "x": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.sqrt(data_variance)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_106": {
                "input_tensor": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "gradients_135": {
                "ys": {
                    "value": "disc_interpolates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.discriminator(interpolates)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "[interpolates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_136": {
                "x": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.gradients(disc_interpolates, [interpolates])[0], [tf.shape(interpolates)[0], -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_183": {
                "name_or_scope": {
                    "value": "generator",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "moments_219": {
                "variable": {
                    "value": "(data_mean, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "subtract_220": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater(self.cur_epoch_tensor, self.config.kick_projection), project_ST_op, lambda : output)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "layers.linear.Linear('input_FC', self.config.latent_vec_dim, spatial[0] ** 2 * depths[0], noise)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, depths[0], spatial[0], spatial[0]])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in_{0}-{1}_{2}'.format(depths[0], depths[0], spatial[0]), depths[0], depths[0], 3, output, spatial[0])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.GenConvBlock('conv__{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_out', depths[ind + 1], self.config.depth_dim, 1, output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "toric_symmetry(output, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.subtract(output, data_mean)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_in', self.config.depth_dim, depths[0], 1, inputs, self.config.spatial_dim)",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "layers.conv_block.DiscConvBlock('conv_{3}_{0}-{1}_{2}'.format(depth, depths[ind + 1], spatial[ind], ind), depth, depths[ind + 1], 3, output, spatial[ind])",
                            "Call"
                        ],
                        [
                            "Conv2D('conv_{0}-{1}_{2}_1'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 3, output, spatial[ind + 1])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(Conv2D('conv_{0}-{1}_{2}_2'.format(depths[ind + 1], depths[ind + 1], spatial[ind + 1]), depths[ind + 1], depths[ind + 1], 4, output, spatial[ind + 1], periodic=False), [-1, depths[ind + 1]])",
                            "Call"
                        ],
                        [
                            "tf.nn.leaky_relu(output)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "data_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(output, axes=[2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(output, axes=[2, 3], keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_257": {
                "name_or_scope": {
                    "value": "discriminator",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_49": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_102": {
                "x": {
                    "value": "data_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(real_charts, axes=[2], keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_135": {
                "input": {
                    "value": "interpolates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "real_charts + alpha * differences",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_205": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.pow(self.config.gamma_decay, tf.cast(tf.subtract(self.cur_epoch_tensor, self.config.kick_projection), dtype='float32'))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.config.gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_213": {
                "x": {
                    "value": "self.cur_epoch_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.config.kick_projection",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_35": {
                "input": {
                    "value": "self.real_charts",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_50": {
                "name": {
                    "value": "'tower.{0}'.format(device_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_57": {
                "variable": {
                    "value": "t_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_128": {
                "input": {
                    "value": "real_charts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.dataLoader.get_next, [self.config.batch_size, self.config.depth_dim, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, 3, self.config.spatial_dim, self.config.spatial_dim])",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(real_charts, indices)",
                            "Call"
                        ],
                        [
                            "align_ST(self, real_charts)",
                            "Call"
                        ],
                        [
                            "tf.subtract(real_charts, tf.reduce_mean(real_charts, axis=[2, 3], keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.reshape(real_charts, [self.config.batch_size, self.config.depth_dim // 3, -1])",
                            "Call"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ],
                        [
                            "real_charts",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "control_dependencies_209": {
                "control_inputs": {
                    "value": "[op1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_210": {
                "input": {
                    "value": "op1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "project_ST(self, output, gamma)",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_205": {
                "x": {
                    "value": "self.config.gamma_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(tf.subtract(self.cur_epoch_tensor, self.config.kick_projection), dtype='float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_205": {
                "x": {
                    "value": "tf.subtract(self.cur_epoch_tensor, self.config.kick_projection)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "subtract_205": {
                "x": {
                    "value": "self.cur_epoch_tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.config.kick_projection",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "trainers/base_trainer.py": {
        "tensorflow": {
            "group_11": {
                "variable": {
                    "value": "self.init",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tf.global_variables_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.local_variables_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_initializer_11": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_11": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "trainers/gan_trainer.py": {
        "tensorflow": {
            "convert_to_tensor_30": {
                "value": {
                    "value": "noise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sess.run(self.model.noise)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "utils/logger.py": {
        "tensorflow": {
            "FileWriter_11": {
                "variable": {
                    "value": "self.train_summary_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(self.config.summary_dir, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_13": {
                "variable": {
                    "value": "self.test_summary_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(self.config.summary_dir, 'test')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_25": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_32": {
                "variable": {
                    "value": "self.summary_placeholders[tag]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "value.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "tag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "summaries_dict.items()",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_34": {
                "variable": {
                    "value": "self.summary_placeholders[tag]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(value.shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "tag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "summaries_dict.items()",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_36": {
                "variable": {
                    "value": "self.summary_ops[tag]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "tag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "summaries_dict.items()",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "self.summary_placeholders[tag]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "image_38": {
                "variable": {
                    "value": "self.summary_ops[tag]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "tag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "summaries_dict.items()",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "self.summary_placeholders[tag]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    }
}