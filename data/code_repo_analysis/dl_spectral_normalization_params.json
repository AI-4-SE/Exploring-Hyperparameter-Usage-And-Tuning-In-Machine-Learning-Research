{
    "dl_spectral_normalization/dl_utils.py": {
        "sklearn": {
            "shuffle_183": {
                "variable": {
                    "value": "(Xtr_, Ytr_)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "Xtr",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "Ytr",
                    "type": "variable",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "sparse_softmax_cross_entropy_with_logits_15": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(np.shape(X))",
                            "Call"
                        ],
                        [
                            "g",
                            "Method Argument"
                        ],
                        [
                            "g",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "equal_29": {
                "variable": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "Y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ],
                        [
                            "Y",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.argmax(g, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_52": {
                "variable": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 28, 28, num_channels]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "in_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_53": {
                "variable": {
                    "value": "input_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "in_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_59": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "gradients_482": {
                "variable": {
                    "value": "(grad,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "graph['total_loss']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "xs": {
                    "value": "graph['input_data']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_664": {
                "variable": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "u",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, W.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_667": {
                "variable": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfvar.eval(session=sess)",
                            "Call"
                        ],
                        [
                            "W",
                            "Method Argument"
                        ],
                        [
                            "W",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_669": {
                "a": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration_conv(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_698": {
                "variable": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "u",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "u_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, length, width, W.shape[-2]]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_701": {
                "variable": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfvar.eval(session=sess)",
                            "Call"
                        ],
                        [
                            "W",
                            "Method Argument"
                        ],
                        [
                            "W",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_703": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration_conv(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_704": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.multiply(z, v_hat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GraphDef_751": {
                "variable": {
                    "value": "strip_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_18": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=Y, logits=g)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(out)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_30": {
                "input_tensor": {
                    "value": "tf.cast(correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_101": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "max_save",
                    "type": "variable",
                    "possible_values": [
                        [
                            "200",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "set_random_seed_144": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reset_default_graph_253": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_341": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_356": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_362": {
                "variable": {
                    "value": "load_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "os.path.join(save_dir, 'checkpoints')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reset_default_graph_441": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_478": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_502": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_527": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "summary_iterator_541": {
                "path": {
                    "value": "tb_log_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(load_dir, 'train', event_file)",
                            "Call"
                        ],
                        [
                            "os.path.join(load_dir, 'validation', event_file)",
                            "Call"
                        ],
                        [
                            "tb_log_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reset_default_graph_623": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_660": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_693": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "argmax_29": {
                "input": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(np.shape(X))",
                            "Call"
                        ],
                        [
                            "g",
                            "Method Argument"
                        ],
                        [
                            "g",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_30": {
                "x": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(Y, tf.argmax(g, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_81": {
                "control_inputs": {
                    "value": "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_83": {
                "variable": {
                    "value": "opt_step",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_85": {
                "variable": {
                    "value": "opt_step",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(0.01, name='learning_rate', trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "merge_all_114": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_115": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(save_dir, 'train')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_116": {
                "variable": {
                    "value": "graph_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(save_dir, 'graph')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "tf.get_default_graph()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_117": {
                "variable": {
                    "value": "valid_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(save_dir, 'validation')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_154": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_256": {
                "device_name": {
                    "value": "'/gpu:%s' % gpu_id",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_323": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_342": {
                "device_name": {
                    "value": "'/gpu:%s' % gpu_id",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_360": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_456": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_486": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_511": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_516": {
                "key": {
                    "value": "w_after_sn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_626": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_630": {
                "key": {
                    "value": "w_after_sn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_random_seed_662": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_669": {
                "a": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration_conv(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_671": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_random_seed_695": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_704": {
                "x": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(u_hat, w_mat, strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration_conv(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_706": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_719": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collection_21": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=Y, logits=g)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(out)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_22": {
                "inputs": {
                    "value": "tf.get_collection('losses')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_81": {
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_105": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss(fc_out_adv, input_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_106": {
                "name": {
                    "value": "accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "total_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "acc(fc_out_adv, input_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_157": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_665": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_672": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_699": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_707": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_22": {
                "key": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_110": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_154": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_323": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_360": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_456": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_486": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_511": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConfigProto_626": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_629": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_644": {
                "input_tensor": {
                    "value": "input_x ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_656": {
                "a": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.matmul(v_, w_mat))",
                            "Call"
                        ],
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d_transpose(v_, w_mat, u_dims, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(w_mat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_657": {
                "a": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "l2_norm(tf.matmul(u_, tf.transpose(w_mat)))",
                            "Call"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d(u_, w_mat, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_688": {
                "input": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.matmul(v_, w_mat))",
                            "Call"
                        ],
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d_transpose(v_, w_mat, u_dims, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_689": {
                "input": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "l2_norm(tf.matmul(u_, tf.transpose(w_mat)))",
                            "Call"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d(u_, w_mat, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "u_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, length, width, W.shape[-2]]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ConfigProto_719": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_111": {
                "name": {
                    "value": "var.op.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "get_default_graph_116": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_452": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_453": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_454": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_656": {
                "a": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "tf.Variable(W)",
                            "Call"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_155": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_324": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_361": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_457": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_487": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_627": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_720": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs.get('gpu_prop', 'default value')",
                            "Call"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "dl_spectral_normalization/adversarial.py": {
        "tensorflow": {
            "maximum_33": {
                "variable": {
                    "value": "adj_norms",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(norms)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "norms / eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_63": {
                "variable": {
                    "value": "loss_",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(preds, 1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(preds, 1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(preds, 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gradients_66": {
                "variable": {
                    "value": "(grad,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=preds)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(preds, y, mean=False)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(model(x_adv, reuse=True, beta=graph_beta, update_collection=update_collection, num_classes=num_classes), y, mean=False)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(model(x_adv, reuse=reuse, beta=graph_beta, update_collection=update_collection, num_classes=num_classes), y, mean=False)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_86": {
                "variable": {
                    "value": "adv_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x + scaled_signed_grad",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gradients_125": {
                "variable": {
                    "value": "(grad,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "eps * loss_",
                    "type": "BinOp",
                    "possible_values": []
                },
                "xs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_126": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x + grad",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stop_gradient_127": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_60": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sign_70": {
                "variable": {
                    "value": "signed_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss_, x)",
                            "Call"
                        ],
                        [
                            "tf.gradients(eps * loss_, x)",
                            "Call"
                        ],
                        [
                            "tf.gradients(eps * loss_, x_adv)",
                            "Call"
                        ],
                        [
                            "grad - grad2",
                            "BinOp"
                        ],
                        [
                            "tf.gradients(loss_, x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_90": {
                "variable": {
                    "value": "adv_x",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "adv_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x + scaled_signed_grad)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(adv_x, clip_min, clip_max)",
                            "Call"
                        ],
                        [
                            "np.zeros(np.shape(X))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "clip_min",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_120": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gradients_133": {
                "variable": {
                    "value": "(grad,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "eps * loss_",
                    "type": "BinOp",
                    "possible_values": []
                },
                "xs": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x + grad)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(x_adv + 1.0 / np.sqrt(t + 2) * grad)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(x_adv + a * scaled_grad)",
                            "Call"
                        ],
                        [
                            "project_back_onto_unit_ball(x_adv, x, eps=eps, order=order)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(x_adv, x - eps, x + eps)",
                            "Call"
                        ],
                        [
                            "x_adv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gradients_134": {
                "variable": {
                    "value": "(grad2,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "tf.nn.l2_loss(x_adv - x)",
                    "type": "Call",
                    "possible_values": []
                },
                "xs": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x + grad)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(x_adv + 1.0 / np.sqrt(t + 2) * grad)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(x_adv + a * scaled_grad)",
                            "Call"
                        ],
                        [
                            "project_back_onto_unit_ball(x_adv, x, eps=eps, order=order)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(x_adv, x - eps, x + eps)",
                            "Call"
                        ],
                        [
                            "x_adv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_136": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv + 1.0 / np.sqrt(t + 2) * grad",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_166": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ],
                        [
                            "preds",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gradients_174": {
                "variable": {
                    "value": "(grad,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=preds)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(preds, y, mean=False)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(model(x_adv, reuse=True, beta=graph_beta, update_collection=update_collection, num_classes=num_classes), y, mean=False)",
                            "Call"
                        ],
                        [
                            "dl_utils.loss(model(x_adv, reuse=reuse, beta=graph_beta, update_collection=update_collection, num_classes=num_classes), y, mean=False)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x + grad)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(x_adv + 1.0 / np.sqrt(t + 2) * grad)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(x_adv + a * scaled_grad)",
                            "Call"
                        ],
                        [
                            "project_back_onto_unit_ball(x_adv, x, eps=eps, order=order)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(x_adv, x - eps, x + eps)",
                            "Call"
                        ],
                        [
                            "x_adv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_185": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_adv + a * scaled_grad",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reset_default_graph_217": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_237": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_10": {
                "input_tensor": {
                    "value": "tf.abs(input_x)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "reduc_ind",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(xrange(1, len(input_x.get_shape())))",
                            "Call"
                        ],
                        [
                            "list(xrange(1, len(input_x.get_shape())))",
                            "Call"
                        ],
                        [
                            "tuple(xrange(1, len(X.shape)))",
                            "Call"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_18": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(input_x), reduction_indices=reduc_ind, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_33": {
                "input": {
                    "value": "norms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "l1_norm_tf(delta)",
                            "Call"
                        ],
                        [
                            "l2_norm_tf(delta)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_218": {
                "device_name": {
                    "value": "'/gpu:%s' % gpu_id",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_238": {
                "device_name": {
                    "value": "'/gpu:%s' % gpu_id",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_10": {
                "x": {
                    "value": "input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_18": {
                "input_tensor": {
                    "value": "tf.square(input_x)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "reduc_ind",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(xrange(1, len(input_x.get_shape())))",
                            "Call"
                        ],
                        [
                            "list(xrange(1, len(input_x.get_shape())))",
                            "Call"
                        ],
                        [
                            "tuple(xrange(1, len(X.shape)))",
                            "Call"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "l2_loss_134": {
                "t": {
                    "value": "x_adv - x",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_191": {
                "variable": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "x_adv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(x + grad)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(x_adv + 1.0 / np.sqrt(t + 2) * grad)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(x_adv + a * scaled_grad)",
                            "Call"
                        ],
                        [
                            "project_back_onto_unit_ball(x_adv, x, eps=eps, order=order)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(x_adv, x - eps, x + eps)",
                            "Call"
                        ],
                        [
                            "x_adv",
                            "Method Argument"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "x - eps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "x + eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_222": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_242": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_18": {
                "x": {
                    "value": "input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sign_183": {
                "variable": {
                    "value": "scaled_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss_, x)",
                            "Call"
                        ],
                        [
                            "tf.gradients(eps * loss_, x)",
                            "Call"
                        ],
                        [
                            "tf.gradients(eps * loss_, x_adv)",
                            "Call"
                        ],
                        [
                            "grad - grad2",
                            "BinOp"
                        ],
                        [
                            "tf.gradients(loss_, x_adv)",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_253": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_222": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_242": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GPUOptions_223": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GPUOptions_243": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2",
                            "Method Argument"
                        ],
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "dl_spectral_normalization/models/alexnet.py": {
        "tensorflow": {
            "relu_16": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_17": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_22": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_23": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_27": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_29": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_32": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_48": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_49": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_55": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_56": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_60": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_62": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_65": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_82": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_83": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_86": {
                "variable": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm1, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.8",
                            "float"
                        ]
                    ]
                }
            },
            "relu_89": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_90": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_93": {
                "variable": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.8",
                            "float"
                        ]
                    ]
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_97": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_100": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_116": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_117": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_123": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_124": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_128": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_131": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_135": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_151": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_152": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_156": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_157": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_160": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_162": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_165": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_181": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_182": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_188": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_189": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_193": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_196": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_200": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_218": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_219": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_225": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_226": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_230": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_233": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_237": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_253": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_254": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_259": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_260": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_264": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "elu_266": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_269": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_285": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_286": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_292": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_293": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_297": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "elu_300": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "elu_304": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_elu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_322": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_323": {
                "variable": {
                    "value": "pool1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv1_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv1_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_329": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, bn=True, training=training)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(pool1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', tighter_sn=False, update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(input_data, [5, 5, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.conv2d(norm1, [5, 5, 96, 256], scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "conv2_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool_330": {
                "variable": {
                    "value": "pool2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(conv, name='conv2_elu')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv, name='conv2_relu')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_334": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(norm2, dropout)",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ],
                        [
                            "tf.nn.lrn(pool2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm2')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 6 * 6 * 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_337": {
                "variable": {
                    "value": "lin1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear1_relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_340": {
                "variable": {
                    "value": "lin2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse, l2_norm=True, wd=wd)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', spectral_norm=False, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(reshape, 384, scope_name='linear1', update_collection=update_collection, beta=beta, reuse=reuse)",
                            "Call"
                        ],
                        [
                            "sn.linear(lin1, 192, scope_name='linear2', update_collection=update_collection, beta=beta)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "linear2_relu",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/models/elunet.py": {
        "tensorflow": {
            "elu_14": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [8, 8, 1, nb_filters], stride=2, padding='SAME', wd=wd, scope_name='conv1', spectral_norm=False, xavier=True, reuse=reuse, l2_norm=l2_norm)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_17": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(conv1, [6, 6, nb_filters, 2 * nb_filters], stride=2, padding='VALID', scope_name='conv2', spectral_norm=False, xavier=True, reuse=reuse, l2_norm=l2_norm)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_20": {
                "variable": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', spectral_norm=False, xavier=True, reuse=reuse, l2_norm=l2_norm)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_23": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.elu(sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', spectral_norm=False, xavier=True, reuse=reuse, l2_norm=l2_norm))",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', update_collection=update_collection, beta=beta, reuse=reuse))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "elu_35": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [8, 8, 1, nb_filters], stride=2, padding='SAME', scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_39": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(conv1, [6, 6, nb_filters, 2 * nb_filters], stride=2, padding='VALID', scope_name='conv2', update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_43": {
                "variable": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_47": {
                "variable": {
                    "value": "reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.elu(sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', spectral_norm=False, xavier=True, reuse=reuse, l2_norm=l2_norm))",
                            "Call"
                        ],
                        [
                            "tf.nn.elu(sn.conv2d(conv2, [5, 5, 2 * nb_filters, 2 * nb_filters], stride=1, padding='VALID', scope_name='conv3', update_collection=update_collection, beta=beta, reuse=reuse))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 128]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/models/inception.py": {
        "tensorflow": {
            "relu_43": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 96], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pool_54": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', update_collection=update_collection, beta=beta, reuse=reuse, training=training)",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[7, 7]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_68": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 96], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pool_79": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', update_collection=update_collection, beta=beta, reuse=reuse, training=training)",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[7, 7]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_94": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 96], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pool_105": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', update_collection=update_collection, beta=beta, reuse=reuse, training=training)",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[7, 7]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_119": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 96], scope_name='conv1', update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pool_141": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "incept(layer10, 176 + 160, 176, 160, scope_name='incept11', update_collection=update_collection, beta=beta, reuse=reuse, training=training)",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[7, 7]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_13": {
                "variable": {
                    "value": "ch1_output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_x, [1, 1, input_filters, ch1_filters], scope_name='conv_ch1', spectral_norm=spectral_norm, xavier=True, bn=bn, beta=beta, tighter_sn=tighter_sn, update_collection=update_collection, reuse=reuse, training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_17": {
                "variable": {
                    "value": "ch3_output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_x, [3, 3, input_filters, ch3_filters], scope_name='conv_ch3', spectral_norm=spectral_norm, xavier=True, bn=bn, beta=beta, tighter_sn=tighter_sn, update_collection=update_collection, reuse=reuse, training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_29": {
                "variable": {
                    "value": "ch3_output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_x, [3, 3, input_filters, ch3_filters], tighter_sn=tighter_sn, scope_name='conv_ch3', spectral_norm=spectral_norm, xavier=True, bn=bn, stride=2, beta=beta, reuse=reuse, update_collection=update_collection, training=training)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_33": {
                "variable": {
                    "value": "pool_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 3, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_12": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'incept'",
                            "Method Argument"
                        ],
                        [
                            "'downsamp'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_21": {
                "values": {
                    "value": "[ch1_output, ch3_output]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_28": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'incept'",
                            "Method Argument"
                        ],
                        [
                            "'downsamp'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_35": {
                "values": {
                    "value": "[ch3_output, pool_output]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/models/mlp.py": {
        "tensorflow": {
            "relu_11": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_22": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_33": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_44": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_55": {
                "variable": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden1', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_57": {
                "variable": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(hidden1, 512, scope_name='hidden2', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_68": {
                "variable": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden1', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_70": {
                "variable": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(hidden1, 512, scope_name='hidden2', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_81": {
                "variable": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden1', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_83": {
                "variable": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(hidden1, 512, scope_name='hidden2', xavier=True, spectral_norm=False, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_94": {
                "variable": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(input_data, 512, scope_name='hidden1', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "elu_96": {
                "variable": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.linear(hidden1, 512, scope_name='hidden2', xavier=True, update_collection=update_collection, beta=beta, reuse=reuse)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/models/resnet.py": {
        "tensorflow": {
            "pad_22": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_93": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_100": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_103": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_104": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_reduce_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_129": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_137": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_140": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_141": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_reduce_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_166": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_173": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_176": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_177": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_reduce_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_205": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_212": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_215": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_216": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_reduce_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_normalization_13": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "momentum": {
                    "value": "0.997",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_45": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_53": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_106": {
                "name": {
                    "value": "debug",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_143": {
                "name": {
                    "value": "debug",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_179": {
                "name": {
                    "value": "debug",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_218": {
                "name": {
                    "value": "debug",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv2d'",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_normalization_44": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, strides, name='conv1', **kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs, filters, 3, 1, name='conv2', **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, projection_shortcut, strides, 'block0', bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, training, None, 1, 'block{}'.format(i), bn=bn, **kwargs)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=True, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "batch_norm(inputs, training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(input_data, num_filters, kernel_size, conv_stride, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs, num_filters, block_fn, num_blocks, block_strides[i], training, name='block_layer{}'.format(i + 1), bn=False, **snconv_kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_reduce_mean')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "training",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_63": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv2d'",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/models/softmax.py": {
        "tensorflow": {}
    },
    "dl_spectral_normalization/models/vgg.py": {
        "tensorflow": {
            "relu_16": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 64], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_17": {
                "variable": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_18": {
                "variable": {
                    "value": "layer3",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_21": {
                "variable": {
                    "value": "layer4",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer3, [3, 3, 64, 128], scope_name='conv4', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_22": {
                "variable": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_23": {
                "variable": {
                    "value": "layer6",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool6",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_26": {
                "variable": {
                    "value": "layer7",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer6, [3, 3, 128, 256], scope_name='conv7', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_27": {
                "variable": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_28": {
                "variable": {
                    "value": "layer9",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool9",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_31": {
                "variable": {
                    "value": "layer10",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer9, [3, 3, 256, 512], scope_name='conv10', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_32": {
                "variable": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_33": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pool_36": {
                "variable": {
                    "value": "layer13",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[4, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool13",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_51": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 64], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_52": {
                "variable": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_53": {
                "variable": {
                    "value": "layer3",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_56": {
                "variable": {
                    "value": "layer4",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer3, [3, 3, 64, 128], scope_name='conv4', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_57": {
                "variable": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_58": {
                "variable": {
                    "value": "layer6",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool6",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_61": {
                "variable": {
                    "value": "layer7",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer6, [3, 3, 128, 256], scope_name='conv7', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_62": {
                "variable": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_63": {
                "variable": {
                    "value": "layer9",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool9",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_66": {
                "variable": {
                    "value": "layer10",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer9, [3, 3, 256, 512], scope_name='conv10', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_67": {
                "variable": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_68": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pool_71": {
                "variable": {
                    "value": "layer13",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[4, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool13",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_90": {
                "variable": {
                    "value": "layer1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(input_data, [3, 3, 3, 64], scope_name='conv1', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_91": {
                "variable": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_92": {
                "variable": {
                    "value": "layer3",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer1, [3, 3, 64, 64], scope_name='conv2', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_95": {
                "variable": {
                    "value": "layer4",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer3, [3, 3, 64, 128], scope_name='conv4', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_96": {
                "variable": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_97": {
                "variable": {
                    "value": "layer6",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer4, [3, 3, 128, 128], scope_name='conv5', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool6",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_100": {
                "variable": {
                    "value": "layer7",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer6, [3, 3, 128, 256], scope_name='conv7', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_101": {
                "variable": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_102": {
                "variable": {
                    "value": "layer9",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer8",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer7, [3, 3, 256, 256], scope_name='conv8', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool9",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_105": {
                "variable": {
                    "value": "layer10",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer9, [3, 3, 256, 512], scope_name='conv10', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_106": {
                "variable": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_107": {
                "variable": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer11",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(sn.conv2d(layer10, [3, 3, 512, 512], scope_name='conv11', **snconv_kwargs))",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pool12",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pool_110": {
                "variable": {
                    "value": "layer13",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer12",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(layer11, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID', name='pool12')",
                            "Call"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[4, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "AVG",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mean_pool13",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "dl_spectral_normalization/sn.py": {
        "tensorflow": {
            "conv2d_51": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_67": {
                "variable": {
                    "value": "flat_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ],
                        [
                            "input_x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, reduce(mul, shape[1:])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_81": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "output_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_size",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_34": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv2d'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_36": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_53": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "output_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size[3]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_54": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input_x, weights, strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(conv, bias)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(conv, training=training)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', output_len, tf.float32, initializer=tf.constant_initializer(0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', output_size, tf.float32, initializer=tf.constant_initializer(0))",
                            "Call"
                        ]
                    ]
                }
            },
            "batch_normalization_56": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input_x, weights, strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(conv, bias)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(conv, training=training)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_74": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv2d'",
                            "Method Argument"
                        ],
                        [
                            "'linear'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_76": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_79": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.02)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'weights_SN'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_127": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration_conv(u, weights, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "maximum_128": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.multiply(z, v_hat)) / beta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_143": {
                "variable": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, w_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_145": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(tf.matmul(v_hat, w_mat), tf.transpose(u_hat)) / beta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_156": {
                "name": {
                    "value": "w_after_sn",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / sigma",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(w_mat, w_shape)",
                            "Call"
                        ],
                        [
                            "weights / sigma",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(w_mat, w_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_39": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_42": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.02)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_49": {
                "variable": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_85": {
                "variable": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_87": {
                "a": {
                    "value": "flat_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_x, [-1, reduce(mul, shape[1:])])",
                            "Call"
                        ],
                        [
                            "input_x",
                            "variable"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_123": {
                "variable": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "u",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, u_width, u_width, u_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_140": {
                "variable": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "u",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, w_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_154": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "w_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_17": {
                "input_tensor": {
                    "value": "input_x ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_to_collection_50": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(weights), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "tf.multiply(tf.nn.l2_loss(weights), wd, name='weight_loss')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_81": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_86": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(weights), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "tf.multiply(tf.nn.l2_loss(weights), wd, name='weight_loss')",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_99": {
                "a": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.matmul(v_, w_mat))",
                            "Call"
                        ],
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d_transpose(v_, w_mat, [1, u_width, u_width, u_depth], strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(w_mat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_100": {
                "a": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "l2_norm(tf.matmul(u_, tf.transpose(w_mat)))",
                            "Call"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d(u_, w_mat, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_106": {
                "input": {
                    "value": "u_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.matmul(v_, w_mat))",
                            "Call"
                        ],
                        [
                            "u",
                            "variable"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d_transpose(v_, w_mat, [1, u_width, u_width, u_depth], strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_107": {
                "input": {
                    "value": "v_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "l2_norm(tf.matmul(u_, tf.transpose(w_mat)))",
                            "Call"
                        ],
                        [
                            "l2_norm(tf.nn.conv2d(u_, w_mat, strides=[1, stride, stride, 1], padding=padding))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "[1, u_width, u_width, u_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_134": {
                "name": {
                    "value": "update_collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "u.assign(u_hat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "w_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_153": {
                "name": {
                    "value": "update_collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "u.assign(u_hat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_49": {
                "t": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_53": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_normal_initializer_80": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                }
            },
            "l2_loss_85": {
                "t": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.variance_scaling_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', kernel_size, tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, tighter_sn=tighter_sn, u_width=u_width, beta=beta, u_depth=kernel_size[-2], stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', [input_size, output_size], tf.float32, initializer=tf.random_normal_initializer(stddev=0.02))",
                            "Call"
                        ],
                        [
                            "weights_spectral_norm(weights, update_collection=update_collection, beta=beta)",
                            "Call"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_99": {
                "a": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_128": {
                "input_tensor": {
                    "value": "tf.multiply(z, v_hat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_131": {
                "control_inputs": {
                    "value": "[u.assign(u_hat)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_145": {
                "a": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration_conv(u, weights, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, [-1, w_shape[-1]])",
                            "Call"
                        ],
                        [
                            "w_mat / sigma",
                            "BinOp"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ],
                        [
                            "w_mat",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "control_dependencies_150": {
                "control_inputs": {
                    "value": "[u.assign(u_hat)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_normal_initializer_43": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_128": {
                "x": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(u_hat, weights, strides=[1, stride, stride, 1], padding=padding)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration_conv(u, weights, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                }
            },
            "truncated_normal_initializer_141": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_145": {
                "a": {
                    "value": "u_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "power_iteration_conv(u, weights, Ip)",
                            "Call"
                        ],
                        [
                            "power_iteration(u, w_mat, Ip)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "get_cifar10.py": {
        "tensorflow": {}
    },
    "notebooks_figures/analysis.py": {
        "tensorflow": {
            "gradients_41": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "g['total_loss']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "xs": {
                    "value": "g['input_data']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reset_default_graph_39": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_47": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True, gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_47": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(per_process_gpu_memory_fraction=gpu_prop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GPUOptions_48": {
                "per_process_gpu_memory_fraction": {
                    "value": "gpu_prop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}