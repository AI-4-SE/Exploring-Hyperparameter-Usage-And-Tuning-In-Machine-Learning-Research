{
    "lib/builder/anchor_builder.py": {
        "tensorflow": {
            "expand_dims_57": {
                "input": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points",
                            "Method Argument"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/builder/data_augmentor.py": {
        "tensorflow": {}
    },
    "lib/builder/encoder_builder.py": {
        "tensorflow": {
            "reshape_52": {
                "variable": {
                    "value": "gt_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "gt_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_gt_boxes[:, :, :, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(gt_offset, [bs, points_num * cls_num, 6])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, 6]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_53": {
                "variable": {
                    "value": "reshape_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "batch_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(batch_anchors_3d, [bs, points_num * cls_num, -1])",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d",
                            "Method Argument"
                        ],
                        [
                            "batch_anchors_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_55": {
                "variable": {
                    "value": "(gt_ctr, gt_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "gt_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_gt_boxes[:, :, :, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(gt_offset, [bs, points_num * cls_num, 6])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_64": {
                "variable": {
                    "value": "encoded_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoded_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder(gt_ctr, gt_size, center_xyz)",
                            "Call"
                        ],
                        [
                            "self.encoder(gt_ctr, gt_size, anchor_ctr, anchor_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoded_ctr, [bs, points_num, cls_num, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_65": {
                "variable": {
                    "value": "encoded_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoded_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder(gt_ctr, gt_size, center_xyz)",
                            "Call"
                        ],
                        [
                            "self.encoder(gt_ctr, gt_size, anchor_ctr, anchor_size)",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoded_offset, [bs, points_num, cls_num, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_71": {
                "variable": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoded_ctr, encoded_offset]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_83": {
                "variable": {
                    "value": "det_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "det_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(det_offset, [bs, points_num * cls_num, -1])",
                            "Call"
                        ],
                        [
                            "det_offset",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_84": {
                "variable": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(det_angle_cls, [bs, points_num * cls_num, cfg.MODEL.ANGLE_CLS_NUM])",
                            "Call"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, cfg.MODEL.ANGLE_CLS_NUM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_85": {
                "variable": {
                    "value": "det_angle_res",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "det_angle_res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(det_angle_res, [bs, points_num * cls_num, cfg.MODEL.ANGLE_CLS_NUM])",
                            "Call"
                        ],
                        [
                            "det_angle_res",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, cfg.MODEL.ANGLE_CLS_NUM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "batch_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "batch_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(batch_anchors_3d, [bs, points_num * cls_num, -1])",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d",
                            "Method Argument"
                        ],
                        [
                            "batch_anchors_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_93": {
                "variable": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.decoder(center_xyz, det_offset, det_angle_cls, det_angle_res, is_training)",
                            "Call"
                        ],
                        [
                            "self.decoder(det_offset, det_angle_cls, det_angle_res, batch_anchors_3d, is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_anchors_3d, [bs, points_num, cls_num, 7])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_60": {
                "variable": {
                    "value": "(anchor_ctr, anchor_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "reshape_anchors_3d[:, :, :-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/builder/layer_builder.py": {
        "tensorflow": {}
    },
    "lib/builder/loss_builder.py": {
        "tensorflow": {
            "reduce_max_64": {
                "variable": {
                    "value": "cls_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cls_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pmask + nmask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(cls_mask, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_68": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(cls_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_94": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'cls_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_110": {
                "variable": {
                    "value": "assigned_boxes_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "assigned_boxes_3d * tf.expand_dims(pmask, axis=-1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_111": {
                "variable": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_114": {
                "variable": {
                    "value": "canonical_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "canonical_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_xyz - assigned_boxes_3d[:, :, :3]",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(canonical_xyz, [bs * pts_num, 1, 3])",
                            "Call"
                        ],
                        [
                            "rotate_points(canonical_xyz, -rys)",
                            "Call"
                        ],
                        [
                            "tf.reshape(canonical_xyz, [bs, pts_num, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * pts_num, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_115": {
                "variable": {
                    "value": "rys",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_boxes_3d[:, :, -1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[bs * pts_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_117": {
                "variable": {
                    "value": "canonical_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "canonical_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_xyz - assigned_boxes_3d[:, :, :3]",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(canonical_xyz, [bs * pts_num, 1, 3])",
                            "Call"
                        ],
                        [
                            "rotate_points(canonical_xyz, -rys)",
                            "Call"
                        ],
                        [
                            "tf.reshape(canonical_xyz, [bs, pts_num, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, pts_num, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_129": {
                "variable": {
                    "value": "ctr_ness",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ctr_ness_l * ctr_ness_h * ctr_ness_w",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-06",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pow_130": {
                "variable": {
                    "value": "ctr_ness",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ctr_ness",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._generate_centerness_label(base_xyz, assigned_boxes_3d, pmask)",
                            "Call"
                        ],
                        [
                            "tf.maximum(ctr_ness_l * ctr_ness_h * ctr_ness_w, epsilon)",
                            "Call"
                        ],
                        [
                            "tf.pow(ctr_ness, 1 / 3.0)",
                            "Call"
                        ],
                        [
                            "ctr_ness + min_ctr_ness",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "1 / 3.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_max_142": {
                "variable": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_145": {
                "variable": {
                    "value": "gt_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_158": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(pmask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_162": {
                "variable": {
                    "value": "iou_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(iou_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'iou_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "py_func_172": {
                "variable": {
                    "value": "(vote_mask, vote_target)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "vote_targets_np",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[vote_base, gt_boxes_3d]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.float32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_173": {
                "variable": {
                    "value": "vote_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "vote_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(vote_targets_np, [vote_base, gt_boxes_3d], [tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(vote_mask, [bs, pts_num])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, pts_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_174": {
                "variable": {
                    "value": "vote_target",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "vote_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(vote_targets_np, [vote_base, gt_boxes_3d], [tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(vote_target, [bs, pts_num, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, pts_num, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_178": {
                "variable": {
                    "value": "vote_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "vote_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vote_loss",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(model_util.huber_loss(vote_target - vote_offset, delta=1.0), axis=-1) * vote_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(vote_loss) / tf.maximum(1.0, tf.reduce_sum(vote_mask))",
                            "BinOp"
                        ],
                        [
                            "tf.identity(vote_loss, 'vote_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'vote_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_192": {
                "variable": {
                    "value": "attr_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(gt_attribute, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_194": {
                "variable": {
                    "value": "gt_attribute_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(gt_attribute, depth=8, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_195": {
                "variable": {
                    "value": "attr_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "gt_attribute_onehot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.one_hot(gt_attribute, depth=8, on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_attribute",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_ATTRIBUTE][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "identity_198": {
                "variable": {
                    "value": "attr_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attr_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_attribute_onehot, logits=pred_attribute)",
                            "Call"
                        ],
                        [
                            "attr_loss * tf.expand_dims(attr_mask, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(attr_loss) / (tf.maximum(1.0, tf.reduce_sum(attr_mask)) * 8.0)",
                            "BinOp"
                        ],
                        [
                            "tf.identity(attr_loss, 'attribute_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'attribute_loss_%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_202": {
                "variable": {
                    "value": "velo_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.logical_not(tf.is_nan(tf.reduce_sum(gt_velocity, axis=-1)))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_204": {
                "variable": {
                    "value": "zero_velocity",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gt_velocity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_VELOCITY][index]",
                            "Subscript"
                        ],
                        [
                            "tf.where(tf.is_nan(gt_velocity), zero_velocity, gt_velocity)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_205": {
                "variable": {
                    "value": "gt_velocity",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_nan(gt_velocity)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "zero_velocity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(gt_velocity)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "gt_velocity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_VELOCITY][index]",
                            "Subscript"
                        ],
                        [
                            "tf.where(tf.is_nan(gt_velocity), zero_velocity, gt_velocity)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_208": {
                "variable": {
                    "value": "velo_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(velo_loss) / tf.maximum(1.0, tf.reduce_sum(velo_mask))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'velocity_loss_%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_220": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(pmask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_224": {
                "variable": {
                    "value": "corner_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(corner_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'corner_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_236": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(pmask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_240": {
                "variable": {
                    "value": "offset_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(offset_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'offset_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "unstack_251": {
                "variable": {
                    "value": "(xbin, xres, zbin, zres)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "gt_offset[:, :, :, :4]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_255": {
                "variable": {
                    "value": "pred_xbin",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ],
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, self.reg_bin_cls_num * 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, self.reg_bin_cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_256": {
                "variable": {
                    "value": "pred_xres",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ],
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, self.reg_bin_cls_num * 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, self.reg_bin_cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_257": {
                "variable": {
                    "value": "pred_zbin",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ],
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, self.reg_bin_cls_num * 2]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, self.reg_bin_cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_258": {
                "variable": {
                    "value": "pred_zres",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ],
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, self.reg_bin_cls_num * 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, self.reg_bin_cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_259": {
                "variable": {
                    "value": "pred_other_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ],
                        [
                            "pred_dict[maps_dict.PRED_OFFSET][index]",
                            "Subscript"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, self.reg_bin_cls_num * 4]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_261": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(pmask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_268": {
                "variable": {
                    "value": "other_offset_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(other_offset_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'other_offset_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_283": {
                "variable": {
                    "value": "norm_param",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(pmask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_290": {
                "variable": {
                    "value": "gt_bin",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gt_bin, tf.int32)",
                            "Call"
                        ],
                        [
                            "gt_bin",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_293": {
                "variable": {
                    "value": "bin_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(bin_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'bin_%s' % scope",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_297": {
                "variable": {
                    "value": "gt_bin_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(gt_bin, depth=bin_class_num, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_298": {
                "variable": {
                    "value": "pred_res",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pred_res * gt_bin_onehot",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "identity_300": {
                "variable": {
                    "value": "res_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(res_loss) / norm_param",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'res_%s' % scope",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_71": {
                "variable": {
                    "value": "gt_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_95": {
                "name": {
                    "value": "'cls_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_96": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_163": {
                "name": {
                    "value": "'iou_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "iou_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "iou_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_iou - target_iou_3d, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(iou_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(iou_loss) / norm_param, 'iou_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_164": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "iou_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "iou_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_iou - target_iou_3d, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(iou_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(iou_loss) / norm_param, 'iou_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_179": {
                "name": {
                    "value": "'vote_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "vote_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vote_loss",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(model_util.huber_loss(vote_target - vote_offset, delta=1.0), axis=-1) * vote_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(vote_loss) / tf.maximum(1.0, tf.reduce_sum(vote_mask))",
                            "BinOp"
                        ],
                        [
                            "tf.identity(vote_loss, 'vote_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_180": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "vote_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vote_loss",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(model_util.huber_loss(vote_target - vote_offset, delta=1.0), axis=-1) * vote_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(vote_loss) / tf.maximum(1.0, tf.reduce_sum(vote_mask))",
                            "BinOp"
                        ],
                        [
                            "tf.identity(vote_loss, 'vote_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_199": {
                "name": {
                    "value": "'attribute_loss_%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "attr_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_attribute_onehot, logits=pred_attribute)",
                            "Call"
                        ],
                        [
                            "attr_loss * tf.expand_dims(attr_mask, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(attr_loss) / (tf.maximum(1.0, tf.reduce_sum(attr_mask)) * 8.0)",
                            "BinOp"
                        ],
                        [
                            "tf.identity(attr_loss, 'attribute_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_200": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "attr_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_attribute_onehot, logits=pred_attribute)",
                            "Call"
                        ],
                        [
                            "attr_loss * tf.expand_dims(attr_mask, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(attr_loss) / (tf.maximum(1.0, tf.reduce_sum(attr_mask)) * 8.0)",
                            "BinOp"
                        ],
                        [
                            "tf.identity(attr_loss, 'attribute_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_209": {
                "name": {
                    "value": "'velocity_loss_%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "velo_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_velocity - gt_velocity, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(velo_loss, axis=-1) * velo_mask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(velo_loss) / tf.maximum(1.0, tf.reduce_sum(velo_mask)), 'velocity_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_210": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "velo_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_velocity - gt_velocity, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(velo_loss, axis=-1) * velo_mask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(velo_loss) / tf.maximum(1.0, tf.reduce_sum(velo_mask)), 'velocity_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_225": {
                "name": {
                    "value": "'corner_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "corner_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "corner_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_corners - gt_corners, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(corner_loss, axis=[-2, -1]) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(corner_loss) / norm_param, 'corner_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_226": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "corner_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "corner_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_corners - gt_corners, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(corner_loss, axis=[-2, -1]) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(corner_loss) / norm_param, 'corner_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_241": {
                "name": {
                    "value": "'offset_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_offset - gt_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(offset_loss) / norm_param, 'offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_242": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_offset - gt_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(offset_loss) / norm_param, 'offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_269": {
                "name": {
                    "value": "'other_offset_loss%d' % index",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "other_offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_other_offset - gt_other_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(other_offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(other_offset_loss) / norm_param, 'other_offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_270": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "other_offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_other_offset - gt_other_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(other_offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(other_offset_loss) / norm_param, 'other_offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_294": {
                "name": {
                    "value": "'bin_%s' % scope",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "bin_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=pred_bin, labels=gt_bin) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(bin_loss) / norm_param, 'bin_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_295": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "bin_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=pred_bin, labels=gt_bin) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(bin_loss) / norm_param, 'bin_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_301": {
                "name": {
                    "value": "'res_%s' % scope",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "res_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss((pred_res - gt_res) * pmask, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(res_loss) / norm_param, 'res_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_302": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "res_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss((pred_res - gt_res) * pmask, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(res_loss) / norm_param, 'res_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_42": {
                "name": {
                    "value": "'loss_stage%d' % self.stage",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "input_tensor": {
                    "value": "cls_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pmask + nmask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(cls_mask, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_75": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "gt_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ],
                        [
                            "gt_cls * tf.expand_dims(ctr_ness, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_77": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "gt_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ],
                        [
                            "gt_cls * tf.expand_dims(ctr_ness, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_mean_78": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_82": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_93": {
                "input_tensor": {
                    "value": "cls_loss * cls_mask",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_145": {
                "indices": {
                    "value": "gt_cls - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "len(self.cls_list)",
                    "type": "Call",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_158": {
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_161": {
                "input_tensor": {
                    "value": "iou_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "iou_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_iou - target_iou_3d, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(iou_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(iou_loss) / norm_param, 'iou_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_176": {
                "input_tensor": {
                    "value": "model_util.huber_loss(vote_target - vote_offset, delta=1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_177": {
                "input_tensor": {
                    "value": "vote_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(vote_targets_np, [vote_base, gt_boxes_3d], [tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(vote_mask, [bs, pts_num])",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_177": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(vote_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "greater_equal_192": {
                "x": {
                    "value": "gt_attribute",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_ATTRIBUTE][index]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_194": {
                "indices": {
                    "value": "gt_attribute",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_ATTRIBUTE][index]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_196": {
                "input": {
                    "value": "attr_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.greater_equal(gt_attribute, 0), tf.float32)",
                            "Call"
                        ],
                        [
                            "attr_mask * pmask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_197": {
                "input_tensor": {
                    "value": "attr_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.greater_equal(gt_attribute, 0), tf.float32)",
                            "Call"
                        ],
                        [
                            "attr_mask * pmask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "logical_not_202": {
                "x": {
                    "value": "tf.is_nan(tf.reduce_sum(gt_velocity, axis=-1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "is_nan_205": {
                "x": {
                    "value": "gt_velocity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_VELOCITY][index]",
                            "Subscript"
                        ],
                        [
                            "tf.where(tf.is_nan(gt_velocity), zero_velocity, gt_velocity)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_207": {
                "input_tensor": {
                    "value": "velo_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_velocity - gt_velocity, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(velo_loss, axis=-1) * velo_mask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(velo_loss) / tf.maximum(1.0, tf.reduce_sum(velo_mask)), 'velocity_loss_%d' % index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_220": {
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_223": {
                "input_tensor": {
                    "value": "corner_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "corner_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_corners - gt_corners, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(corner_loss, axis=[-2, -1]) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(corner_loss) / norm_param, 'corner_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_236": {
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_239": {
                "input_tensor": {
                    "value": "offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_offset - gt_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(offset_loss) / norm_param, 'offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_261": {
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_267": {
                "input_tensor": {
                    "value": "other_offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_other_offset - gt_other_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(other_offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(other_offset_loss) / norm_param, 'other_offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_283": {
                "input_tensor": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_292": {
                "logits": {
                    "value": "pred_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_bin",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "gt_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gt_bin, tf.int32)",
                            "Call"
                        ],
                        [
                            "gt_bin",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_297": {
                "indices": {
                    "value": "gt_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gt_bin, tf.int32)",
                            "Call"
                        ],
                        [
                            "gt_bin",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "bin_class_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bin_class_num",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_71": {
                "indices": {
                    "value": "gt_cls - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "len(self.cls_list)",
                    "type": "Call",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stop_gradient_86": {
                "variable": {
                    "value": "base_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "base_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.KEY_OUTPUT_XYZ][index]",
                            "Subscript"
                        ],
                        [
                            "tf.stop_gradient(base_xyz)",
                            "Call"
                        ],
                        [
                            "base_xyz",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_90": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "gt_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ],
                        [
                            "gt_cls * tf.expand_dims(ctr_ness, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "label_dict[maps_dict.GT_CLS][index]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.one_hot(gt_cls - 1, depth=len(self.cls_list), on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_dict[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_mean_91": {
                "variable": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "model_util.focal_loss_producer(pred_cls, gt_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(cls_loss * cls_mask) / norm_param",
                            "BinOp"
                        ],
                        [
                            "tf.identity(cls_loss, 'cls_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=gt_cls, logits=pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(cls_loss, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_110": {
                "input": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=2)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_max(pmask, axis=-1)",
                            "Call"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "label_dict[maps_dict.GT_PMASK][index]",
                            "Subscript"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "minimum_126": {
                "x": {
                    "value": "distance_front",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_boxes_3d[:, :, 3] / 2.0 - canonical_xyz[:, :, 0]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_back",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 0] + assigned_boxes_3d[:, :, 3] / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_126": {
                "x": {
                    "value": "distance_front",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_boxes_3d[:, :, 3] / 2.0 - canonical_xyz[:, :, 0]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_back",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 0] + assigned_boxes_3d[:, :, 3] / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "minimum_127": {
                "x": {
                    "value": "distance_left",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_boxes_3d[:, :, 5] / 2.0 - canonical_xyz[:, :, 2]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_right",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 2] + assigned_boxes_3d[:, :, 5] / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_127": {
                "x": {
                    "value": "distance_left",
                    "type": "variable",
                    "possible_values": [
                        [
                            "assigned_boxes_3d[:, :, 5] / 2.0 - canonical_xyz[:, :, 2]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_right",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 2] + assigned_boxes_3d[:, :, 5] / 2.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "minimum_128": {
                "x": {
                    "value": "distance_bottom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0 - canonical_xyz[:, :, 1]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 1] + assigned_boxes_3d[:, :, 4]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_128": {
                "x": {
                    "value": "distance_bottom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0 - canonical_xyz[:, :, 1]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "distance_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "canonical_xyz[:, :, 1] + assigned_boxes_3d[:, :, 4]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_162": {
                "input_tensor": {
                    "value": "iou_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "iou_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_iou - target_iou_3d, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(iou_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(iou_loss) / norm_param, 'iou_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "maximum_197": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(attr_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "is_nan_202": {
                "x": {
                    "value": "tf.reduce_sum(gt_velocity, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_208": {
                "input_tensor": {
                    "value": "velo_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.logical_not(tf.is_nan(tf.reduce_sum(gt_velocity, axis=-1))), tf.float32)",
                            "Call"
                        ],
                        [
                            "velo_mask * pmask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_208": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(velo_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_224": {
                "input_tensor": {
                    "value": "corner_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "corner_loss",
                            "Call"
                        ],
                        [
                            "model_util.huber_loss(pred_corners - gt_corners, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(corner_loss, axis=[-2, -1]) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(corner_loss) / norm_param, 'corner_loss%d' % index)",
                            "Call"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_240": {
                "input_tensor": {
                    "value": "offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_offset - gt_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(offset_loss) / norm_param, 'offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_268": {
                "input_tensor": {
                    "value": "other_offset_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss(pred_other_offset - gt_other_offset, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(other_offset_loss, axis=-1) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(other_offset_loss) / norm_param, 'other_offset_loss%d' % index)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_293": {
                "input_tensor": {
                    "value": "bin_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=pred_bin, labels=gt_bin) * pmask",
                            "BinOp"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(bin_loss) / norm_param, 'bin_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_300": {
                "input_tensor": {
                    "value": "res_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.huber_loss((pred_res - gt_res) * pmask, delta=1.0)",
                            "Call"
                        ],
                        [
                            "tf.identity(tf.reduce_sum(res_loss) / norm_param, 'res_%s' % scope)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_202": {
                "input_tensor": {
                    "value": "gt_velocity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "label_dict[maps_dict.GT_VELOCITY][index]",
                            "Subscript"
                        ],
                        [
                            "tf.where(tf.is_nan(gt_velocity), zero_velocity, gt_velocity)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_89": {
                "input": {
                    "value": "ctr_ness",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._generate_centerness_label(base_xyz, assigned_boxes_3d, pmask)",
                            "Call"
                        ],
                        [
                            "tf.maximum(ctr_ness_l * ctr_ness_h * ctr_ness_w, epsilon)",
                            "Call"
                        ],
                        [
                            "tf.pow(ctr_ness, 1 / 3.0)",
                            "Call"
                        ],
                        [
                            "ctr_ness + min_ctr_ness",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/builder/mixup_sampler.py": {
        "tensorflow": {}
    },
    "lib/builder/points_pooler.py": {
        "tensorflow": {
            "reduce_max_35": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_boxes_3d_mask(base_xyz, expand_pred_boxes_3d)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_36": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_boxes_3d_mask(base_xyz, expand_pred_boxes_3d)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_53": {
                "variable": {
                    "value": "additional_info",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[canonical_xyz, pool_info]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_56": {
                "variable": {
                    "value": "pool_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[canonical_xyz, pool_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_59": {
                "variable": {
                    "value": "pool_output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pool_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([canonical_xyz, pool_feature], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pool_output, [bs * proposal_num, nsample, c])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * proposal_num, nsample, c]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_77": {
                "variable": {
                    "value": "additional_info",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[local_canonical_xyz, canonical_xyz, pool_info]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_79": {
                "variable": {
                    "value": "pool_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[additional_info, pool_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_84": {
                "variable": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "dense_feature_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "voxel_pts_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * proposal_num, self.l * self.h * self.w, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_87": {
                "variable": {
                    "value": "dense_feature_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dense_feature_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(voxel_pts_num, [bs * proposal_num, self.l * self.h * self.w, 1])",
                            "Call"
                        ],
                        [
                            "tf.greater(dense_feature_mask, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(dense_feature_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_88": {
                "variable": {
                    "value": "dense_feature_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dense_feature_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(voxel_pts_num, [bs * proposal_num, self.l * self.h * self.w, 1])",
                            "Call"
                        ],
                        [
                            "tf.greater(dense_feature_mask, 0)",
                            "Call"
                        ],
                        [
                            "tf.cast(dense_feature_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_89": {
                "variable": {
                    "value": "voxel_ctrs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "voxel_ctrs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(voxel_ctrs, [bs * proposal_num, self.l * self.h * self.w, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * proposal_num, self.l * self.h * self.w, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_91": {
                "variable": {
                    "value": "dense_local_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_92": {
                "variable": {
                    "value": "dense_canonical_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_93": {
                "variable": {
                    "value": "dense_info",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 6]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, additional_info_channel - 6]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_94": {
                "variable": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, additional_info_channel]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_97": {
                "variable": {
                    "value": "dense_additional_info",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dense_canonical_xyz, dense_info, dense_pillars_info]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_102": {
                "variable": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dense_feature, [bs * proposal_num, self.l * self.h * self.w, self.sample_num, channel_num])",
                            "Call"
                        ],
                        [
                            "tf.slice(dense_feature, [0, 0, 0, additional_info_channel], [-1, -1, -1, -1])",
                            "Call"
                        ],
                        [
                            "self.align_info_and_feature(dense_additional_info, dense_feature, is_training, bn_decay)",
                            "Call"
                        ],
                        [
                            "align_channel_network(dense_feature, self.vfe_channel_list, self.bn, is_training, bn_decay, '%s/vfe' % self.scope)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(dense_feature, axis=2)",
                            "Call"
                        ],
                        [
                            "dense_feature * dense_feature_mask",
                            "BinOp"
                        ],
                        [
                            "tf.concat([dense_voxel_ctrs, dense_feature], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_105": {
                "variable": {
                    "value": "dense_voxel_ctrs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "voxel_ctrs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points_pooling(pool_feature, expand_pred_boxes_3d[:, :, :-1], local_canonical_xyz, l=self.l, h=self.h, w=self.w, sample_num=self.sample_num)",
                            "Call"
                        ],
                        [
                            "tf.reshape(voxel_ctrs, [bs * proposal_num, self.l * self.h * self.w, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs * proposal_num, self.l * self.h * self.w, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_106": {
                "variable": {
                    "value": "dense_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dense_voxel_ctrs, dense_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_115": {
                "variable": {
                    "value": "pool_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoded_info, pool_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_125": {
                "variable": {
                    "value": "pool_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(tf.greater(pool_cnt, 0), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_138": {
                "variable": {
                    "value": "pool_info",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pool_info_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_164": {
                "variable": {
                    "value": "pred_boxes_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_165": {
                "variable": {
                    "value": "pred_boxes_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_166": {
                "variable": {
                    "value": "pred_boxes_ry",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_boxes_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 6]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_169": {
                "variable": {
                    "value": "expand_pred_boxes_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_boxes_ctr, pred_boxes_size, pred_boxes_ry]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_75": {
                "input": {
                    "value": "expand_pred_boxes_3d[:, :, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_125": {
                "x": {
                    "value": "tf.greater(pool_cnt, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "norm_134": {
                "tensor": {
                    "value": "pool_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gather_interior_xyz_feature(base_xyz, base_feature, base_mask, expand_pred_boxes_3d)",
                            "Call"
                        ],
                        [
                            "self.gather_interior_xyz_feature(base_xyz, base_feature, base_mask, expand_pred_boxes_3d)",
                            "Call"
                        ],
                        [
                            "group_point(base_xyz, pool_idx)",
                            "Call"
                        ],
                        [
                            "pool_xyz",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_125": {
                "x": {
                    "value": "pool_cnt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_boxes_3d_points(self.sample_pts_num, base_xyz, pred_boxes_3d)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_152": {
                "input": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "proposals",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/builder/postprocessor.py": {
        "tensorflow": {
            "reduce_max_33": {
                "variable": {
                    "value": "unaware_pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.class_unaware_format(pred_anchors_3d, pred_score)",
                            "Call"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmax_39": {
                "variable": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.class_unaware_format(pred_anchors_3d, pred_score)",
                            "Call"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_40": {
                "variable": {
                    "value": "pred_cls_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(pred_cls, depth=cls_num, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_43": {
                "variable": {
                    "value": "unaware_pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "unaware_pred_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_anchors_3d * tf.expand_dims(pred_cls_onehot, axis=-1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(unaware_pred_anchors_3d, axis=2, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_61": {
                "variable": {
                    "value": "pred_anchors_3d_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.class_unaware_format(pred_anchors_3d, pred_score)",
                            "Call"
                        ],
                        [
                            "zip(range(len(pred_anchors_3d_list)), pred_anchors_3d_list, pred_scores_list)",
                            "Call"
                        ],
                        [
                            "pred_anchors_3d",
                            "Method Argument"
                        ],
                        [
                            "pred_anchors_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_62": {
                "variable": {
                    "value": "pred_scores_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.class_unaware_format(pred_anchors_3d, pred_score)",
                            "Call"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ],
                        [
                            "pred_score",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_111": {
                "variable": {
                    "value": "pred_3d_bbox_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pred_3d_bbox_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(pred_3d_bbox_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_112": {
                "variable": {
                    "value": "pred_3d_cls_score_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pred_3d_cls_score_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(pred_3d_cls_score_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_113": {
                "variable": {
                    "value": "pred_3d_cls_cat_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pred_3d_cls_cat_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(pred_3d_cls_cat_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_95": {
                "variable": {
                    "value": "cur_pred_3d_bbox_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_pred_3d_bbox_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(cur_pred_3d_bbox_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_96": {
                "variable": {
                    "value": "cur_pred_3d_cls_score_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_pred_3d_cls_score_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(cur_pred_3d_cls_score_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_97": {
                "variable": {
                    "value": "cur_pred_3d_cls_cat_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_pred_3d_cls_cat_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(cur_pred_3d_cls_cat_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_40": {
                "indices": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(pred_score, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "cls_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_anchors_3d.get_shape().as_list()[2]",
                            "Subscript"
                        ],
                        [
                            "pred_score.get_shape().as_list()[-1]",
                            "Subscript"
                        ],
                        [
                            "cls_num",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_42": {
                "input": {
                    "value": "pred_cls_onehot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.one_hot(pred_cls, depth=cls_num, on_value=1, off_value=0, axis=-1), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "non_max_suppression_84": {
                "variable": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": []
                },
                "boxes": {
                    "value": "cur_pred_anchors_bev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "project_to_bev(cur_pred_anchors)",
                            "Call"
                        ]
                    ]
                },
                "scores": {
                    "value": "cur_cls_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_scores[:, i]",
                            "Subscript"
                        ]
                    ]
                },
                "max_output_size": {
                    "value": "self.max_output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "iou_threshold": {
                    "value": "self.nms_threshold",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_104": {
                "variable": {
                    "value": "cur_pred_attribute_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_pred_attribute_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(cur_pred_attribute_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_108": {
                "variable": {
                    "value": "cur_pred_velocity_list",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_pred_velocity_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(cur_pred_velocity_list, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_119": {
                "values": {
                    "value": "pred_attribute_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_121": {
                "values": {
                    "value": "pred_velocity_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_86": {
                "params": {
                    "value": "cur_pred_anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_anchors_3d[:, reg_i, :]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(cur_pred_anchors_bev, cur_cls_score, max_output_size=self.max_output_size, iou_threshold=self.nms_threshold)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_87": {
                "params": {
                    "value": "cur_cls_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_scores[:, i]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(cur_pred_anchors_bev, cur_cls_score, max_output_size=self.max_output_size, iou_threshold=self.nms_threshold)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_88": {
                "x": {
                    "value": "tf.ones_like(nms_index)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_91": {
                "params": {
                    "value": "pred_attribute[batch_idx, :, reg_i, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(cur_pred_anchors_bev, cur_cls_score, max_output_size=self.max_output_size, iou_threshold=self.nms_threshold)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_93": {
                "params": {
                    "value": "pred_velocity[batch_idx, :, reg_i, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(cur_pred_anchors_bev, cur_cls_score, max_output_size=self.max_output_size, iou_threshold=self.nms_threshold)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_88": {
                "input": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(cur_pred_anchors_bev, cur_cls_score, max_output_size=self.max_output_size, iou_threshold=self.nms_threshold)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "lib/builder/sampler.py": {
        "tensorflow": {
            "squeeze_32": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_44": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_57": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tensor_dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "expand_dims_46": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_48": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_52": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_list",
                            "variable"
                        ],
                        [
                            "self.gather_tensor(mask, tensor)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(tensor, tensor_dtype)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "gather_by_mask(self.proposal_num, tensor, mask)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tensor, axis=2)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/builder/target_assigner.py": {
        "tensorflow": {
            "reduce_sum_59": {
                "variable": {
                    "value": "assigned_gt_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "assigned_gt_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gather_class(gt_labels, assigned_idx)",
                            "Call"
                        ],
                        [
                            "assigned_gt_labels * tf.cast(assigned_pmask, tf.int32)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(assigned_gt_labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "group_point(gt_labels_f, assigned_idx)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.cast(assigned_gt_labels, gt_labels_dtype), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_84": {
                "variable": {
                    "value": "gt_labels_f",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(gt_labels, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_86": {
                "variable": {
                    "value": "assigned_gt_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(assigned_gt_labels, gt_labels_dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_107": {
                "variable": {
                    "value": "anchors_3d_reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchors_3d",
                            "Method Argument"
                        ],
                        [
                            "anchors_3d",
                            "Method Argument"
                        ],
                        [
                            "anchors_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num * cls_num, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_117": {
                "variable": {
                    "value": "iou_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "iou_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "iou_bev",
                            "variable"
                        ],
                        [
                            "tf.reshape(iou_matrix, [bs, points_num, cls_num, gt_num])",
                            "Call"
                        ],
                        [
                            "iou_3d",
                            "variable"
                        ],
                        [
                            "query_points_iou(points, anchors_3d_reshape, gt_boxes_3d, iou_3d)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num, gt_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "py_func_119": {
                "variable": {
                    "value": "(assigned_idx, assigned_pmask, assigned_nmask)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "gt_sampler.iou_assign_targets_anchors_np",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inp": {
                    "value": "[iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.int32, tf.float32, tf.float32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_123": {
                "variable": {
                    "value": "assigned_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_idx, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_idx, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "assigned_idx",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_124": {
                "variable": {
                    "value": "assigned_pmask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_125": {
                "variable": {
                    "value": "assigned_nmask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_nmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_nmask, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_nmask, [bs, points_num, cls_num])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "py_func_147": {
                "variable": {
                    "value": "(assigned_idx, assigned_pmask, assigned_nmask)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "gt_sampler.mask_assign_targets_anchors_np",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inp": {
                    "value": "[points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.int32, tf.float32, tf.float32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "variable": {
                    "value": "assigned_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_idx, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_idx, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "assigned_idx",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_152": {
                "variable": {
                    "value": "assigned_pmask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_153": {
                "variable": {
                    "value": "assigned_nmask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "assigned_nmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_nmask, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_nmask, [bs, points_num, cls_num])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_53": {
                "variable": {
                    "value": "valid_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[bs, points_num, cls_num]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "points.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_58": {
                "x": {
                    "value": "assigned_pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.assign_targets_anchors(points, anchors_3d, gt_boxes_3d, gt_labels, valid_mask)",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.iou_assign_targets_anchors_np, [iou_matrix, points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ],
                        [
                            "tf.py_func(gt_sampler.mask_assign_targets_anchors_np, [points, anchors_3d, gt_boxes_3d, gt_labels, self.minibatch_size, self.positive_ratio, self.pos_iou, self.neg_iou, self.effective_sample_range, valid_mask], [tf.int32, tf.float32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.reshape(assigned_pmask, [bs, points_num, cls_num])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_84": {
                "x": {
                    "value": "gt_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_labels",
                            "Method Argument"
                        ],
                        [
                            "gt_labels",
                            "Method Argument"
                        ],
                        [
                            "gt_labels",
                            "Method Argument"
                        ],
                        [
                            "gt_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "assigned_gt_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gather_class(gt_labels, assigned_idx)",
                            "Call"
                        ],
                        [
                            "assigned_gt_labels * tf.cast(assigned_pmask, tf.int32)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(assigned_gt_labels, axis=-1)",
                            "Call"
                        ],
                        [
                            "group_point(gt_labels_f, assigned_idx)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.cast(assigned_gt_labels, gt_labels_dtype), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "gt_labels_dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_labels.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_106": {
                "input": {
                    "value": "gt_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_144": {
                "input": {
                    "value": "gt_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "gt_boxes_3d",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "lib/core/data_preprocessor.py": {
        "tensorflow": {}
    },
    "lib/core/evaluator.py": {
        "tensorflow": {
            "Saver_70": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_101": {
                "variable": {
                    "value": "cur_model_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dirs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.restore_model_path",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Session_111": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/core/tester.py": {
        "tensorflow": {
            "Saver_64": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_94": {
                "variable": {
                    "value": "cur_model_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dirs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.restore_model_path",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Session_100": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/core/trainer.py": {
        "tensorflow": {
            "group_89": {
                "variable": {
                    "value": "self.train_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*self.update_op",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "GPUOptions_92": {
                "variable": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": []
                },
                "per_process_gpu_memory_fraction": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "allow_growth": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConfigProto_93": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "gpu_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GPUOptions(per_process_gpu_memory_fraction=1, allow_growth=True)",
                            "Call"
                        ]
                    ]
                },
                "device_count": {
                    "value": "{'GPU': self.gpu_num}",
                    "type": "Dict",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_100": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(gpu_options=gpu_options, device_count={'GPU': self.gpu_num}, allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_102": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_103": {
                "variable": {
                    "value": "self.merged",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_104": {
                "variable": {
                    "value": "self.train_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(self.log_dir, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_154": {
                "variable": {
                    "value": "total_loss_gpu",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "total_loss_gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reduce_mean(total_loss_gpu)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_158": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_or_create_global_step_69": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_80": {
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.total_loss_gpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_165": {
                "variable": {
                    "value": "global_variables",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_173": {
                "variable": {
                    "value": "restorer",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "variables_to_restore",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            },
            "device_68": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_73": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "momentum": {
                    "value": "cfg.SOLVER.MOMENTUM",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_85": {
                "device_name": {
                    "value": "/gpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_step_182": {
                "variable": {
                    "value": "global_step_np",
                    "type": "variable",
                    "possible_values": []
                },
                "sess": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "global_step_tensor": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_75": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_127": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_134": {
                "variable": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_trainable_loss(self.trainable_loss_prefix, scope)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gradients_143": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n(losses, name='total_loss')",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_trainable_parameter(self.trainable_param_prefix)",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_global_norm_144": {
                "variable": {
                    "value": "(clipped_gradients, gradient_norm)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(total_loss, params)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "5.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "identity_153": {
                "input": {
                    "value": "tf.reduce_mean(v)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "losses_dict.items()",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_127": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_128": {
                "device_name": {
                    "value": "'/gpu:%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_128": {
                "name": {
                    "value": "'gpu_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_collection_149": {
                "variable": {
                    "value": "extra_update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_153": {
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "losses_dict.items()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "lib/core/trainer_utils.py": {
        "tensorflow": {
            "piecewise_constant_10": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch",
                            "Method Argument"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cfg.SOLVER.STEPS",
                            "Attribute"
                        ],
                        [
                            "cfg.SOLVER.STEPS",
                            "Attribute"
                        ]
                    ]
                },
                "values": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[cfg.SOLVER.BASE_LR] + [cfg.SOLVER.BASE_LR * cfg.SOLVER.GAMMA ** (index + 1) for (index, step) in enumerate(steps)]",
                            "BinOp"
                        ],
                        [
                            "[cfg.SOLVER.BN_INIT_DECAY] + [cfg.SOLVER.BN_INIT_DECAY * cfg.SOLVER.BN_DECAY_DECAY_RATE ** (index + 1) for (index, step) in enumerate(steps)]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_12": {
                "variable": {
                    "value": "learing_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.piecewise_constant(batch, steps, values)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "piecewise_constant_18": {
                "variable": {
                    "value": "bn_momentum",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch",
                            "Method Argument"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ]
                    ]
                },
                "boundaries": {
                    "value": "steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cfg.SOLVER.STEPS",
                            "Attribute"
                        ],
                        [
                            "cfg.SOLVER.STEPS",
                            "Attribute"
                        ]
                    ]
                },
                "values": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[cfg.SOLVER.BASE_LR] + [cfg.SOLVER.BASE_LR * cfg.SOLVER.GAMMA ** (index + 1) for (index, step) in enumerate(steps)]",
                            "BinOp"
                        ],
                        [
                            "[cfg.SOLVER.BN_INIT_DECAY] + [cfg.SOLVER.BN_INIT_DECAY * cfg.SOLVER.BN_DECAY_DECAY_RATE ** (index + 1) for (index, step) in enumerate(steps)]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "minimum_20": {
                "variable": {
                    "value": "bn_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "cfg.SOLVER.BN_DECAY_CLIP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "1 - bn_momentum",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_38": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_39": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=0, values=grads)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(grad, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "NewCheckpointReader_50": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "file_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "file_name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_32": {
                "variable": {
                    "value": "expanded_g",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad_and_vars",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trainable_variables_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_65": {
                "variable": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "prefix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix_list",
                            "variable"
                        ],
                        [
                            "prefix_list",
                            "variable"
                        ]
                    ]
                }
            },
            "get_collection_74": {
                "key": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_78": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "scope": {
                    "value": "'%s%s' % (scope, prefix)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/dataset/dataloader/__init__.py": {
        "tensorflow": {}
    },
    "lib/dataset/dataloader/kitti_dataloader.py": {
        "tensorflow": {
            "squeeze_329": {
                "variable": {
                    "value": "pred_bbox_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_BBOX][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_330": {
                "variable": {
                    "value": "pred_cls_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_SCORE][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_331": {
                "variable": {
                    "value": "pred_cls_category",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_CLS_CATEGORY][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_386": {
                "variable": {
                    "value": "pred_bbox_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_list[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/dataset/dataloader/nuscenes_dataloader.py": {
        "tensorflow": {
            "squeeze_514": {
                "variable": {
                    "value": "pred_bbox_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_BBOX][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_515": {
                "variable": {
                    "value": "pred_cls_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_SCORE][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_516": {
                "variable": {
                    "value": "pred_cls_category",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_CLS_CATEGORY][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_520": {
                "variable": {
                    "value": "pred_attribute",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_ATTRIBUTE][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_521": {
                "variable": {
                    "value": "pred_velocity",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "model.output[maps_dict.PRED_3D_VELOCITY][-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/dataset/feeddict_builder.py": {
        "tensorflow": {}
    },
    "lib/dataset/placeholders.py": {
        "tensorflow": {
            "placeholder_20": {
                "variable": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dtype",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_25": {
                "name_or_scope": {
                    "value": "points_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_28": {
                "name_or_scope": {
                    "value": "pl_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_42": {
                "name_or_scope": {
                    "value": "points_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "pl_labels",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "lib/modeling/double_stage_detector.py": {
        "tensorflow": {
            "slice_148": {
                "variable": {
                    "value": "l0_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "point_cloud",
                    "type": "variable",
                    "possible_values": [
                        [
                            "point_cloud",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_149": {
                "variable": {
                    "value": "l0_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "point_cloud",
                    "type": "variable",
                    "possible_values": [
                        [
                            "point_cloud",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_190": {
                "variable": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_3D_BBOX][-1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(proposals, [self.batch_size, cfg.MODEL.FIRST_STAGE.MAX_OUTPUT_NUM, 7])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(expand_proposals, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, cfg.MODEL.FIRST_STAGE.MAX_OUTPUT_NUM, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_191": {
                "variable": {
                    "value": "expand_proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_3D_BBOX][-1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(proposals, [self.batch_size, cfg.MODEL.FIRST_STAGE.MAX_OUTPUT_NUM, 7])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(expand_proposals, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_205": {
                "variable": {
                    "value": "base_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(base_mask, self.pool_mask_thresh)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_206": {
                "variable": {
                    "value": "base_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "base_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_3D_SCORE][-1]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.greater_equal(base_mask, self.pool_mask_thresh), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(base_mask, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_288": {
                "variable": {
                    "value": "corner_loss_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(assigned_gt_angle_cls, depth=cfg.MODEL.ANGLE_CLS_NUM, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_197": {
                "variable": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "expand_proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(proposals, axis=2)",
                            "Call"
                        ],
                        [
                            "self.target_assign(-1, 1, ctr_proposals[:, :, :3], expand_proposals, valid_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_315": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "slice_316": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.slice(pred_score, [0, 0, 1], [-1, -1, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(pred_cls)",
                            "Call"
                        ],
                        [
                            "pred_score * pred_iou",
                            "BinOp"
                        ],
                        [
                            "pred_score * valid_mask",
                            "BinOp"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_318": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_326": {
                "variable": {
                    "value": "valid_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.points_pooler.get_valid_mask(base_xyz, proposals)",
                            "Call"
                        ],
                        [
                            "tf.cast(valid_mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_equal_205": {
                "x": {
                    "value": "base_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_3D_SCORE][-1]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.greater_equal(base_mask, self.pool_mask_thresh), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(base_mask, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.pool_mask_thresh",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_288": {
                "indices": {
                    "value": "assigned_gt_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_decoder.encode(base_xyz, assigned_gt_boxes_3d, anchors)",
                            "Call"
                        ],
                        [
                            "self.sampler.gather_list(assigned_mask, [anchors, assigned_pmask, assigned_nmask, assigned_gt_boxes_3d, assigned_gt_labels, assigned_gt_offset, assigned_gt_angle_cls, assigned_gt_angle_res, assigned_gt_velocity, assigned_gt_attribute])",
                            "Call"
                        ],
                        [
                            "self.labels[maps_dict.GT_ANGLE_CLS][index]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "cfg.MODEL.ANGLE_CLS_NUM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/modeling/head_builder.py": {
        "tensorflow": {
            "concat_85": {
                "variable": {
                    "value": "xyz_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xyz_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(xyz_input, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(xyz_input, [self.batch_size, -1, 3])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_90": {
                "variable": {
                    "value": "feature_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "feature_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(feature_input, axis=1)",
                            "Call"
                        ],
                        [
                            "self.format_input(feature_input)",
                            "Call"
                        ],
                        [
                            "self.conv_op(feature_input, channel, bn=self.bn, scope='conv1d_%d' % i, bn_decay=bn_decay, is_training=self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(feature_input, [self.batch_size, -1, feature_shape[-1]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_124": {
                "variable": {
                    "value": "format_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "feature",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[feature_shape[0], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_126": {
                "variable": {
                    "value": "format_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "feature",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, -1, feature_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_94": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_104": {
                "variable": {
                    "value": "xyz_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xyz_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(xyz_input, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(xyz_input, [self.batch_size, -1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_105": {
                "variable": {
                    "value": "feature_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "feature_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(feature_input, axis=1)",
                            "Call"
                        ],
                        [
                            "self.format_input(feature_input)",
                            "Call"
                        ],
                        [
                            "self.conv_op(feature_input, channel, bn=self.bn, scope='conv1d_%d' % i, bn_decay=bn_decay, is_training=self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(feature_input, [self.batch_size, -1, feature_shape[-1]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, -1, feature_shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/modeling/single_stage_detector.py": {
        "tensorflow": {
            "slice_116": {
                "variable": {
                    "value": "l0_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "point_cloud",
                    "type": "variable",
                    "possible_values": [
                        [
                            "point_cloud",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_117": {
                "variable": {
                    "value": "l0_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "point_cloud",
                    "type": "variable",
                    "possible_values": [
                        [
                            "point_cloud",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_174": {
                "variable": {
                    "value": "corner_loss_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(assigned_gt_angle_cls, depth=cfg.MODEL.ANGLE_CLS_NUM, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_209": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "slice_210": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(pred_cls)",
                            "Call"
                        ],
                        [
                            "tf.slice(pred_score, [0, 0, 1], [-1, -1, -1])",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(pred_cls)",
                            "Call"
                        ],
                        [
                            "pred_score * pred_iou",
                            "BinOp"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_212": {
                "variable": {
                    "value": "pred_score",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output[maps_dict.PRED_CLS][index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_174": {
                "indices": {
                    "value": "assigned_gt_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder_decoder.encode(base_xyz, assigned_gt_boxes_3d, anchors)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "cfg.MODEL.ANGLE_CLS_NUM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/anchor_decoder.py": {
        "tensorflow": {
            "cast_10": {
                "variable": {
                    "value": "pred_cls_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(pred_cls, depth=bin_size, on_value=1, off_value=0, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_11": {
                "variable": {
                    "value": "pred_angle_res_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pred_cls_onehot * pred_res_norm",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_12": {
                "variable": {
                    "value": "f_pred_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_28": {
                "variable": {
                    "value": "(det_ctr, det_offset)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_30": {
                "variable": {
                    "value": "(a_l, a_h, a_w)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "batch_anchors_3d[:, :, 3:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "norm_31": {
                "variable": {
                    "value": "a_d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.stack([a_l, a_w], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_33": {
                "variable": {
                    "value": "(a_x, a_y, a_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "batch_anchors_3d[:, :, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_34": {
                "variable": {
                    "value": "(p_x, p_y, p_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "det_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(det_residual, num_or_size_splits=2, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(det_residual, num_or_size_splits=2, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_35": {
                "variable": {
                    "value": "(p_l, p_h, p_w)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "det_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(det_residual, num_or_size_splits=2, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(det_residual, num_or_size_splits=2, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.slice(det_residual, [0, 0, bin_num_class * 4], [-1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_45": {
                "variable": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_50": {
                "variable": {
                    "value": "pred_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_x, pred_y, pred_z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_51": {
                "variable": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack([pred_l, pred_h, pred_w], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "expand_dims_52": {
                "variable": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_54": {
                "variable": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_ctr, pred_offset, pred_angle]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_69": {
                "variable": {
                    "value": "(det_ctr, det_offset)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_74": {
                "variable": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(tf.stack([pred_l, pred_h, pred_w], axis=-1), 0.1)",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d[:, :, 3:6] + det_offset * batch_anchors_3d[:, :, 3:6]",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(pred_offset, 0.1)",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d[:, :, 3:6] + det_size_res",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(pred_offset, 0.1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "argmax_76": {
                "variable": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_80": {
                "variable": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_82": {
                "variable": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_ctr, pred_offset, pred_angle]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_97": {
                "variable": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_99": {
                "variable": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_106": {
                "variable": {
                    "value": "padding_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "padding_half_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "half_distance[:, :, 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "stack_107": {
                "variable": {
                    "value": "padding_translate",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[padding_zeros, padding_half_height, padding_zeros]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_109": {
                "variable": {
                    "value": "lhw",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "half_distance * 2.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_111": {
                "variable": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctr_xyz, lhw, pred_angle]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_127": {
                "variable": {
                    "value": "x_bin",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, bin_num_class * 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, bin_num_class]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_128": {
                "variable": {
                    "value": "x_res",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, bin_num_class * 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, bin_num_class]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_129": {
                "variable": {
                    "value": "z_bin",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, bin_num_class * 2]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, bin_num_class]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_130": {
                "variable": {
                    "value": "z_res",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, bin_num_class * 3]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, bin_num_class]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_131": {
                "variable": {
                    "value": "det_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "det_residual",
                    "type": "variable",
                    "possible_values": [
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ],
                        [
                            "det_residual",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, bin_num_class * 4]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_133": {
                "variable": {
                    "value": "(anchor_x, anchor_y, anchor_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "batch_anchors_3d[:, :, :3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_136": {
                "variable": {
                    "value": "x_bin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(det_residual, [0, 0, bin_num_class * 0], [-1, -1, bin_num_class])",
                            "Call"
                        ],
                        [
                            "tf.argmax(x_bin, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_142": {
                "variable": {
                    "value": "z_bin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z_bin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(det_residual, [0, 0, bin_num_class * 2], [-1, -1, bin_num_class])",
                            "Call"
                        ],
                        [
                            "tf.argmax(z_bin, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_151": {
                "variable": {
                    "value": "pred_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_x, pred_y, pred_z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_155": {
                "variable": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pred_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(tf.stack([pred_l, pred_h, pred_w], axis=-1), 0.1)",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d[:, :, 3:6] + det_offset * batch_anchors_3d[:, :, 3:6]",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(pred_offset, 0.1)",
                            "Call"
                        ],
                        [
                            "batch_anchors_3d[:, :, 3:6] + det_size_res",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(pred_offset, 0.1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "argmax_157": {
                "variable": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "det_angle_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(det_angle_cls, axis=-1)",
                            "Call"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ],
                        [
                            "det_angle_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "variable": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ],
                        [
                            "decode_class2angle(det_angle_cls, det_angle_res, bin_size=cfg.MODEL.ANGLE_CLS_NUM, bin_interval=2 * np.pi / cfg.MODEL.ANGLE_CLS_NUM)",
                            "Call"
                        ],
                        [
                            "anchor_angle + pred_angle",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(pred_angle, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_163": {
                "variable": {
                    "value": "pred_anchors_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pred_ctr, pred_offset, pred_angle]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_10": {
                "indices": {
                    "value": "pred_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_cls",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "bin_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bin_size",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_31": {
                "values": {
                    "value": "[a_l, a_w]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_40": {
                "x": {
                    "value": "p_l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(det_offset, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_41": {
                "x": {
                    "value": "p_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(det_offset, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_42": {
                "x": {
                    "value": "p_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(det_offset, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_51": {
                "values": {
                    "value": "[pred_l, pred_h, pred_w]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/anchor_encoder.py": {
        "tensorflow": {
            "mod_23": {
                "variable": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.mod(angle, 2 * np.pi)",
                            "Call"
                        ],
                        [
                            "tf.mod(angle, 2 * np.pi)",
                            "Call"
                        ],
                        [
                            "angle",
                            "Method Argument"
                        ],
                        [
                            "angle",
                            "Method Argument"
                        ]
                    ]
                },
                "x2": {
                    "value": "2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mod_26": {
                "variable": {
                    "value": "shifted_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "angle + angle_per_class / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "floor_27": {
                "variable": {
                    "value": "class_id_f",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "shifted_angle / angle_per_class",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_28": {
                "variable": {
                    "value": "class_id",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "class_id_f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.floor(shifted_angle / angle_per_class)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floor_43": {
                "variable": {
                    "value": "bin_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(assigned_res + half_bin_search_range) / bin_interval_range",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "minimum_44": {
                "variable": {
                    "value": "bin_cls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(0.0, bin_cls)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "float(bin_num_class - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unstack_69": {
                "variable": {
                    "value": "(gt_l, gt_h, gt_w)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "gt_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_offset",
                            "Method Argument"
                        ],
                        [
                            "gt_offset",
                            "Method Argument"
                        ],
                        [
                            "gt_offset",
                            "Method Argument"
                        ],
                        [
                            "gt_offset",
                            "Method Argument"
                        ],
                        [
                            "gt_offset",
                            "Method Argument"
                        ],
                        [
                            "gt_offset",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_70": {
                "variable": {
                    "value": "(anchor_l, anchor_h, anchor_w)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "anchor_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchor_offset",
                            "Method Argument"
                        ],
                        [
                            "anchor_offset",
                            "Method Argument"
                        ],
                        [
                            "anchor_offset",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "anchor_offset",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_72": {
                "variable": {
                    "value": "anchor_d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[anchor_l, anchor_w]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "norm_73": {
                "variable": {
                    "value": "anchor_d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchor_d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([anchor_l, anchor_w], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.norm(anchor_d, axis=-1)",
                            "Call"
                        ],
                        [
                            "np.concatenate([anchor_l, anchor_w], axis=-1)",
                            "Call"
                        ],
                        [
                            "np.linalg.norm(anchor_d, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_75": {
                "variable": {
                    "value": "(gt_x, gt_y, gt_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "gt_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_76": {
                "variable": {
                    "value": "(anchor_x, anchor_y, anchor_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "anchor_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_82": {
                "variable": {
                    "value": "encode_l",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_l / anchor_l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_83": {
                "variable": {
                    "value": "encode_h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_h / anchor_h",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_84": {
                "variable": {
                    "value": "encode_w",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gt_w / anchor_w",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_86": {
                "variable": {
                    "value": "encoded_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encode_x, encode_y, encode_z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_87": {
                "variable": {
                    "value": "encoded_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encode_l, encode_h, encode_w]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_168": {
                "variable": {
                    "value": "padding_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "padding_half_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_ctr_half[:, :, 1]",
                            "Subscript"
                        ],
                        [
                            "target_ctr_half[:, :, 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "stack_169": {
                "variable": {
                    "value": "padding_translate",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[padding_zeros, padding_half_height, padding_zeros]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_217": {
                "variable": {
                    "value": "(gt_x, gt_y, gt_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "gt_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ],
                        [
                            "gt_ctr",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_218": {
                "variable": {
                    "value": "(anchor_x, anchor_y, anchor_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "anchor_ctr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ],
                        [
                            "anchor_ctr",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_224": {
                "variable": {
                    "value": "y_res",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y_res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gt_y - anchor_y",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(y_res, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_227": {
                "variable": {
                    "value": "encoded_ctr",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x_bin, x_res, z_bin, z_res]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_228": {
                "variable": {
                    "value": "encoded_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[y_res, offset]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_44": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "bin_cls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.floor((assigned_res + half_bin_search_range) / bin_interval_range)",
                            "Call"
                        ],
                        [
                            "tf.minimum(tf.maximum(0.0, bin_cls), float(bin_num_class - 1))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "lib/utils/anchors_util.py": {
        "tensorflow": {
            "reshape_113": {
                "variable": {
                    "value": "anchors_corners",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors_corners",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.reshape(anchors_corners, [-1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(anchors_corners, [-1, 3])",
                            "Call"
                        ],
                        [
                            "anchors_corners",
                            "Method Argument"
                        ],
                        [
                            "anchors_corners",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_118": {
                "variable": {
                    "value": "pts_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pts_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kitti_util.project_to_image(anchors_corners, stereo_calib_p2)",
                            "Call"
                        ],
                        [
                            "np.reshape(pts_2d, [-1, 8, 2])",
                            "Call"
                        ],
                        [
                            "kitti_util.tf_project_to_image_tensor(anchors_corners, stereo_calib_p2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pts_2d, [-1, 8, 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 8, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_123": {
                "variable": {
                    "value": "i_axis_min_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(tf.reduce_min(pts_2d[:, :, 0], axis=1), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.split(anchors, 6, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_124": {
                "variable": {
                    "value": "j_axis_min_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(tf.reduce_min(pts_2d[:, :, 1], axis=1), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.split(anchors, 6, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_126": {
                "variable": {
                    "value": "i_axis_max_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(tf.reduce_max(pts_2d[:, :, 0], axis=1), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.split(anchors, 6, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_127": {
                "variable": {
                    "value": "j_axis_max_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(tf.reduce_max(pts_2d[:, :, 1], axis=1), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.split(anchors, 6, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_129": {
                "variable": {
                    "value": "box_corners",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[i_axis_min_points, j_axis_min_points, i_axis_max_points, j_axis_max_points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_150": {
                "variable": {
                    "value": "boxes_reordered",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[box_corners[:, 1], box_corners[:, 0], box_corners[:, 3], box_corners[:, 2]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_132": {
                "x": {
                    "value": "box_corners",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.stack([i_axis_min_points, j_axis_min_points, i_axis_max_points, j_axis_max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.stack([i_axis_min_points, j_axis_min_points, i_axis_max_points, j_axis_max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "box_corners",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_123": {
                "x": {
                    "value": "tf.reduce_min(pts_2d[:, :, 0], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_124": {
                "x": {
                    "value": "tf.reduce_min(pts_2d[:, :, 1], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_126": {
                "x": {
                    "value": "tf.reduce_max(pts_2d[:, :, 0], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_127": {
                "x": {
                    "value": "tf.reduce_max(pts_2d[:, :, 1], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_123": {
                "input_tensor": {
                    "value": "pts_2d[:, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_124": {
                "input_tensor": {
                    "value": "pts_2d[:, :, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_126": {
                "input_tensor": {
                    "value": "pts_2d[:, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_127": {
                "input_tensor": {
                    "value": "pts_2d[:, :, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/box_3d_utils.py": {
        "tensorflow": {
            "slice_93": {
                "variable": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sizes",
                            "Method Argument"
                        ],
                        [
                            "sizes",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_94": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sizes",
                            "Method Argument"
                        ],
                        [
                            "sizes",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_95": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sizes",
                            "Method Argument"
                        ],
                        [
                            "sizes",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_96": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.split(boxes_3d, 7, axis=-1)",
                            "Call"
                        ],
                        [
                            "sizes[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.slice(sizes, [0, 0], [-1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_98": {
                "variable": {
                    "value": "x_corners",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[l / 2, l / 2, -l / 2, -l / 2, l / 2, l / 2, -l / 2, -l / 2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_99": {
                "variable": {
                    "value": "y_corners",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z, z, z, z, -h, -h, -h, -h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_100": {
                "variable": {
                    "value": "z_corners",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[w / 2, -w / 2, -w / 2, w / 2, w / 2, -w / 2, -w / 2, w / 2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "corners",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(x_corners, 1), tf.expand_dims(y_corners, 1), tf.expand_dims(z_corners, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cos_103": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "headings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "headings",
                            "Method Argument"
                        ],
                        [
                            "headings",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sin_104": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "headings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "headings",
                            "Method Argument"
                        ],
                        [
                            "headings",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_105": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_106": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_107": {
                "variable": {
                    "value": "row1",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[c, zeros, s]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_108": {
                "variable": {
                    "value": "row2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[zeros, ones, zeros]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_109": {
                "variable": {
                    "value": "row3",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[-s, zeros, c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_110": {
                "variable": {
                    "value": "R",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(row1, 1), tf.expand_dims(row2, 1), tf.expand_dims(row3, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_112": {
                "variable": {
                    "value": "corners_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "R",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate([np.expand_dims(row1, 1), np.expand_dims(row2, 1), np.expand_dims(row3, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(row1, 1), tf.expand_dims(row2, 1), tf.expand_dims(row3, 1)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "corners",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate([np.expand_dims(x_corners, 1), np.expand_dims(y_corners, 1), np.expand_dims(z_corners, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(x_corners, 1), tf.expand_dims(y_corners, 1), tf.expand_dims(z_corners, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "get_box3d_corners_helper(boxes_3d_reshape[:, :3], boxes_3d_reshape[:, -1], boxes_3d_reshape[:, 3:-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(corners, new_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_114": {
                "variable": {
                    "value": "corners_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "corners_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.matmul(R, corners)",
                            "Call"
                        ],
                        [
                            "corners_3d + tf.tile(tf.expand_dims(centers, 2), [1, 1, 8])",
                            "BinOp"
                        ],
                        [
                            "np.transpose(corners_3d, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(R, corners)",
                            "Call"
                        ],
                        [
                            "tf.transpose(corners_3d, perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_125": {
                "variable": {
                    "value": "boxes_3d_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "boxes_3d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_126": {
                "variable": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[boxes_3d_shape[:-1], [8, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_127": {
                "variable": {
                    "value": "boxes_3d_reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "boxes_3d",
                            "Method Argument"
                        ],
                        [
                            "boxes_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_129": {
                "variable": {
                    "value": "corners",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "corners",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate([np.expand_dims(x_corners, 1), np.expand_dims(y_corners, 1), np.expand_dims(z_corners, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(x_corners, 1), tf.expand_dims(y_corners, 1), tf.expand_dims(z_corners, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "get_box3d_corners_helper(boxes_3d_reshape[:, :3], boxes_3d_reshape[:, -1], boxes_3d_reshape[:, 3:-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(corners, new_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([boxes_3d_shape[:-1], [8, 3]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_113": {
                "input": {
                    "value": "tf.expand_dims(centers, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, 8]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_92": {
                "input": {
                    "value": "centers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "centers",
                            "Method Argument"
                        ],
                        [
                            "centers",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_113": {
                "input": {
                    "value": "centers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "centers",
                            "Method Argument"
                        ],
                        [
                            "centers",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_101": {
                "input": {
                    "value": "z_corners",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.stack([w / 2, -w / 2, -w / 2, w / 2, w / 2, -w / 2, -w / 2, w / 2], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([w / 2, -w / 2, -w / 2, w / 2, w / 2, -w / 2, -w / 2, w / 2], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_110": {
                "input": {
                    "value": "row3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.stack([-s, zeros, c], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([-s, zeros, c], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/demo_utils.py": {
        "tensorflow": {}
    },
    "lib/utils/generate_anchors.py": {
        "tensorflow": {
            "unstack_47": {
                "variable": {
                    "value": "(x, y, z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points",
                            "Method Argument"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_48": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(x, [bs, points_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_49": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(y, [bs, points_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_50": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(z, [bs, points_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_54": {
                "variable": {
                    "value": "(l, h, w)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "anchor_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(anchor_sizes)",
                            "Call"
                        ],
                        [
                            "np.array(anchor_sizes).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "anchor_sizes",
                            "Method Argument"
                        ],
                        [
                            "anchor_sizes",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_55": {
                "variable": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(l, [1, 1, anchors_num, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_56": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(h, [1, 1, anchors_num, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(w, [1, 1, anchors_num, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_59": {
                "variable": {
                    "value": "ry",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(anchor_sizes, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(l, [1, 1, anchors_num, 1]), [bs, points_num, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_63": {
                "variable": {
                    "value": "all_anchor_boxes_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, y, z, l, h, w, ry]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_64": {
                "variable": {
                    "value": "all_anchor_boxes_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_anchor_boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate([ctr, offset, ry], axis=-1)",
                            "Call"
                        ],
                        [
                            "np.reshape(all_anchor_boxes_3d, [bs, points_num, anchors_num, 7])",
                            "Call"
                        ],
                        [
                            "tf.concat([x, y, z, l, h, w, ry], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_anchor_boxes_3d, [bs, points_num, anchors_num, 7])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, anchors_num, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_48": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(points, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(x, [bs, points_num, 1, 1]), [1, 1, anchors_num, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_49": {
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(points, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(y, [bs, points_num, 1, 1]), [1, 1, anchors_num, 1])",
                            "Call"
                        ],
                        [
                            "y + h / 2.0",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_50": {
                "tensor": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(points, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(z, [bs, points_num, 1, 1]), [1, 1, anchors_num, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_55": {
                "tensor": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(anchor_sizes, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(l, [1, 1, anchors_num, 1]), [bs, points_num, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(anchor_sizes, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(h, [1, 1, anchors_num, 1]), [bs, points_num, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_57": {
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(anchor_sizes, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(w, [1, 1, anchors_num, 1]), [bs, points_num, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, anchors_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/group_normalization.py": {
        "tensorflow": {
            "convert_to_tensor_109": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(inputs, inputs_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(inputs, inputs_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "inputs_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "axes_before_channels + [groups, channels // groups] + axes_after_channels",
                            "BinOp"
                        ]
                    ]
                }
            },
            "rsqrt_220": {
                "variable": {
                    "value": "gain",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "variance + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_230": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs * gain + offset",
                            "BinOp"
                        ],
                        [
                            "array_ops.reshape(outputs, original_shape)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape",
                            "Attribute"
                        ]
                    ]
                }
            },
            "variable_scope_171": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "GroupNorm",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_192": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "variables.model_variable('beta', shape=params_shape, dtype=dtype, initializer=beta_initializer, collections=beta_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(beta, params_shape_broadcast)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "params_shape_broadcast",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * len(axes_before_channels) + [groups, channels // groups] + [1] * len(axes_after_channels)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_205": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "variables.model_variable('gamma', shape=params_shape, dtype=dtype, initializer=gamma_initializer, collections=gamma_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(gamma, params_shape_broadcast)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "params_shape_broadcast",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * len(axes_before_channels) + [groups, channels // groups] + [1] * len(axes_after_channels)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sufficient_statistics_210": {
                "variable": {
                    "value": "(counts, means_ss, variance_ss, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(inputs, inputs_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "moments_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[channels_axis + 1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "normalize_moments_212": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "counts": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nn.sufficient_statistics(inputs, moments_axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "mean_ss": {
                    "value": "means_ss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nn.sufficient_statistics(inputs, moments_axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "variance_ss": {
                    "value": "variance_ss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nn.sufficient_statistics(inputs, moments_axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "shift": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "moments_215": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ops.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "array_ops.reshape(inputs, inputs_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "moments_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[channels_axis + 1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_initializer_185": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_198": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/head_util.py": {
        "tensorflow": {
            "reshape_38": {
                "variable": {
                    "value": "pred_reg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pred_reg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_reg_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_reg, pred_reg_base_num * (pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2), activation_fn=None, scope='pred_reg')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_reg, [bs, points_num, pred_reg_base_num, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, pred_reg_base_num, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_43": {
                "variable": {
                    "value": "pred_attr",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pred_attr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_attr_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_attr, pred_reg_base_num * 8, activation_fn=None, scope='pred_attr')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_attr, [bs, points_num, pred_reg_base_num, 8])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, pred_reg_base_num, 8]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_47": {
                "variable": {
                    "value": "pred_velo",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pred_velo",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_velo_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_velo, pred_reg_base_num * 2, activation_fn=None, scope='pred_velo')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_velo, [bs, points_num, pred_reg_base_num, 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[bs, points_num, pred_reg_base_num, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_53": {
                "input_": {
                    "value": "pred_reg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_reg_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_reg, pred_reg_base_num * (pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2), activation_fn=None, scope='pred_reg')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_reg, [bs, points_num, pred_reg_base_num, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, pred_reg_channel_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_54": {
                "input_": {
                    "value": "pred_reg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_reg_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_reg, pred_reg_base_num * (pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2), activation_fn=None, scope='pred_reg')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_reg, [bs, points_num, pred_reg_base_num, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, pred_reg_channel_num]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, cfg.MODEL.ANGLE_CLS_NUM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_56": {
                "input_": {
                    "value": "pred_reg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv_op(feature_input, 128, bn=bn, is_training=is_training, scope='pred_reg_base', bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "conv_op(pred_reg, pred_reg_base_num * (pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2), activation_fn=None, scope='pred_reg')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pred_reg, [bs, points_num, pred_reg_base_num, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM * 2])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, pred_reg_channel_num + cfg.MODEL.ANGLE_CLS_NUM]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/kitti_util.py": {
        "tensorflow": {
            "concat_364": {
                "variable": {
                    "value": "pts_3d_extend",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pts_3d, tf.ones([n, 1], dtype=pts_3d.dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "matmul_365": {
                "variable": {
                    "value": "pts_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "pts_3d_extend",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.hstack((pts_3d, np.ones((n, 1))))",
                            "Call"
                        ],
                        [
                            "tf.concat([pts_3d, tf.ones([n, 1], dtype=pts_3d.dtype)], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(P)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_368": {
                "variable": {
                    "value": "pts_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pts_2d_x, pts_2d_y]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_363": {
                "input": {
                    "value": "pts_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pts_3d",
                            "Method Argument"
                        ],
                        [
                            "pts_3d",
                            "Method Argument"
                        ],
                        [
                            "pts_3d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_365": {
                "a": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P",
                            "Method Argument"
                        ],
                        [
                            "P",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_364": {
                "shape": {
                    "value": "[n, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "pts_3d.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/layers_util.py": {
        "tensorflow": {
            "reshape_21": {
                "variable": {
                    "value": "min_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "cfg.MODEL.MAX_TRANSLATE_RANGE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_22": {
                "variable": {
                    "value": "limited_ctr_offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(ctr_offsets, min_offset)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "-min_offset",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_42": {
                "variable": {
                    "value": "grouped_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[xyz, points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_54": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grouped_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([xyz, points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv1d(grouped_points, num_out_channel, 1, padding='VALID', bn=bn, is_training=is_training, scope='conv%d' % j, bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "group_point(points, idx)",
                            "Call"
                        ],
                        [
                            "tf.concat([grouped_points, grouped_xyz], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(grouped_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d_%d' % (i, j), bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_111": {
                "variable": {
                    "value": "fps_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_fps_idx_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_207": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_208": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1.0 / dist",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_209": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_217": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=2, values=[interpolated_points, points1])",
                            "Call"
                        ],
                        [
                            "interpolated_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_%d' % i, bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_223": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=2, values=[interpolated_points, points1])",
                            "Call"
                        ],
                        [
                            "interpolated_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_%d' % i, bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_16": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_41": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_81": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "slice_85": {
                "variable": {
                    "value": "tmp_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xyz + limited_ctr_offsets",
                            "BinOp"
                        ],
                        [
                            "xyz",
                            "Method Argument"
                        ],
                        [
                            "xyz",
                            "Method Argument"
                        ],
                        [
                            "xyz",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, last_fps_end_index, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, fps_sample_range, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_86": {
                "variable": {
                    "value": "tmp_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_util.conv1d(points, channel, 1, padding='VALID', stride=1, bn=bn, scope='vote_layer_%d' % i, bn_decay=bn_decay, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, last_fps_end_index, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, fps_sample_range, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "fps_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fps_idx, former_fps_idx]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "top_k_130": {
                "variable": {
                    "value": "(_, relation_idx)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "relation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.calc_square_dist(new_points, points)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "relation.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_157": {
                "variable": {
                    "value": "pts_cnt_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(pts_cnt, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_158": {
                "variable": {
                    "value": "pts_cnt_fmask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pts_cnt_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.greater(pts_cnt, 0), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_165": {
                "variable": {
                    "value": "grouped_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[grouped_points, grouped_xyz]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_178": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grouped_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([xyz, points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv1d(grouped_points, num_out_channel, 1, padding='VALID', bn=bn, is_training=is_training, scope='conv%d' % j, bn_decay=bn_decay)",
                            "Call"
                        ],
                        [
                            "group_point(points, idx)",
                            "Call"
                        ],
                        [
                            "tf.concat([grouped_points, grouped_xyz], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(grouped_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d_%d' % (i, j), bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_183": {
                "variable": {
                    "value": "new_points_concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "new_points_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_205": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_214": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[interpolated_points, points1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_22": {
                "x": {
                    "value": "ctr_offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_util.conv1d(points, 3, 1, padding='VALID', stride=1, bn=False, activation_fn=None, scope='vote_offsets')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "min_offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(cfg.MODEL.MAX_TRANSLATE_RANGE, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_92": {
                "variable": {
                    "value": "fps_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.range(npoint), [1, npoint])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[bs, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_162": {
                "input": {
                    "value": "new_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gather_point(vote_ctr, fps_idx)",
                            "Call"
                        ],
                        [
                            "gather_point(xyz, fps_idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_180": {
                "input": {
                    "value": "pts_cnt_fmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(pts_cnt_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_94": {
                "variable": {
                    "value": "features_for_fps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tmp_xyz, tmp_points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_98": {
                "variable": {
                    "value": "fps_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fps_idx_1, fps_idx_2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_157": {
                "x": {
                    "value": "pts_cnt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point_withidx(radius, nsample, xyz, new_xyz, relation_idx)",
                            "Call"
                        ],
                        [
                            "query_ball_point(radius, nsample, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "pts_cnt_list[i]",
                            "Subscript"
                        ],
                        [
                            "query_ball_point_dilated(min_radius, radius, nsample, xyz, new_xyz)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_159": {
                "input": {
                    "value": "pts_cnt_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.greater(pts_cnt, 0), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_92": {
                "tensor": {
                    "value": "tf.range(npoint)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, npoint]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_100": {
                "variable": {
                    "value": "fps_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.range(npoint), [1, npoint])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[bs, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_102": {
                "variable": {
                    "value": "features_for_fps",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tmp_xyz, tmp_points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_100": {
                "tensor": {
                    "value": "tf.range(npoint)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, npoint]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/model_util.py": {
        "tensorflow": {
            "sigmoid_cross_entropy_with_logits_75": {
                "variable": {
                    "value": "per_entry_cross_ent",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "target_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "prediction_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_77": {
                "variable": {
                    "value": "prediction_probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prediction_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "non_max_suppression_102": {
                "variable": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": []
                },
                "boxes": {
                    "value": "pred_box",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_box",
                            "Method Argument"
                        ]
                    ]
                },
                "scores": {
                    "value": "image_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loc_loss",
                            "variable"
                        ],
                        [
                            "cls_loss",
                            "variable"
                        ],
                        [
                            "cls_loss_weights * cls_loss + loc_loss_weights * loc_loss",
                            "BinOp"
                        ]
                    ]
                },
                "max_output_size": {
                    "value": "num_hard_sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "128",
                            "Method Argument"
                        ]
                    ]
                },
                "iou_threshold": {
                    "value": "iou_thresh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.7",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_107": {
                "variable": {
                    "value": "hard_sample_fmask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indices_to_dense_vector(nms_index, tf.shape(cls_loss)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_109": {
                "variable": {
                    "value": "debug_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hard_sample_fmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(indices_to_dense_vector(nms_index, tf.shape(cls_loss)[0]), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_110": {
                "variable": {
                    "value": "cnt",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hard_sample_fmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(indices_to_dense_vector(nms_index, tf.shape(cls_loss)[0]), tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_115": {
                "variable": {
                    "value": "positives_indicator",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "pmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pmask",
                            "Method Argument"
                        ],
                        [
                            "pmask",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(pred_box, image_loss, num_hard_sample, iou_threshold=iou_thresh)",
                            "Call"
                        ],
                        [
                            "subsample_to_desire_ratio(nms_index, pmask, nmask, max_negatives_per_positive, min_negatives_per_image)",
                            "Call"
                        ],
                        [
                            "nms_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_116": {
                "variable": {
                    "value": "negatives_indicator",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "nmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nmask",
                            "Method Argument"
                        ],
                        [
                            "nmask",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(pred_box, image_loss, num_hard_sample, iou_threshold=iou_thresh)",
                            "Call"
                        ],
                        [
                            "subsample_to_desire_ratio(nms_index, pmask, nmask, max_negatives_per_positive, min_negatives_per_image)",
                            "Call"
                        ],
                        [
                            "nms_index",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_118": {
                "variable": {
                    "value": "positive_num",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(positives_indicator)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "maximum_119": {
                "variable": {
                    "value": "max_negatives",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "min_negatives_per_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "16",
                            "Method Argument"
                        ],
                        [
                            "min_negatives_per_image",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_int32(max_negatives_per_positive * tf.to_float(positive_num))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_equal_123": {
                "variable": {
                    "value": "topk_negatives_indicator",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cumsum(tf.to_int32(negatives_indicator))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "max_negatives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(min_negatives_per_image, tf.to_int32(max_negatives_per_positive * tf.to_float(positive_num)))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_125": {
                "variable": {
                    "value": "subsampled_selection_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.logical_or(positives_indicator, topk_negatives_indicator)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_133": {
                "variable": {
                    "value": "abs_error",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "error",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "minimum_134": {
                "variable": {
                    "value": "quadratic",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "abs_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.abs(error)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "delta",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_150": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_151": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(b, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(b, axis=1)",
                            "Call"
                        ],
                        [
                            "b",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_152": {
                "variable": {
                    "value": "a_square",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(a)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_153": {
                "variable": {
                    "value": "b_square",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(b)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_154": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_155": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(b, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(b, axis=1)",
                            "Call"
                        ],
                        [
                            "b",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_default_graph_168": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_183": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "unstack_247": {
                "variable": {
                    "value": "(cx, by, cz, l, h, w, ry)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "boxes_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "boxes_3d",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_252": {
                "variable": {
                    "value": "ctr_boxes_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cx, cy, cz, l, h, w, ry]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_70": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(weights, 2)",
                            "Call"
                        ],
                        [
                            "weights * tf.reshape(ops.indices_to_dense_vector(class_indices, tf.shape(prediction_tensor)[2]), [1, 1, -1])",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_82": {
                "variable": {
                    "value": "modulating_factor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 - p_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "_gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_129": {
                "tensor": {
                    "value": "tf.gather(nms_index, subsampled_selection_indices)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_210": {
                "logits": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "variable"
                        ],
                        [
                            "gumbel_softmax_sample(logits, temp)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(y_hard - y) + y",
                            "BinOp"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_238": {
                "variable": {
                    "value": "merged_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "cur_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_dict[key][start_idx:]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_71": {
                "tensor": {
                    "value": "ops.indices_to_dense_vector(class_indices, tf.shape(prediction_tensor)[2])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_118": {
                "x": {
                    "value": "positives_indicator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(pmask, nms_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_120": {
                "x": {
                    "value": "max_negatives_per_positive * tf.to_float(positive_num)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cumsum_124": {
                "x": {
                    "value": "tf.to_int32(negatives_indicator)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_or_126": {
                "x": {
                    "value": "positives_indicator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(pmask, nms_index)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "topk_negatives_indicator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cumsum(tf.to_int32(negatives_indicator)), max_negatives)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_127": {
                "input": {
                    "value": "subsampled_selection_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.logical_or(positives_indicator, topk_negatives_indicator))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_129": {
                "params": {
                    "value": "nms_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.non_max_suppression(pred_box, image_loss, num_hard_sample, iou_threshold=iou_thresh)",
                            "Call"
                        ],
                        [
                            "subsample_to_desire_ratio(nms_index, pmask, nmask, max_negatives_per_positive, min_negatives_per_image)",
                            "Call"
                        ],
                        [
                            "nms_index",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "subsampled_selection_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.logical_or(positives_indicator, topk_negatives_indicator))",
                            "Call"
                        ]
                    ]
                }
            },
            "square_152": {
                "x": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_153": {
                "x": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(b, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(b, axis=1)",
                            "Call"
                        ],
                        [
                            "b",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_170": {
                "name": {
                    "value": "SigmRound",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_185": {
                "name": {
                    "value": "STE_Grad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_197": {
                "x": {
                    "value": "u + eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_220": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_224": {
                "variable": {
                    "value": "y_hard",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(y, tf.reduce_max(y, -1, keep_dims=True))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "y.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_124": {
                "x": {
                    "value": "negatives_indicator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(nmask, nms_index)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_157": {
                "x": {
                    "value": "a_square + b_square - 2 * tf.matmul(a, tf.transpose(b, [0, 2, 1]))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_157": {
                "x": {
                    "value": "tf.shape(a)[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_107": {
                "input": {
                    "value": "cls_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cls_loss",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_121": {
                "x": {
                    "value": "positive_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.to_int32(positives_indicator))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_159": {
                "a": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(b, [0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_224": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "variable"
                        ],
                        [
                            "gumbel_softmax_sample(logits, temp)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(y_hard - y) + y",
                            "BinOp"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_max(y, -1, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stop_gradient_225": {
                "input": {
                    "value": "y_hard - y",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_73": {
                "input": {
                    "value": "prediction_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction_tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_157": {
                "input": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_159": {
                "a": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(b, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(b, axis=1)",
                            "Call"
                        ],
                        [
                            "b",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sign_174": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sign_189": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_224": {
                "input_tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "variable"
                        ],
                        [
                            "gumbel_softmax_sample(logits, temp)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(y_hard - y) + y",
                            "BinOp"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_157": {
                "a": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(a, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(a, axis=2)",
                            "Call"
                        ],
                        [
                            "a",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(b, [0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_157": {
                "a": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(b, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(b, axis=1)",
                            "Call"
                        ],
                        [
                            "b",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/points_filter.py": {
        "tensorflow": {}
    },
    "lib/utils/pool_utils.py": {
        "tensorflow": {
            "variable_scope_6": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "lib/utils/rotation_util.py": {
        "tensorflow": {
            "shape_42": {
                "input": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib_name.transpose(points, transpose_vector)",
                            "Call"
                        ],
                        [
                            "lib_name.transpose(points, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ],
                        [
                            "points",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "lib/utils/sync_bn.py": {
        "tensorflow": {
            "get_variable_32": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "trainable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "collections": {
                    "value": "variables_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_36": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "trainable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "collections": {
                    "value": "variables_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_40": {
                "variable": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_mean",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "collections": {
                    "value": "variables_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_44": {
                "variable": {
                    "value": "moving_var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_variance",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "collections": {
                    "value": "variables_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_27": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'BatchNorm'",
                            "str"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "BatchNorm",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_68": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, red_axises)",
                            "Call"
                        ],
                        [
                            "batch_mean",
                            "variable"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, red_axises)",
                            "Call"
                        ],
                        [
                            "batch_mean_square - tf.square(batch_mean)",
                            "BinOp"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='beta', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=trainable, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='gamma', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(1.0), trainable=trainable, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_88": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='moving_mean', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=False, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "moving_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='moving_variance', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(1.0), trainable=False, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='beta', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=trainable, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='gamma', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(1.0), trainable=trainable, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "moments_51": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "red_axises",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_54": {
                "variable": {
                    "value": "batch_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "red_axises",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_55": {
                "variable": {
                    "value": "batch_mean_square",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "red_axises",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "assign_71": {
                "variable": {
                    "value": "update_moving_mean_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='moving_mean', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=False, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "moving_mean * decay + mean * (1 - decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_72": {
                "variable": {
                    "value": "update_moving_var_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='moving_variance', shape=[num_outputs], dtype=tf.float32, initializer=tf.constant_initializer(1.0), trainable=False, collections=variables_collections)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "moving_var * decay + var * (1 - decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_84": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.batch_normalization(inputs, moving_mean, moving_var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inputs, mean, var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_33": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_37": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_41": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_45": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "identity_82": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.batch_normalization(inputs, moving_mean, moving_var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inputs, mean, var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "square_55": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_67": {
                "x": {
                    "value": "batch_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs, axis=red_axises)",
                            "Call"
                        ],
                        [
                            "gen_nccl_ops.nccl_all_reduce(input=batch_mean, reduction='sum', num_devices=num_dev, shared_name=shared_name + '_NCCL_mean') * (1.0 / num_dev)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "identity_78": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.batch_normalization(inputs, moving_mean, moving_var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "tf.nn.batch_normalization(inputs, mean, var, beta, gamma, epsilon)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_80": {
                "name": {
                    "value": "updates_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphKeys.UPDATE_OPS",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "update_moving_mean_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign(moving_mean, moving_mean * decay + mean * (1 - decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_81": {
                "name": {
                    "value": "updates_collections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphKeys.UPDATE_OPS",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "update_moving_var_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign(moving_var, moving_var * decay + var * (1 - decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_77": {
                "control_inputs": {
                    "value": "[update_moving_mean_op, update_moving_var_op]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/adabound/adabound.py": {
        "tensorflow": {
            "convert_to_tensor_72": {
                "variable": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_73": {
                "variable": {
                    "value": "self._base_lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_74": {
                "variable": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._beta1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_75": {
                "variable": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._beta2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_76": {
                "variable": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._epsilon",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_77": {
                "variable": {
                    "value": "self._gamma_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._gamma",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_80": {
                "variable": {
                    "value": "beta1_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_81": {
                "variable": {
                    "value": "beta2_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_82": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_83": {
                "variable": {
                    "value": "base_lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._base_lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_84": {
                "variable": {
                    "value": "beta1_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_85": {
                "variable": {
                    "value": "beta2_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_86": {
                "variable": {
                    "value": "epsilon_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_87": {
                "variable": {
                    "value": "gamma_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._gamma_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_97": {
                "variable": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'm').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "beta1_t * m + m_scaled_g_values",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_102": {
                "variable": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "beta2_t * v + v_scaled_g_values",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_sub_118": {
                "variable": {
                    "value": "var_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var.handle",
                            "Attribute"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "bounded_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_123": {
                "variable": {
                    "value": "beta1_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_124": {
                "variable": {
                    "value": "beta2_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_125": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_126": {
                "variable": {
                    "value": "base_lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._base_lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_127": {
                "variable": {
                    "value": "beta1_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_128": {
                "variable": {
                    "value": "beta2_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_129": {
                "variable": {
                    "value": "epsilon_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "grad.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_130": {
                "variable": {
                    "value": "gamma_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._gamma_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_140": {
                "variable": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'm').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "beta1_t * m + m_scaled_g_values",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_145": {
                "variable": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "beta2_t * v + v_scaled_g_values",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_sub_160": {
                "variable": {
                    "value": "var_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var.handle",
                            "Attribute"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "bounded_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_165": {
                "variable": {
                    "value": "beta1_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_166": {
                "variable": {
                    "value": "beta2_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_167": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_168": {
                "variable": {
                    "value": "base_lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._base_lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_169": {
                "variable": {
                    "value": "beta1_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_170": {
                "variable": {
                    "value": "beta2_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_171": {
                "variable": {
                    "value": "epsilon_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_172": {
                "variable": {
                    "value": "gamma_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._gamma_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_182": {
                "variable": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'm').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "m * beta1_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_189": {
                "variable": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "v * beta2_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_sub_206": {
                "variable": {
                    "value": "var_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var.handle",
                            "Attribute"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "bounded_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ],
                        [
                            "m_t * clip_by_value(step_size_bound, lower_bound, upper_bound)",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_107": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "math_ops.maximum(v_t, vhat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_108": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_110": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_111": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_119": {
                "*inputs": {
                    "value": "*[var_update, m_t, v_t, vhat_t]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "assign_150": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "math_ops.maximum(v_t, vhat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_151": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_153": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_154": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_162": {
                "*inputs": {
                    "value": "*[var_update, m_t, v_t, vhat_t]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "assign_196": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "math_ops.maximum(v_t, vhat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_197": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, math_ops.maximum(v_t, vhat))",
                            "Call"
                        ],
                        [
                            "state_ops.assign(vhat, vhat)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_199": {
                "variable": {
                    "value": "vhat_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_200": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_208": {
                "*inputs": {
                    "value": "*[var_update, m_t, v_t, vhat_t]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_235": {
                "*inputs": {
                    "value": "*update_ops + [update_beta1, update_beta2]",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "name_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name_scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_by_value_116": {
                "t": {
                    "value": "step_size_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "lower_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "upper_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_158": {
                "t": {
                    "value": "step_size_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "lower_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "upper_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "control_dependencies_183": {
                "control_inputs": {
                    "value": "[m_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_190": {
                "control_inputs": {
                    "value": "[v_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_204": {
                "t": {
                    "value": "step_size_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ],
                        [
                            "step_size / (v_sqrt + epsilon_t)",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "lower_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 - 1.0 / (gamma_t + 1.0))",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "upper_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ],
                        [
                            "final_lr * (1.0 + 1.0 / gamma_t)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "control_dependencies_217": {
                "control_inputs": {
                    "value": "[resource_variable_ops.resource_scatter_add(x.handle, i, v)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_227": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "update_ops",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "colocate_with_61": {
                "op": {
                    "value": "first_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(var_list, key=lambda x: x.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_89": {
                "x": {
                    "value": "1 - beta2_power",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_107": {
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_132": {
                "x": {
                    "value": "1 - beta2_power",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_150": {
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_174": {
                "x": {
                    "value": "1 - beta2_power",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_196": {
                "x": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, beta2_t * v + v_scaled_g_values, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'vhat').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'vhat')",
                            "Call"
                        ]
                    ]
                }
            },
            "scatter_add_213": {
                "ref": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i",
                            "Method Argument"
                        ]
                    ]
                },
                "updates": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v').handle",
                            "Attribute"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "colocate_with_228": {
                "op": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/evaluation/test_calc_3d_iou.py": {
        "tensorflow": {
            "Session_12": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_24": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/evaluation/test_evaluate.py": {
        "tensorflow": {
            "Session_10": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/evaluation/tf_evaluate.py": {
        "tensorflow": {
            "load_op_library_7": {
                "variable": {
                    "value": "evaluate_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_evaluate_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_53": {
                "variable": {
                    "value": "iou_bev",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "iou_bev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "evaluate_module.calc_iou(detections, groundtruths)",
                            "Call"
                        ],
                        [
                            "evaluate_module.calc_matching_iou(detections, groundtruths)",
                            "Call"
                        ],
                        [
                            "calc_iou_match(tf.reshape(detections, [-1, 7]), tf.reshape(groundtruths, [-1, 7]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(iou_bev, original_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(detections)[:-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_54": {
                "variable": {
                    "value": "iou_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "iou_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "evaluate_module.calc_iou(detections, groundtruths)",
                            "Call"
                        ],
                        [
                            "evaluate_module.calc_matching_iou(detections, groundtruths)",
                            "Call"
                        ],
                        [
                            "calc_iou_match(tf.reshape(detections, [-1, 7]), tf.reshape(groundtruths, [-1, 7]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(iou_3d, original_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(detections)[:-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_50": {
                "input": {
                    "value": "detections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_51": {
                "tensor": {
                    "value": "detections",
                    "type": "variable",
                    "possible_values": [
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ],
                        [
                            "detections",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_52": {
                "tensor": {
                    "value": "groundtruths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "groundtruths",
                            "Method Argument"
                        ],
                        [
                            "groundtruths",
                            "Method Argument"
                        ],
                        [
                            "groundtruths",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 7]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/evaluation/tf_evaluate_op_test.py": {
        "tensorflow": {
            "main_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_8": {
                "variable": {
                    "value": "dets",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[2, 645.6, 167.95, 680.98, 198.93, -1.65, 4.59, 1.32, 45.84, 1.86, 0.6, 2.02, -1.55, 0.8], [0, 387.63, 181.54, 423.81, 203.12, 1.85, -16.53, 2.39, 58.49, 1.67, 1.87, 3.69, 1.57, 0.99], [1, 712.4, 143.0, 810.73, 307.92, -0.2, 1.84, 1.47, 8.41, 1.89, 0.48, 1.2, 0.01, 0.7], [0, 614.24, 181.78, 727.31, 284.77, 1.55, 1.0, 1.75, 13.22, 1.57, 1.73, 4.15, 1.62, 0.99]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_14": {
                "variable": {
                    "value": "names",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "['/root/kitti_native_evaluation/gtfiles/000001.txt', '/root/kitti_native_evaluation/gtfiles/000000.txt', '/root/kitti_native_evaluation/gtfiles/000003.txt']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_15": {
                "variable": {
                    "value": "numlist",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[2, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/evaluation/visu_interpolation.py": {
        "tensorflow": {}
    },
    "lib/utils/tf_ops/grouping/test/test_op.py": {
        "tensorflow": {
            "reshape_44": {
                "variable": {
                    "value": "anchors",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate_3d_anchors_by_point_tf(tf.constant(points, dtype=tf.float32), [[3.8, 1.6, 1.5]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(anchors, [batch_size, -1, 7])",
                            "Call"
                        ],
                        [
                            "sess.run([iou_points, anchors])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_46": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_43": {
                "value": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "points[:, :, :3]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/grouping/tf_grouping.py": {
        "tensorflow": {
            "load_op_library_12": {
                "variable": {
                    "value": "grouping_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_grouping_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_123": {
                "op_type": {
                    "value": "GroupPoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_147": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(xyz1, (b, 1, n, c))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, m, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_148": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(xyz2, (b, m, 1, c))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_149": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(xyz1 - xyz2) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "slice_152": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "outi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "select_top_k(k, dist)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_153": {
                "variable": {
                    "value": "val",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "select_top_k(k, dist)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_140": {
                "input": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz1, (b, 1, n, c)), [1, m, 1, 1])",
                            "Call"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_141": {
                "input": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz1, (b, 1, n, c)), [1, m, 1, 1])",
                            "Call"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_142": {
                "input": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz1, (b, 1, n, c)), [1, m, 1, 1])",
                            "Call"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_143": {
                "input": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz2, (b, m, 1, c)), [1, 1, n, 1])",
                            "Call"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_147": {
                "tensor": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz1, (b, 1, n, c)), [1, m, 1, 1])",
                            "Call"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(b, 1, n, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_148": {
                "tensor": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(xyz2, (b, m, 1, c)), [1, 1, n, 1])",
                            "Call"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(b, m, 1, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/grouping/tf_grouping_op_test.py": {
        "tensorflow": {}
    },
    "lib/utils/tf_ops/interpolation/tf_interpolate.py": {
        "tensorflow": {
            "load_op_library_7": {
                "variable": {
                    "value": "interpolate_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_interpolate_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_31": {
                "op_type": {
                    "value": "ThreeInterpolate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RegisterGradient_49": {
                "op_type": {
                    "value": "KInterpolate",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/interpolation/tf_interpolate_op_test.py": {
        "tensorflow": {}
    },
    "lib/utils/tf_ops/interpolation/visu_interpolation.py": {
        "tensorflow": {}
    },
    "lib/utils/tf_ops/nms/tf_points_nms.py": {
        "tensorflow": {
            "load_op_library_7": {
                "variable": {
                    "value": "points_nms_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_nms_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_41": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1, 0, 0, 0, 1, 1, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_42": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1, 1, 1, 1, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_43": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1, 0, 1, 1, 0, 1, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_44": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0, 1, 0, 0, 0, 0, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_57": {
                "variable": {
                    "value": "points_sample_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[60000, 10000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_59": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/points_pooling/points_pooling.py": {
        "tensorflow": {
            "load_op_library_8": {
                "variable": {
                    "value": "points_pooling_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_points_pooling_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_22": {
                "op_type": {
                    "value": "PointsPooling",
                    "type": "str",
                    "possible_values": []
                }
            },
            "unstack_39": {
                "variable": {
                    "value": "proposal_unstack",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "proposals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "proposals",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_62": {
                "variable": {
                    "value": "anchors_pillars",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "anchors_pillars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calc_anchors_pillar_center(a, l, h, w)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(anchors_pillars, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_43": {
                "variable": {
                    "value": "proposal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "proposal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "proposal_unstack",
                            "variable"
                        ],
                        [
                            "tf.reshape(proposal, [3, 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "meshgrid_54": {
                "variable": {
                    "value": "(x, y, z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(0, l, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(0, h, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "indexing": {
                    "value": "ij",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_59": {
                "variable": {
                    "value": "anchors_pillar",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, y, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_60": {
                "variable": {
                    "value": "anchors_pillar",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "anchors_pillar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([x, y, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(anchors_pillar, [-1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_54": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_ops/sampling/tf_sampling.py": {
        "tensorflow": {
            "load_op_library_7": {
                "variable": {
                    "value": "sampling_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_sampling_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_38": {
                "op_type": {
                    "value": "GatherPoint",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "lib/utils/tf_util.py": {
        "tensorflow": {
            "get_variable_18": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truncated_normal_initializer(mean=0.0, stddev=0.01)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.xavier_initializer()",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal_initializer(stddev=stddev)",
                            "Call"
                        ],
                        [
                            "initializer",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float16 if use_fp16 else tf.float32",
                            "IfExp"
                        ]
                    ]
                }
            },
            "truncated_normal_initializer_39": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "multiply_46": {
                "variable": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(var)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wd",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv1d_102": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay, focal_loss=focal_loss)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_179": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay, focal_loss=focal_loss)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv3d_250": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay, focal_loss=focal_loss)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_301": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=[num_input_units, num_outputs], use_xavier=use_xavier, stddev=stddev, wd=weight_decay, focal_loss=focal_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool_339": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_364": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool3d_390": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool3d_415": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_16": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_43": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stddev",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_to_collection_47": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(var), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_88": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_113": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], biases_initializer)",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_164": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_190": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], biases_initializer)",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_239": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_260": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], biases_initializer)",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ],
                        [
                            "data_format",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_293": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_309": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "group_norm_template(outputs, is_training, scope='gn')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn')",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(inputs, keep_prob, noise_shape)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], biases_initializer)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], biases_initializer)",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_336": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_361": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_387": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_412": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_540": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_542": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "l2_loss_46": {
                "t": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_108": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.log((1 - 0.01) / 0.01)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_110": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_185": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.log((1 - 0.01) / 0.01)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_187": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_255": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.log((1 - 0.01) / 0.01)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_257": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_304": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.log((1 - 0.01) / 0.01)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_306": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    }
}