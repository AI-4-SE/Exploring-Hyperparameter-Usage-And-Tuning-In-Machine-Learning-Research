{
    "pero_ocr/layout_engines/layout_helpers.py": {
        "sklearn": {}
    },
    "pero_ocr/layout_engines/naive_sorter.py": {
        "sklearn": {
            "DBSCAN_70": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "eps": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.shape[1] // self.width_denom",
                            "BinOp"
                        ]
                    ]
                },
                "min_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/document_ocr/repair_engine.py": {
        "tensorflow": {
            "import_meta_graph_32": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "repair_model + '.meta'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_38": {
                "variable": {
                    "value": "self.repair_session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "import_meta_graph_43": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "inpainting_model + '.meta'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_49": {
                "variable": {
                    "value": "self.inpainting_session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_34": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "ConfigProto_36": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "reset_default_graph_42": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_45": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "ConfigProto_47": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/layout_engines/parsenet.py": {
        "tensorflow": {
            "disable_v2_behavior_9": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_31": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(intra_op_parallelism_threads=6, inter_op_parallelism_threads=1, device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "GraphDef_17": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_24": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "intra_op_parallelism_threads": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                },
                "inter_op_parallelism_threads": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "ConfigProto_26": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "GFile_16": {
                "name": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_path",
                            "Method Argument"
                        ],
                        [
                            "model_path",
                            "Method Argument"
                        ],
                        [
                            "model_path",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_19": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "import_graph_def_20": {
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "prefix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'prefix'",
                            "Method Argument"
                        ],
                        [
                            "'parsenet'",
                            "Method Argument"
                        ],
                        [
                            "'tiltnet'",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "pero_ocr/ocr_engine/CTC_nets.py": {
        "tensorflow": {
            "dropout_73": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_77": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "conv1d_85": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_88": {
                "variable": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ctc_greedy_decoder_89": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "dropout_116": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_121": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_124": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_126": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_133": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_134": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_136": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv1d_143": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_146": {
                "variable": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ctc_greedy_decoder_147": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv1d_214": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_217": {
                "variable": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ctc_greedy_decoder_218": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "dropout_248": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_253": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_256": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_258": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_normalization_259": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_260": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_261": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_263": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_314": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_319": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_pooling2d_368": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_pooling2d_371": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_pooling2d_374": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "(2, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "max_pooling2d_377": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "(2, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "conv2d_379": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "512",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(2, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_382": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_389": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_391": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_393": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_396": {
                "variable": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ctc_greedy_decoder_397": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_477": {
                "variable": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "keep_prob",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_478": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_480": {
                "variable": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "train_phase",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_481": {
                "variable": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "data_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_489": {
                "variable": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "seq_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_515": {
                "variable": {
                    "value": "logits_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(tf.pow(logits, 2), 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_516": {
                "variable": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[tf.reduce_mean(trn_loss, name='trn_loss'), tf.multiply(logits_loss, logits_regularization)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_collection_518": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_522": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_523": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "0.33",
                    "type": "float",
                    "possible_values": []
                }
            },
            "placeholder_535": {
                "variable": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "keep_prob",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_536": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_538": {
                "variable": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "train_phase",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_539": {
                "variable": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "data_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_568": {
                "variable": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "trn_loss_reduce_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_collection_570": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_597": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_598": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "placeholder_608": {
                "variable": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "keep_prob",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_609": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_611": {
                "variable": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "train_phase",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_612": {
                "variable": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "data_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_641": {
                "variable": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "trn_loss_reduce_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_collection_643": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_673": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_674": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "placeholder_685": {
                "variable": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "data_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ],
                        [
                            "data_shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "input_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_687": {
                "variable": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "seq_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_698": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "conv2d_9": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_filter_count * scale_id",
                            "BinOp"
                        ],
                        [
                            "filter_count",
                            "Method Argument"
                        ],
                        [
                            "filter_count",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "dilation_rate": {
                    "value": "dilations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'same'",
                            "Method Argument"
                        ],
                        [
                            "'same'",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_17": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv1d_24": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_filter_count * scale_id",
                            "BinOp"
                        ],
                        [
                            "filter_count",
                            "Method Argument"
                        ],
                        [
                            "filter_count",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "dilation_rate": {
                    "value": "dilations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'same'",
                            "Method Argument"
                        ],
                        [
                            "'same'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_32": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_49": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling2d_68": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_69": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling2d_105": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_106": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_131": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling2d_163": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_164": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling1d_173": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_174": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_195": {
                "variable": {
                    "value": "lstm_net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_197": {
                "variable": {
                    "value": "lstm_net",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "lstm_net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(lstm_net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(lstm_net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(lstm_net, training=train_phase)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_207": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling2d_236": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_237": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ctc_greedy_decoder_284": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t_all[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "max_pooling2d_302": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_303": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='keep_prob')",
                            "Call"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ],
                        [
                            "keep_prob",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_327": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.boolean_mask(net, mask, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_336": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.boolean_mask(net, mask, axis=0), [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(branch)",
                            "Call"
                        ],
                        [
                            "tf.transpose(branch, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(branch, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(branch)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(branch, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([masked_bypass, branch], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_normalization_337": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.boolean_mask(net, mask, axis=0), [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(branch)",
                            "Call"
                        ],
                        [
                            "tf.transpose(branch, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(branch, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(branch)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(branch, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([masked_bypass, branch], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_338": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.boolean_mask(net, mask, axis=0), [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(branch)",
                            "Call"
                        ],
                        [
                            "tf.transpose(branch, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(branch, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(branch)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(branch, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([masked_bypass, branch], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_339": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.boolean_mask(net, mask, axis=0), [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(branch)",
                            "Call"
                        ],
                        [
                            "tf.transpose(branch, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(branch, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(branch)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(branch, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([masked_bypass, branch], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_340": {
                "variable": {
                    "value": "masked_bypass",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_341": {
                "variable": {
                    "value": "masked_bypass",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "masked_bypass",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(bypass, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(masked_bypass, mask, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ],
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_342": {
                "variable": {
                    "value": "branch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[masked_bypass, branch]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ctc_greedy_decoder_355": {
                "variable": {
                    "value": "(decoded, log_prob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits_t_all[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_484": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TARGETS",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sparse_placeholder_485": {
                "variable": {
                    "value": "str_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "str_targets",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_491": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_500": {
                "variable": {
                    "value": "char_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_501": {
                "variable": {
                    "value": "ler",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.not_equal(char_preds, targets), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "label_error_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_502": {
                "variable": {
                    "value": "ler_chars",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.edit_distance(tf.cast(decoded[0], tf.int32), str_targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "str_label_error_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_507": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.not_equal(targets, class_count - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_509": {
                "variable": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.not_equal(targets, class_count - 1), tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_520": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_550": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_623": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_normalization_16": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_31": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_48": {
                "name": {
                    "value": "summaries",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_50": {
                "name": {
                    "value": "mean",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(var)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_52": {
                "variable": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(tf.square(var - mean))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_53": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(tf.reduce_mean(tf.square(var - mean)))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_54": {
                "name": {
                    "value": "max",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_max(var)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_55": {
                "name": {
                    "value": "min",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_min(var)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_56": {
                "name": {
                    "value": "histogram",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling1d_109": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "strides": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_187": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "bypass + [net]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_normalization_201": {
                "variable": {
                    "value": "lstm_net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lstm_net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(lstm_net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(lstm_net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(lstm_net, training=train_phase)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "train_phase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.bool, name='train_phase')",
                            "Call"
                        ],
                        [
                            "False",
                            "bool"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ],
                        [
                            "train_phase",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_pooling1d_241": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "strides": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "max_pooling1d_307": {
                "variable": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "bp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, base_filter_count * 2, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(bp, 2 ** (block_count - i - 1), 2 ** (block_count - i - 1))",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "strides": {
                    "value": "2 ** (block_count - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sparse_placeholder_487": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TARGETS",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_512": {
                "variable": {
                    "value": "ler",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.edit_distance(tf.cast(decoded[0], tf.int32), targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "label_error_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ctc_loss_514": {
                "variable": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "label_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "ctc_merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_515": {
                "input_tensor": {
                    "value": "tf.pow(logits, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_519": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_571": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_591": {
                "variable": {
                    "value": "grads_and_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_592": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_594": {
                "variable": {
                    "value": "grads_and_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_595": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_644": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_667": {
                "variable": {
                    "value": "grads_and_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_668": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_670": {
                "variable": {
                    "value": "grads_and_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_671": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, name='learning_rate')",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_51": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_max_54": {
                "input_tensor": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_min_55": {
                "input_tensor": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "UpSampling1D_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LayerNormalization_129": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "UpSampling1D_139": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "UpSampling1D_266": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_272": {
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'MASK_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv1d_276": {
                "input": {
                    "value": "tf.boolean_mask(net, mask, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_283": {
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_323": {
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'MASK_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "boolean_mask_327": {
                "tensor": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ],
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv1d_347": {
                "input": {
                    "value": "lstm_all[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filters": {
                    "value": "class_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count + 1",
                            "BinOp"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ],
                        [
                            "class_count",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_354": {
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_501": {
                "x": {
                    "value": "tf.not_equal(char_preds, targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "edit_distance_503": {
                "hypothesis": {
                    "value": "tf.cast(decoded[0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "truth": {
                    "value": "str_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse_placeholder(tf.int32, name='str_targets')",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_507": {
                "x": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "class_count - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pow_515": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, class_count, 1)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_516": {
                "input_tensor": {
                    "value": "trn_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.sparse_softmax_cross_entropy(labels=targets, logits=logits, weights=weights)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum([tf.reduce_mean(trn_loss, name='trn_loss'), tf.multiply(logits_loss, logits_regularization)])",
                            "Call"
                        ],
                        [
                            "tf.nn.ctc_loss(targets, logits_t, seq_len, ctc_merge_repeated=True)",
                            "Call"
                        ],
                        [
                            "tf.add_n(trn_loss_reduce_all)",
                            "Call"
                        ],
                        [
                            "tf.add_n(trn_loss_reduce_all)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_516": {
                "x": {
                    "value": "logits_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(tf.pow(logits, 2), 1))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "logits_regularization",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_placeholder_543": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'TARGETS_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_547": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'seq_len_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "edit_distance_559": {
                "hypothesis": {
                    "value": "tf.cast(decoded[0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "truth": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ctc_loss_565": {
                "labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "label_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "ctc_merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_566": {
                "input_tensor": {
                    "value": "trn_loss_all[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_575": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sparse_placeholder_616": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'TARGETS_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_620": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'seq_len_{}'.format(last_layer_index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "edit_distance_632": {
                "hypothesis": {
                    "value": "tf.cast(decoded[0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "truth": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ctc_loss_638": {
                "labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, (1, 0, 2))",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ],
                        [
                            "net_builder(class_count, net, train_phase, keep_prob, seq_len)",
                            "Call"
                        ]
                    ]
                },
                "label_length": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "zip(logits_all, seq_len_all)",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, [None], name='seq_len')",
                            "Call"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ],
                        [
                            "seq_len",
                            "Method Argument"
                        ]
                    ]
                },
                "ctc_merge_repeated": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_639": {
                "input_tensor": {
                    "value": "trn_loss_all[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "trn_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_648": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_690": {
                "x": {
                    "value": "input_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.uint8, shape=data_shape, name='input_data')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_692": {
                "value": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LayerNormalization_14": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "LayerNormalization_29": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_52": {
                "input_tensor": {
                    "value": "tf.square(var - mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LayerNormalization_199": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "UpSampling1D_209": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "boolean_mask_276": {
                "tensor": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding, use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(net, filters=filter_count, kernel_size=kernel_size, dilation_rate=dilations, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, count, kernel_size=(height, 1), padding='valid')",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.LayerNormalization(axis=-1, center=True, scale=True)(net)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i, layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, base_filter_count * 2 ** (i + block_count_2d), layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling1d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, 1, filter_count, kernel_size=1, dilations=1, padding='same', layer_norm=layer_norm)",
                            "Call"
                        ],
                        [
                            "net + lstm_net",
                            "BinOp"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(net, training=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.UpSampling1D()(net)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block_1d(net, train_phase, block_layer_count, num_hidden)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, block_layer_count, base_filter_count * 2 ** i)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, num_hidden, padding='same')",
                            "Call"
                        ],
                        [
                            "get_aggregation(net, num_hidden, train_phase)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(net, keep_prob ** 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(bypass + [net], axis=2)",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 64)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 1, 128)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, 2, 2)",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 256)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "sequential_conv_block(net, train_phase, 2, 512)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(net, (2, 1), (2, 1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(net, filters=512, kernel_size=(2, 1), padding='valid', use_bias=False)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(net)",
                            "Call"
                        ],
                        [
                            "net[:, 0, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "lstm(net)",
                            "Call"
                        ],
                        [
                            "tf.transpose(net, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32)",
                            "Call"
                        ],
                        [
                            "manipulator().transform(input_data, train_phase=train_phase)",
                            "Call"
                        ],
                        [
                            "tf.cast(input_data, tf.float32) / 255",
                            "BinOp"
                        ],
                        [
                            "manipulator().transform(input_data, tf.constant(False, dtype=tf.bool))",
                            "Call"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ],
                        [
                            "net",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ],
                        [
                            "zip(range(number_of_last_layers), mask_all)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "not_equal_501": {
                "x": {
                    "value": "char_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=2, output_type=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_503": {
                "x": {
                    "value": "decoded[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "edit_distance_512": {
                "hypothesis": {
                    "value": "tf.cast(decoded[0], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "truth": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "tf.sparse_placeholder(tf.int32, name='TARGETS')",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ],
                        [
                            "zip(decoded_all, targets_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_559": {
                "x": {
                    "value": "decoded[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_588": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers_to_train",
                            "variable"
                        ],
                        [
                            "layers_to_train",
                            "variable"
                        ]
                    ]
                }
            },
            "cast_632": {
                "x": {
                    "value": "decoded[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_664": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers_to_train",
                            "variable"
                        ],
                        [
                            "layers_to_train",
                            "variable"
                        ]
                    ]
                }
            },
            "square_52": {
                "x": {
                    "value": "var - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_512": {
                "x": {
                    "value": "decoded[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/ocr_engine/line_ocr_engine.py": {
        "tensorflow": {
            "Graph_120": {
                "variable": {
                    "value": "self.net_graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_139": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.net_graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_121": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_135": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "ConfigProto_137": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/decoding/decoding_itf.py": {
        "torch": {
            "from_numpy_71": {
                "variable": {
                    "value": "dense_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "logits.toarray()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_31": {
                "variable": {
                    "value": "lm",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "compose_path(path, config_path)",
                    "type": "Call",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_softmax_73": {
                "input": {
                    "value": "dense_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(logits.toarray()).float()",
                            "Call"
                        ],
                        [
                            "F.log_softmax(dense_logits, dim=-1).data",
                            "Attribute"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "device_31": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/decoding/lm_wrapper.py": {
        "torch": {
            "device_72": {
                "variable": {
                    "value": "self._lm_device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tensor_112": {
                "variable": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[start_input]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_65": {
                "variable": {
                    "value": "self._lm_device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "no_grad_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_98": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_52": {
                "variable": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._h, other._h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "device_69": {
                "variable": {
                    "value": "self._lm_device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "from_numpy_82": {
                "ndarray": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsqueeze_82": {
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_50": {
                "tensors": {
                    "value": "[s, o]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/layout_engines/torch_parsenet.py": {
        "torch": {
            "from_numpy_50": {
                "variable": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((1, new_shape_x, new_shape_y, 3), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(test_img_canvas).to(self.device).float().permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "np.zeros((1, new_shape_x, new_shape_y, 3), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(test_img_canvas).to(self.device).float().permute(0, 3, 1, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "permute_50": {
                "variable": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_119": {
                "variable": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((1, new_shape_x, new_shape_y, 3), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(test_img_canvas).to(self.device).float().permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "np.zeros((1, new_shape_x, new_shape_y, 3), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(test_img_canvas).to(self.device).float().permute(0, 3, 1, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "permute_119": {
                "variable": {
                    "value": "test_img_canvas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dims": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "load_16": {
                "variable": {
                    "value": "self.net",
                    "type": "Attribute",
                    "possible_values": []
                },
                "f": {
                    "value": "model_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_path",
                            "Method Argument"
                        ],
                        [
                            "model_path",
                            "Method Argument"
                        ],
                        [
                            "model_path",
                            "Method Argument"
                        ]
                    ]
                },
                "map_location": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "pero_ocr/ocr_engine/pytorch_ocr_engine.py": {
        "torch": {
            "cat_14": {
                "variable": {
                    "value": "scores_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(scores_probs[:, 0:1], scores_probs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_18": {
                "variable": {
                    "value": "scores_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(scores_probs[:, :, 0:1], scores_probs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "device_42": {
                "variable": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0 if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Sequential_89": {
                "*args": {
                    "value": "*layers",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_110": {
                "*args": {
                    "value": "*layers",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_159": {
                "variable": {
                    "value": "self.blocks_2d",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.blocks_2d",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "LSTM_161": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv1d_162": {
                "variable": {
                    "value": "self.output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_167": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(out, 2)",
                            "Call"
                        ],
                        [
                            "self.block_1d(out)",
                            "Call"
                        ],
                        [
                            "self.gru(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "outputs[0]",
                            "Subscript"
                        ],
                        [
                            "layer(scaled_data.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "out + output",
                            "BinOp"
                        ],
                        [
                            "self.final_layer(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "torch.nn.functional.interpolate(out, scale_factor=2 ** depth, mode='nearest')",
                            "Call"
                        ],
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.max(out, 2)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(out)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_223": {
                "variable": {
                    "value": "self.blocks_2d",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.blocks_2d",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "ModuleList_234": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[torch.nn.LSTM(channels, channels // 2, num_layers=layers_per_scale, bidirectional=True) for scale in range(scales)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "LSTM_237": {
                "variable": {
                    "value": "self.final_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv1d_272": {
                "variable": {
                    "value": "self.output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "rnn_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.blocks_2d.out_channels",
                            "Attribute"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ],
                        [
                            "num_classes",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_277": {
                "variable": {
                    "value": "(out, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(out, 2)",
                            "Call"
                        ],
                        [
                            "self.block_1d(out)",
                            "Call"
                        ],
                        [
                            "self.gru(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "outputs[0]",
                            "Subscript"
                        ],
                        [
                            "layer(scaled_data.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "out + output",
                            "BinOp"
                        ],
                        [
                            "self.final_layer(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "torch.nn.functional.interpolate(out, scale_factor=2 ** depth, mode='nearest')",
                            "Call"
                        ],
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.max(out, 2)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(out)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Parameter_324": {
                "variable": {
                    "value": "self.scale",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_325": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_326": {
                "variable": {
                    "value": "self.tau",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_332": {
                "variable": {
                    "value": "nu2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.pow(x, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_343": {
                "variable": {
                    "value": "self.scale",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_344": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_345": {
                "variable": {
                    "value": "self.tau",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, self.in_channels, 1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_351": {
                "variable": {
                    "value": "nu2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.pow(x, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv1d_362": {
                "variable": {
                    "value": "self.embed_to_param_net",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self.embeddings['dim']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "int(self.in_channels * 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Parameter_364": {
                "variable": {
                    "value": "self.embed_to_param_net.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "self.embed_to_param_net.weight * (scale_std / 0.6)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Parameter_365": {
                "variable": {
                    "value": "self.embed_to_param_net.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros_like(self.embed_to_param_net.bias)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "std_mean_372": {
                "variable": {
                    "value": "(self.std_in, self.mean_in)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "chunk_374": {
                "variable": {
                    "value": "(self.scale, self.bias)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "embed_to_param_net_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.embed_to_param_net(self.embeddings['data'].unsqueeze(2))",
                            "Call"
                        ],
                        [
                            "self.embed_to_param_net(self.embeddings['data'].unsqueeze(2).unsqueeze(3))",
                            "Call"
                        ]
                    ]
                },
                "chunks": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_387": {
                "variable": {
                    "value": "self.embed_to_param_net",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self.embeddings['dim']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "int(self.in_channels * 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Parameter_389": {
                "variable": {
                    "value": "self.embed_to_param_net.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "self.embed_to_param_net.weight * (scale_std / 0.6)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Parameter_390": {
                "variable": {
                    "value": "self.embed_to_param_net.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros_like(self.embed_to_param_net.bias)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "std_mean_397": {
                "variable": {
                    "value": "(self.std_in, self.mean_in)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "(2, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "chunk_399": {
                "variable": {
                    "value": "(self.scale, self.bias)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "embed_to_param_net_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.embed_to_param_net(self.embeddings['data'].unsqueeze(2))",
                            "Call"
                        ],
                        [
                            "self.embed_to_param_net(self.embeddings['data'].unsqueeze(2).unsqueeze(3))",
                            "Call"
                        ]
                    ]
                },
                "chunks": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_473": {
                "variable": {
                    "value": "self.conv_blocks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.conv_blocks",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Dropout_502": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_612": {
                "variable": {
                    "value": "self.down_sample_blocks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.down_sample_blocks",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_629": {
                "variable": {
                    "value": "self.aggregation_block",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.aggregation_block",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Sequential_641": {
                "variable": {
                    "value": "self.recurrent_block",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.recurrent_block",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Conv1d_644": {
                "variable": {
                    "value": "self.output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "actual_in_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "self.in_channels",
                            "Attribute"
                        ],
                        [
                            "actual_out_channels",
                            "variable"
                        ],
                        [
                            "actual_out_channels",
                            "variable"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "self.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_22": {
                "input": {
                    "value": "scores_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat((scores_probs[:, 0:1], scores_probs), axis=1)",
                            "Call"
                        ],
                        [
                            "torch.cat((scores_probs[:, :, 0:1], scores_probs), axis=2)",
                            "Call"
                        ],
                        [
                            "scores_probs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "mean_51": {
                "variable": {
                    "value": "mean_embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model.embeddings_layer(torch.LongTensor(list(range(self.model.embeddings_layer.num_embeddings))).to(self.device))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "embeddings",
                            "Method Argument"
                        ],
                        [
                            "embeddings",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_88": {
                "kernel_size": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_335": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "max_354": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Conv1d_420": {
                "variable": {
                    "value": "self.conv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self.out_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.stride",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MaxPool1d_489": {
                "variable": {
                    "value": "self.pooling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.stride",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_45": {
                "f": {
                    "value": "self.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "map_location": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_56": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "max_pool1d_245": {
                "variable": {
                    "value": "scaled_data",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scaled_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "torch.nn.functional.max_pool1d(scaled_data, kernel_size=2, stride=2)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "interpolate_250": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.mean(out, 2)",
                            "Call"
                        ],
                        [
                            "self.block_1d(out)",
                            "Call"
                        ],
                        [
                            "self.gru(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "outputs[0]",
                            "Subscript"
                        ],
                        [
                            "layer(scaled_data.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "out.permute(1, 2, 0)",
                            "Call"
                        ],
                        [
                            "out + output",
                            "BinOp"
                        ],
                        [
                            "self.final_layer(out.permute(2, 0, 1))",
                            "Call"
                        ],
                        [
                            "torch.nn.functional.interpolate(out, scale_factor=2 ** depth, mode='nearest')",
                            "Call"
                        ],
                        [
                            "self.blocks_2d(x)",
                            "Call"
                        ],
                        [
                            "torch.max(out, 2)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(out)",
                            "Call"
                        ],
                        [
                            "self.output_layer(out)",
                            "Call"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ],
                        [
                            "(x - self.mean_in) / (self.std_in + 1e-05)",
                            "BinOp"
                        ]
                    ]
                },
                "scale_factor": {
                    "value": "2 ** depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mode": {
                    "value": "nearest",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNorm1d_291": {
                "variable": {
                    "value": "self.normalization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pow_332": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "exponent": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rsqrt_333": {
                "input": {
                    "value": "nu2 + self.eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pow_351": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "x * torch.rsqrt(nu2 + self.eps)",
                            "BinOp"
                        ],
                        [
                            "x * self.scale + self.bias",
                            "BinOp"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.activation(x)",
                            "Call"
                        ],
                        [
                            "self.inner_block(x)",
                            "Call"
                        ],
                        [
                            "self.pooling(x)",
                            "Call"
                        ],
                        [
                            "self.normalization(x)",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.conv_block(x)",
                            "Call"
                        ],
                        [
                            "x.permute(0, 3, 1, 2)",
                            "Call"
                        ],
                        [
                            "self.down_sample_blocks(x)",
                            "Call"
                        ],
                        [
                            "self.aggregation_block(x)",
                            "Call"
                        ],
                        [
                            "self.recurrent_block(x)",
                            "Call"
                        ],
                        [
                            "self.output(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "exponent": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rsqrt_352": {
                "input": {
                    "value": "nu2 + self.eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_365": {
                "input": {
                    "value": "self.embed_to_param_net.bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_390": {
                "input": {
                    "value": "self.embed_to_param_net.bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2d_423": {
                "variable": {
                    "value": "self.conv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self.out_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.stride",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MaxPool2d_491": {
                "variable": {
                    "value": "self.pooling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.stride",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_555": {
                "variable": {
                    "value": "self.embeddings_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "scale_grad_by_freq": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Embedding_559": {
                "variable": {
                    "value": "self.embeddings_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "scale_grad_by_freq": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "is_available_42": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "from_numpy_57": {
                "ndarray": {
                    "value": "batch_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(batch_data).to(self.device).float() / 255.0",
                            "BinOp"
                        ],
                        [
                            "batch_data",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Conv2d_73": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_74": {
                "num_features": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "LeakyReLU_75": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv1d_97": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm1d_98": {
                "num_features": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "LeakyReLU_99": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "BatchNorm2d_155": {
                "num_features": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "BatchNorm2d_219": {
                "num_features": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "LSTM_234": {
                "*args": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "layers_per_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "bidirectional": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm2d_293": {
                "variable": {
                    "value": "self.normalization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "InstanceNorm1d_296": {
                "variable": {
                    "value": "self.normalization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2d_79": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LeakyReLU_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv1d_103": {
                "in_channels": {
                    "value": "in_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "layer.bias.shape[0]",
                            "Subscript"
                        ],
                        [
                            "out_channels",
                            "variable"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "in_channels",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "out_channels": {
                    "value": "out_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "in_channels",
                            "variable"
                        ],
                        [
                            "base_channels * 2 ** i",
                            "BinOp"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ],
                        [
                            "out_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LeakyReLU_104": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MaxPool2d_135": {
                "kernel_size": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "MaxPool2d_196": {
                "kernel_size": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2, 2)",
                            "Tuple"
                        ],
                        [
                            "(2, 1)",
                            "Tuple"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "(2",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "InstanceNorm2d_298": {
                "variable": {
                    "value": "self.normalization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.in_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "test/test_decoding/test_lm_wrapper.py": {
        "torch": {
            "Embedding_12": {
                "variable": {
                    "value": "self._model_i",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_18": {
                "variable": {
                    "value": "self._model_r",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_44": {
                "variable": {
                    "value": "self._model_o",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out_features": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "from_numpy_101": {
                "variable": {
                    "value": "in_h",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.asarray([-2.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_106": {
                "variable": {
                    "value": "in_h",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.asarray([-2.0, 3.0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_111": {
                "variable": {
                    "value": "in_h",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.asarray([[-1.0, 3.0], [-2.0, 4.0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_112": {
                "variable": {
                    "value": "in_c",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.asarray([[-1.0, 3.0], [-2.0, 4.0]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensor_133": {
                "variable": {
                    "value": "expected",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[-2.0], [4.0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_171": {
                "variable": {
                    "value": "self._device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_178": {
                "variable": {
                    "value": "self._device",
                    "type": "Attribute",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cat_38": {
                "tensors": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "hs",
                            "Method Argument"
                        ],
                        [
                            "hs",
                            "Method Argument"
                        ],
                        [
                            "hs",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensor_84": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[prefix_id] + sentence_ids",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tensor_86": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "sentence_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self.vocab[c] for c in sentence]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "ones_29": {
                "*size": {
                    "value": "(1, bsz, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "ref.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "ref.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_108": {
                "input": {
                    "value": "h0.prepare_for_torch()",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "in_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(np.asarray([-2.0])).to(dtype=torch.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.asarray([-2.0, 3.0])).to(dtype=torch.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.asarray([[-1.0, 3.0], [-2.0, 4.0]])).to(dtype=torch.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_114": {
                "input": {
                    "value": "h0.prepare_for_torch()[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "other": {
                    "value": "in_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(np.asarray([-2.0])).to(dtype=torch.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.asarray([-2.0, 3.0])).to(dtype=torch.float32)",
                            "Call"
                        ],
                        [
                            "torch.from_numpy(np.asarray([[-1.0, 3.0], [-2.0, 4.0]])).to(dtype=torch.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_115": {
                "input": {
                    "value": "h0.prepare_for_torch()[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "other": {
                    "value": "in_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.from_numpy(np.asarray([[-1.0, 3.0], [-2.0, 4.0]])).to(dtype=torch.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_126": {
                "data": {
                    "value": "[-2.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_131": {
                "data": {
                    "value": "[[-2.0], [2.0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_137": {
                "data": {
                    "value": "[[[1.0]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_142": {
                "data": {
                    "value": "[[[1.0], [-2.0]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_163": {
                "data": {
                    "value": "[[[0.0], [0.2]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_94": {
                "tensors": {
                    "value": "[h0[0][0].unsqueeze(1), o]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_128": {
                "data": {
                    "value": "[-2.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_148": {
                "data": {
                    "value": "[[19.0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "arange_62": {
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "preds_flat.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    }
}