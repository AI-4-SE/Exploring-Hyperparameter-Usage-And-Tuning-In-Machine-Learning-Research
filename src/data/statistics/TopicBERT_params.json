{
    "TopicBERT/topic_bert/interpretability.py": {
        "sklearn": {
            "precision_recall_fscore_support_794": {
                "variable": {
                    "value": "(macro_prec, macro_recall, macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_795": {
                "variable": {
                    "value": "(micro_prec, micro_recall, micro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_796": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_866": {
                "variable": {
                    "value": "(macro_prec, macro_recall, macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_867": {
                "variable": {
                    "value": "(micro_prec, micro_recall, micro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_868": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "set_random_seed_27": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "expand_dims_515": {
                "variable": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5 * tf.math.reduce_max(doc_repres, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(min_allowed_val, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_516": {
                "variable": {
                    "value": "min_allowed",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5 * tf.math.reduce_max(doc_repres, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(min_allowed_val, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, FLAGS.n_topic]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_517": {
                "variable": {
                    "value": "boolean_allowed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.greater_equal(doc_repres, min_allowed)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_892": {
                "variable": {
                    "value": "saver_PPL",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_919": {
                "variable": {
                    "value": "saver_PPL",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_1113": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1114": {
                "variable": {
                    "value": "input_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1115": {
                "variable": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "segment_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1122": {
                "variable": {
                    "value": "doc_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1123": {
                "variable": {
                    "value": "topic_bow",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, topic_vocab_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1124": {
                "variable": {
                    "value": "topic_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1125": {
                "variable": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "is_training",
                    "type": "str",
                    "possible_values": []
                }
            },
            "parse_single_example_203": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": [
                        [
                            "serialized_example",
                            "Method Argument"
                        ]
                    ]
                },
                "features": {
                    "value": "{'input_ids': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'input_mask': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'segment_ids': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'label_ids': tf.FixedLenFeature([label_size], tf.int64), 'doc_id': tf.FixedLenFeature([1], tf.int64)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "TFRecordDataset_227": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TFRecordDataset_235": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_561": {
                "variable": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_model.get_pooled_output()",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_layer, keep_prob=1 - is_training, seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "1 - is_training",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "get_variable_683": {
                "variable": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hidden_size, num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_687": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "xw_plus_b_690": {
                "variable": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_705": {
                "variable": {
                    "value": "self.comb_lm_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.comb_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_706": {
                "variable": {
                    "value": "self.topic_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.topic_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_708": {
                "variable": {
                    "value": "self.comb_obj_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "(1.0 - FLAGS.alpha) * self.comb_lm_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "FLAGS.alpha * FLAGS.gsm_lr_factor * self.topic_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "local_variables_initializer_890": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_890": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_891": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_891": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_1090": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_1118": {
                "variable": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "label_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1121": {
                "variable": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "label_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1128": {
                "variable": {
                    "value": "static_topic",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, FLAGS.n_topic)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "static_topics",
                    "type": "str",
                    "possible_values": []
                }
            },
            "run_1141": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_max_514": {
                "input_tensor": {
                    "value": "doc_repres",
                    "type": "variable",
                    "possible_values": [
                        [
                            "doc_repres",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_equal_517": {
                "x": {
                    "value": "doc_repres",
                    "type": "variable",
                    "possible_values": [
                        [
                            "doc_repres",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "min_allowed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(min_allowed_val, [1, FLAGS.n_topic])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_595": {
                "variable": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hidden_size, num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_599": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "xw_plus_b_602": {
                "variable": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_model.get_pooled_output()",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_layer, keep_prob=1 - is_training, seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_620": {
                "variable": {
                    "value": "self.bert_obj_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.bert_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_659": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output_layer, self.doc_repres]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_694": {
                "variable": {
                    "value": "self.comb_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_695": {
                "variable": {
                    "value": "self.comb_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(label_ids, self.comb_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_698": {
                "variable": {
                    "value": "self.comb_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_699": {
                "variable": {
                    "value": "self.comb_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_701": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(label_list)",
                            "Call"
                        ],
                        [
                            "num_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_892": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_919": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_1069": {
                "config": {
                    "value": "tf.ConfigProto(inter_op_parallelism_threads=FLAGS.num_cores, intra_op_parallelism_threads=FLAGS.num_cores, gpu_options=tf.GPUOptions(allow_growth=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_563": {
                "name_or_scope": {
                    "value": "bert_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_608": {
                "variable": {
                    "value": "self.bert_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_609": {
                "variable": {
                    "value": "self.bert_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(label_ids, self.bert_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_614": {
                "variable": {
                    "value": "self.bert_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_615": {
                "variable": {
                    "value": "self.log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_617": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(label_list)",
                            "Call"
                        ],
                        [
                            "num_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_662": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_layer.shape[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "modeling.get_activation(bert_config.hidden_act)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "modeling.create_initializer(bert_config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_568": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output_layer, self.static_topic]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_685": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "zeros_initializer_688": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_695": {
                "multi_class_labels": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_703": {
                "input_tensor": {
                    "value": "self.one_hot_labels * self.comb_log_probs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ConfigProto_1069": {
                "inter_op_parallelism_threads": {
                    "value": "FLAGS.num_cores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "intra_op_parallelism_threads": {
                    "value": "FLAGS.num_cores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(allow_growth=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tf_record_iterator_1111": {
                "path": {
                    "value": "train_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.data_dir, 'training.tfrecord')",
                            "Call"
                        ],
                        [
                            "train_file",
                            "Method Argument"
                        ],
                        [
                            "train_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "FixedLenFeature_206": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_209": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_212": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_215": {
                "shape": {
                    "value": "[label_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_218": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_571": {
                "variable": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_layer.shape[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "modeling.get_activation(bert_config.hidden_act)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "modeling.create_initializer(bert_config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_597": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "zeros_initializer_600": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_609": {
                "multi_class_labels": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_619": {
                "input_tensor": {
                    "value": "self.one_hot_labels * self.log_probs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GPUOptions_1069": {
                "allow_growth": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/model_GSM_supervised.py": {
        "sklearn": {
            "precision_recall_fscore_support_676": {
                "variable": {
                    "value": "(print_macro_prec, print_macro_recall, print_macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "doc_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_labels)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "doc_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_pred)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_678": {
                "variable": {
                    "value": "print_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "doc_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_labels)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "doc_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_pred)",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "set_random_seed_22": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "add_276": {
                "variable": {
                    "value": "self.unsupervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.recons_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_277": {
                "variable": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "(1 - topic_params.beta) * self.unsupervised_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "topic_params.beta * self.supervised_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_combined_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_279": {
                "variable": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_292": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_296": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_298": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_299": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gradients_301": {
                "variable": {
                    "value": "enc_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_302": {
                "variable": {
                    "value": "dec_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_91": {
                "variable": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_66": {
                "input": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_73": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_123": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_129": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_132": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_141": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.vocab_size, scope='projection', get_matrix=True, matrix_initializer=initializer_nvdm[3][0], bias_initializer=initializer_nvdm[3][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_212": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "input_tensor": {
                    "value": "1 - tf.square(self.mean) + 2 * self.logsigm - tf.exp(2 * self.logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_147": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_148": {
                "variable": {
                    "value": "self.supervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none'), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_151": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_152": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_153": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "n_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_218": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), curr_eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_220": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(tf.exp(self.logsigm), curr_eps), self.mean)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(doc_vec, axis=1)",
                            "Call"
                        ],
                        [
                            "session.run([self.doc_vec], input_feed)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_222": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_231": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_232": {
                "variable": {
                    "value": "self.supervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none'), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_235": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_236": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_237": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "n_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "latest_checkpoint_530": {
                "checkpoint_dir": {
                    "value": "model_dir_ppl_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ppl_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_552": {
                "checkpoint_dir": {
                    "value": "model_dir_f1_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_f1_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_576": {
                "checkpoint_dir": {
                    "value": "model_dir_ir_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ir_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_129": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_142": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_224": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_225": {
                "inputs": {
                    "value": "doc_vec_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "exp_89": {
                "x": {
                    "value": "2 * self.logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_129": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_142": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_148": {
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_154": {
                "input_tensor": {
                    "value": "tf.multiply(log_prob, self.one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_scope_216": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_218": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_232": {
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_238": {
                "input_tensor": {
                    "value": "tf.multiply(log_prob, self.one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_148": {
                "multi_class_labels": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_154": {
                "x": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_218": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_223": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_232": {
                "multi_class_labels": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_238": {
                "x": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_89": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_223": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/model_NVDM_supervised.py": {
        "sklearn": {
            "precision_recall_fscore_support_743": {
                "variable": {
                    "value": "(print_macro_prec, print_macro_recall, print_macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "doc_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_labels)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "doc_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_pred)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_745": {
                "variable": {
                    "value": "print_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "doc_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_labels)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "doc_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.asarray(doc_pred)",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "set_random_seed_22": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "add_286": {
                "variable": {
                    "value": "self.unsupervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.recons_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_287": {
                "variable": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "(1 - topic_params.beta) * self.unsupervised_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "topic_params.beta * self.supervised_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_combined_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_289": {
                "variable": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_302": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_306": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_308": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_309": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gradients_311": {
                "variable": {
                    "value": "enc_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_312": {
                "variable": {
                    "value": "dec_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_378": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_379": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_380": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_92": {
                "variable": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_67": {
                "input": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_74": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_124": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_131": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_softmax_140": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.vocab_size, scope='projection', get_matrix=True, matrix_initializer=initializer_nvdm[3][0], bias_initializer=initializer_nvdm[3][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_223": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_90": {
                "input_tensor": {
                    "value": "1 - tf.square(self.mean) + 2 * self.logsigm - tf.exp(2 * self.logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_146": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_147": {
                "variable": {
                    "value": "self.supervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none'), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_150": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_151": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_152": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "n_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_229": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), curr_eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_231": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_242": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_243": {
                "variable": {
                    "value": "self.supervised_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none'), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_246": {
                "variable": {
                    "value": "self.sup_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_247": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_248": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "depth": {
                    "value": "n_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "n_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "on_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "latest_checkpoint_540": {
                "checkpoint_dir": {
                    "value": "model_dir_ppl_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ppl_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_561": {
                "checkpoint_dir": {
                    "value": "model_dir_f1_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_f1_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_584": {
                "checkpoint_dir": {
                    "value": "model_dir_ir_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ir_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_131": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_141": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_235": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_236": {
                "inputs": {
                    "value": "doc_vec_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "exp_90": {
                "x": {
                    "value": "2 * self.logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_131": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_141": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_147": {
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_153": {
                "input_tensor": {
                    "value": "tf.multiply(log_prob, self.one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_scope_227": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_229": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_243": {
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(self.label_ids, sup_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_249": {
                "input_tensor": {
                    "value": "tf.multiply(log_prob, self.one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_147": {
                "multi_class_labels": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_153": {
                "x": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_229": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_232": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_243": {
                "multi_class_labels": {
                    "value": "self.label_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "sup_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ],
                        [
                            "utils.nvdm_linear(self.doc_vec, self.n_labels, scope='supervised')",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_249": {
                "x": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(sup_logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_90": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_232": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/model_NVDM_yatin.py": {
        "sklearn": {},
        "tensorflow": {
            "set_random_seed_19": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "placeholder_42": {
                "variable": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self.vocab_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_43": {
                "variable": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_218": {
                "variable": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.recons_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_219": {
                "variable": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_228": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_232": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_234": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gradients_236": {
                "variable": {
                    "value": "enc_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_237": {
                "variable": {
                    "value": "dec_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_295": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_296": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_297": {
                "variable": {
                    "value": "pretrain_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_45": {
                "variable": {
                    "value": "self.x_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, self.vocab_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "x_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_48": {
                "variable": {
                    "value": "self.x_doc_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self.vocab_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "x_doc_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_76": {
                "variable": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_223": {
                "variable": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.eye(self.n_topic)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_225": {
                "variable": {
                    "value": "uniqueness",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(tf.matmul(topicnorm, tf.transpose(topicnorm)) - eye)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_51": {
                "input": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_58": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_79": {
                "variable": {
                    "value": "self.x_sent_reshape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.x_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self.vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_90": {
                "variable": {
                    "value": "W_prior",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_TM_prior",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "prior_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_108": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_112": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_softmax_120": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.vocab_size, scope='projection', get_matrix=True, matrix_initializer=initializer_nvdm[3][0], bias_initializer=initializer_nvdm[3][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_176": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_53": {
                "input": {
                    "value": "self.x_sent",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_54": {
                "input": {
                    "value": "self.x_sent",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "1 - tf.square(self.mean) + 2 * self.logsigm - tf.exp(2 * self.logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_126": {
                "variable": {
                    "value": "topics_masked",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(self.x_doc_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(self.decoding_matrix, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "topics_masked",
                    "type": "str",
                    "possible_values": []
                }
            },
            "top_k_127": {
                "variable": {
                    "value": "self.top_k",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "topics_masked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.expand_dims(self.x_doc_mask, axis=1), tf.expand_dims(self.decoding_matrix, axis=0), name='topics_masked')",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "params.use_k_topic_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_144": {
                "variable": {
                    "value": "self.topic_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.top_k_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "topic_embeddings",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_167": {
                "variable": {
                    "value": "self.last_h_topic_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(tf.expand_dims(last_h_softmax, axis=1), self.topic_embeddings)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_topic_emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_softmax_182": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_189": {
                "variable": {
                    "value": "self.last_h_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm_sent), eps_sent)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "sent_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_190": {
                "variable": {
                    "value": "self.last_h_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.last_h_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.input_batch_size_sent, self.input_batch_len_sent, self.n_topic]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_224": {
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.decoding_matrix), 1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_225": {
                "x": {
                    "value": "tf.matmul(topicnorm, tf.transpose(topicnorm)) - eye",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "latest_checkpoint_410": {
                "checkpoint_dir": {
                    "value": "model_dir_ppl_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(params.model, 'model_ppl_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_430": {
                "checkpoint_dir": {
                    "value": "model_dir_ir_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(params.model, 'model_ir_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_112": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_121": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "embedding_lookup_129": {
                "variable": {
                    "value": "self.top_k_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "W_prior",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('embeddings_TM_prior', dtype=tf.float32, initializer=prior_embeddings, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "self.top_k.indices",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "embedding_lookup_136": {
                "variable": {
                    "value": "self.top_k_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.transpose(self.decoding_matrix)",
                    "type": "Call",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.top_k.indices",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "top_k_148": {
                "variable": {
                    "value": "(top_k_h_values, top_k_h_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "self.last_h",
                    "type": "Attribute",
                    "possible_values": []
                },
                "k": {
                    "value": "params.use_k_topics",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "top_k_h",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_149": {
                "variable": {
                    "value": "row_numbers",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(0, self.input_batch_size), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, params.use_k_topics]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "row_numbers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_150": {
                "variable": {
                    "value": "full_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(row_numbers, -1), tf.expand_dims(top_k_h_indices, -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "variable": {
                    "value": "full_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "full_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.expand_dims(row_numbers, -1), tf.expand_dims(top_k_h_indices, -1)], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(full_indices, [-1, 2], name='full_indices')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "full_indices",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scatter_nd_155": {
                "variable": {
                    "value": "last_h_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "full_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.expand_dims(row_numbers, -1), tf.expand_dims(top_k_h_indices, -1)], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(full_indices, [-1, 2], name='full_indices')",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.reshape(tf.nn.softmax(top_k_h_values, axis=1), [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.input_batch_size, self.n_topic]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_163": {
                "variable": {
                    "value": "last_h_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.last_h",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_184": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "matmul_207": {
                "variable": {
                    "value": "self.last_h_topic_emb_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "a": {
                    "value": "last_h_softmax_sent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(full_indices_sent, tf.reshape(tf.nn.softmax(top_k_h_sent_values, axis=1), [-1]), [self.batch_size_sent, self.n_topic], name='last_h_softmax_sent')",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self.last_h_sent, axis=2, name='last_h_softmax_sent')",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.topic_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_topic_emb_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_224": {
                "input_tensor": {
                    "value": "tf.square(self.decoding_matrix)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "exp_74": {
                "x": {
                    "value": "2 * self.logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_112": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_121": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_126": {
                "input": {
                    "value": "self.decoding_matrix",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_167": {
                "a": {
                    "value": "tf.expand_dims(last_h_softmax, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self.topic_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_179": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_181": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "multiply_189": {
                "x": {
                    "value": "tf.exp(self.logsigm_sent)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps_sent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.batch_size_sent, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "top_k_196": {
                "variable": {
                    "value": "(top_k_h_sent_values, top_k_h_sent_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "self.last_h_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "k": {
                    "value": "params.use_k_topics",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "top_k_h_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_197": {
                "variable": {
                    "value": "row_numbers_sent",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(0, self.batch_size_sent), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, params.use_k_topics]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "row_numbers_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_198": {
                "variable": {
                    "value": "full_indices_sent",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(row_numbers_sent, -1), tf.expand_dims(top_k_h_sent_indices, -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_199": {
                "variable": {
                    "value": "full_indices_sent",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "full_indices_sent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.expand_dims(row_numbers_sent, -1), tf.expand_dims(top_k_h_sent_indices, -1)], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(full_indices_sent, [-1, 2], name='full_indices_sent')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "full_indices_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scatter_nd_203": {
                "variable": {
                    "value": "last_h_softmax_sent",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "full_indices_sent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.expand_dims(row_numbers_sent, -1), tf.expand_dims(top_k_h_sent_indices, -1)], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(full_indices_sent, [-1, 2], name='full_indices_sent')",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.reshape(tf.nn.softmax(top_k_h_sent_values, axis=1), [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size_sent, self.n_topic]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_softmax_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_205": {
                "variable": {
                    "value": "last_h_softmax_sent",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.last_h_sent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "last_h_softmax_sent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_224": {
                "x": {
                    "value": "self.decoding_matrix",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_225": {
                "a": {
                    "value": "topicnorm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "matrix / tf.sqrt(tf.reduce_sum(tf.square(self.decoding_matrix), 1, keepdims=True))",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(topicnorm)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_136": {
                "a": {
                    "value": "self.decoding_matrix",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_149": {
                "input": {
                    "value": "tf.range(0, self.input_batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_157": {
                "tensor": {
                    "value": "tf.nn.softmax(top_k_h_values, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_167": {
                "input": {
                    "value": "last_h_softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(full_indices, tf.reshape(tf.nn.softmax(top_k_h_values, axis=1), [-1]), [self.input_batch_size, self.n_topic], name='last_h_softmax')",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self.last_h, axis=1, name='last_h_softmax')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_181": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_183": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_189": {
                "x": {
                    "value": "self.logsigm_sent",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_225": {
                "a": {
                    "value": "topicnorm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "matrix / tf.sqrt(tf.reduce_sum(tf.square(self.decoding_matrix), 1, keepdims=True))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "square_74": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_150": {
                "input": {
                    "value": "top_k_h_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(self.last_h, k=params.use_k_topics, sorted=False, name='top_k_h')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_157": {
                "logits": {
                    "value": "top_k_h_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(self.last_h, k=params.use_k_topics, sorted=False, name='top_k_h')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_183": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_197": {
                "input": {
                    "value": "tf.range(0, self.batch_size_sent)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_203": {
                "tensor": {
                    "value": "tf.nn.softmax(top_k_h_sent_values, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_198": {
                "input": {
                    "value": "top_k_h_sent_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(self.last_h_sent, k=params.use_k_topics, sorted=False, name='top_k_h_sent')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_203": {
                "logits": {
                    "value": "top_k_h_sent_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(self.last_h_sent, k=params.use_k_topics, sorted=False, name='top_k_h_sent')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/run_finetuning_spot.py": {
        "sklearn": {
            "precision_recall_fscore_support_753": {
                "variable": {
                    "value": "(macro_prec, macro_recall, macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_754": {
                "variable": {
                    "value": "(micro_prec, micro_recall, micro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_755": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_853": {
                "variable": {
                    "value": "(macro_prec, macro_recall, macro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_854": {
                "variable": {
                    "value": "(micro_prec, micro_recall, micro_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_855": {
                "variable": {
                    "value": "acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "true_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(true_label_list)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pred_label_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "postprocess_pred(true_label_list, pred_label_list, doc_ids_list, pred_prob=prob_list)",
                            "Call"
                        ],
                        [
                            "np.asarray(pred_label_list)",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "tensorflow": {
            "set_random_seed_27": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "expand_dims_491": {
                "variable": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5 * tf.math.reduce_max(doc_repres, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(min_allowed_val, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_492": {
                "variable": {
                    "value": "min_allowed",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "min_allowed_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5 * tf.math.reduce_max(doc_repres, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(min_allowed_val, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, FLAGS.n_topic]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_493": {
                "variable": {
                    "value": "boolean_allowed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.greater_equal(doc_repres, min_allowed)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_880": {
                "variable": {
                    "value": "saver_PPL",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_894": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.output_dir + '/supervised_TM', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/finetuned_bert_model', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/' + comb_model_name, 'logs')",
                            "Call"
                        ]
                    ]
                },
                "graph": {
                    "value": "session.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_895": {
                "variable": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_951": {
                "variable": {
                    "value": "saver_PPL",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_969": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.output_dir + '/supervised_TM', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/finetuned_bert_model', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/' + comb_model_name, 'logs')",
                            "Call"
                        ]
                    ]
                },
                "graph": {
                    "value": "session.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_970": {
                "variable": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_1185": {
                "variable": {
                    "value": "saver_PPL",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_1246": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.output_dir + '/supervised_TM', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/finetuned_bert_model', 'logs')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.output_dir + '/' + comb_model_name, 'logs')",
                            "Call"
                        ]
                    ]
                },
                "graph": {
                    "value": "session.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_1247": {
                "variable": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_1547": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1548": {
                "variable": {
                    "value": "input_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1549": {
                "variable": {
                    "value": "segment_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "segment_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1556": {
                "variable": {
                    "value": "doc_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1557": {
                "variable": {
                    "value": "topic_bow",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, topic_vocab_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1558": {
                "variable": {
                    "value": "topic_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1559": {
                "variable": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "is_training",
                    "type": "str",
                    "possible_values": []
                }
            },
            "parse_single_example_203": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": [
                        [
                            "serialized_example",
                            "Method Argument"
                        ]
                    ]
                },
                "features": {
                    "value": "{'input_ids': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'input_mask': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'segment_ids': tf.FixedLenFeature([FLAGS.max_seq_length], tf.int64), 'label_ids': tf.FixedLenFeature([label_size], tf.int64), 'doc_id': tf.FixedLenFeature([1], tf.int64)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "TFRecordDataset_227": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TFRecordDataset_235": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_539": {
                "variable": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_model.get_pooled_output()",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_layer, keep_prob=1 - is_training, seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "1 - is_training",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "get_variable_622": {
                "variable": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hidden_size, num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_626": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "xw_plus_b_629": {
                "variable": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_644": {
                "variable": {
                    "value": "self.comb_lm_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.comb_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_645": {
                "variable": {
                    "value": "self.topic_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.topic_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_647": {
                "variable": {
                    "value": "self.comb_obj_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "(1.0 - FLAGS.alpha) * self.comb_lm_loss",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "FLAGS.alpha * FLAGS.gsm_lr_factor * self.topic_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "local_variables_initializer_897": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_897": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_898": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_898": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_943": {
                "variable": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_971": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_971": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_972": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_972": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_checkpoint_state_1205": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "str(FLAGS.output_dir) + '/finetuned_bert_model'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "initialize_variables_1210": {
                "variable": {
                    "value": "global_step_init",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "[model.comb_global_step]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assign_1221": {
                "variable": {
                    "value": "clf_weights_assign_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "comb_clf_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "bert_clf_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "session.run('bert_loss/output_weights:0')",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_1222": {
                "variable": {
                    "value": "clf_bias_assign_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "comb_clf_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "bert_clf_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "session.run('bert_loss/output_bias:0')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_1524": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_1552": {
                "variable": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "label_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1555": {
                "variable": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "label_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_1562": {
                "variable": {
                    "value": "static_topic",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, FLAGS.n_topic)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "static_topics",
                    "type": "str",
                    "possible_values": []
                }
            },
            "run_1574": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_max_490": {
                "input_tensor": {
                    "value": "doc_repres",
                    "type": "variable",
                    "possible_values": [
                        [
                            "doc_repres",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_equal_493": {
                "x": {
                    "value": "doc_repres",
                    "type": "variable",
                    "possible_values": [
                        [
                            "doc_repres",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "min_allowed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(min_allowed_val, [1, FLAGS.n_topic])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_555": {
                "variable": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hidden_size, num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_559": {
                "variable": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_labels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "xw_plus_b_562": {
                "variable": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_model.get_pooled_output()",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_layer, keep_prob=1 - is_training, seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_weights', [hidden_size, num_labels], initializer=tf.truncated_normal_initializer(stddev=0.02, seed=tf_op_seed))",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_bias', [num_labels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_577": {
                "variable": {
                    "value": "self.bert_obj_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.bert_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_613": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output_layer, self.doc_repres]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_633": {
                "variable": {
                    "value": "self.comb_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_634": {
                "variable": {
                    "value": "self.comb_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(label_ids, self.comb_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_637": {
                "variable": {
                    "value": "self.comb_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_638": {
                "variable": {
                    "value": "self.comb_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_640": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(label_list)",
                            "Call"
                        ],
                        [
                            "num_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_880": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "init_from_checkpoint_946": {
                "ckpt_dir_or_file": {
                    "value": "init_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.init_checkpoint",
                            "Attribute"
                        ],
                        [
                            "FLAGS.init_checkpoint",
                            "Attribute"
                        ]
                    ]
                },
                "assignment_map": {
                    "value": "assignment_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)",
                            "Call"
                        ],
                        [
                            "modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_951": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_1185": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_1191": {
                "variable": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_1200": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_1200": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_1201": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_1201": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_1218": {
                "variable": {
                    "value": "comb_clf_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_weights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_1219": {
                "variable": {
                    "value": "comb_clf_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_1503": {
                "config": {
                    "value": "tf.ConfigProto(inter_op_parallelism_threads=FLAGS.num_cores, intra_op_parallelism_threads=FLAGS.num_cores, gpu_options=tf.GPUOptions(allow_growth=True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_541": {
                "name_or_scope": {
                    "value": "bert_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_566": {
                "variable": {
                    "value": "self.bert_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_567": {
                "variable": {
                    "value": "self.bert_per_example_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(label_ids, self.bert_logits, reduction='none')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_571": {
                "variable": {
                    "value": "self.bert_probabilities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_572": {
                "variable": {
                    "value": "self.log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_574": {
                "variable": {
                    "value": "self.one_hot_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(label_list)",
                            "Call"
                        ],
                        [
                            "num_labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_616": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_layer.shape[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "modeling.get_activation(bert_config.hidden_act)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "modeling.create_initializer(bert_config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "init_from_checkpoint_1194": {
                "ckpt_dir_or_file": {
                    "value": "init_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.init_checkpoint",
                            "Attribute"
                        ],
                        [
                            "FLAGS.init_checkpoint",
                            "Attribute"
                        ]
                    ]
                },
                "assignment_map": {
                    "value": "assignment_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)",
                            "Call"
                        ],
                        [
                            "modeling.get_assignment_map_from_checkpoint(tvars, init_checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_1217": {
                "name_or_scope": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_546": {
                "variable": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output_layer, self.static_topic]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_624": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "zeros_initializer_627": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_634": {
                "multi_class_labels": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "self.comb_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_642": {
                "input_tensor": {
                    "value": "self.one_hot_labels * self.comb_log_probs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ConfigProto_1503": {
                "inter_op_parallelism_threads": {
                    "value": "FLAGS.num_cores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "intra_op_parallelism_threads": {
                    "value": "FLAGS.num_cores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "gpu_options": {
                    "value": "tf.GPUOptions(allow_growth=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tf_record_iterator_1545": {
                "path": {
                    "value": "train_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.data_dir, 'training.tfrecord')",
                            "Call"
                        ],
                        [
                            "train_file",
                            "Method Argument"
                        ],
                        [
                            "train_file",
                            "Method Argument"
                        ],
                        [
                            "train_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "FixedLenFeature_206": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_209": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_212": {
                "shape": {
                    "value": "[FLAGS.max_seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_215": {
                "shape": {
                    "value": "[label_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_218": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_549": {
                "variable": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "joint_output_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([output_layer, self.static_topic], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([output_layer, self.doc_repres], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(joint_output_layer, units=hidden_size, activation=modeling.get_activation(bert_config.hidden_act), kernel_initializer=modeling.create_initializer(bert_config.initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_layer.shape[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "modeling.get_activation(bert_config.hidden_act)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "modeling.create_initializer(bert_config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_557": {
                "stddev": {
                    "value": "0.02",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "zeros_initializer_560": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_567": {
                "multi_class_labels": {
                    "value": "label_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "batch_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "training_iter.get_next()",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=(None, None), name='label_ids')",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.int32, shape=None, name='label_ids')",
                            "Call"
                        ],
                        [
                            "label_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "self.bert_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "none",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_576": {
                "input_tensor": {
                    "value": "self.one_hot_labels * self.log_probs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GPUOptions_1503": {
                "allow_growth": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/train_logistic.py": {
        "sklearn": {
            "precision_recall_fscore_support_271": {
                "variable": {
                    "value": "(micro_dev_prec, micro_dev_recall, micro_dev_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_273": {
                "variable": {
                    "value": "dev_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_294": {
                "variable": {
                    "value": "(test_prec, test_recall, test_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "f1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'macro'",
                            "str"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_295": {
                "variable": {
                    "value": "(micro_test_prec, micro_test_recall, micro_test_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_297": {
                "variable": {
                    "value": "test_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_368": {
                "variable": {
                    "value": "(micro_dev_prec, micro_dev_recall, micro_dev_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_370": {
                "variable": {
                    "value": "dev_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred_best_clf)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_390": {
                "variable": {
                    "value": "(test_prec, test_recall, test_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "f1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'macro'",
                            "str"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_391": {
                "variable": {
                    "value": "(micro_test_prec, micro_test_recall, micro_test_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "micro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_score_393": {
                "variable": {
                    "value": "test_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(test_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(test_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "test_pred_best_clf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ],
                        [
                            "best_clf.predict(test_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(test_pred_best_clf)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_252": {
                "variable": {
                    "value": "(dev_prec, dev_recall, dev_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "f1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'macro'",
                            "str"
                        ]
                    ]
                }
            },
            "precision_recall_fscore_support_349": {
                "variable": {
                    "value": "(dev_prec, dev_recall, dev_f1_score, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "dev_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prepare_doc_emb_data(validation_bert, multilabel_flag=multilabel)",
                            "Call"
                        ],
                        [
                            "prepare_token_data(validation_file_bert, multilabel_flag=multilabel, bert_emb_type=bert_emb_type)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_label)",
                            "Call"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "dev_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "clf.predict(dev_data)",
                            "Call"
                        ],
                        [
                            "np.asarray(dev_pred)",
                            "Call"
                        ]
                    ]
                },
                "pos_label": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "average": {
                    "value": "f1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'macro'",
                            "str"
                        ]
                    ]
                }
            },
            "OneVsRestClassifier_236": {
                "variable": {
                    "value": "clf",
                    "type": "variable",
                    "possible_values": []
                },
                "estimator": {
                    "value": "LinearSVC(C=c, random_state=seed, dual=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LogisticRegression_241": {
                "variable": {
                    "value": "clf",
                    "type": "variable",
                    "possible_values": []
                },
                "C": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C",
                            "variable"
                        ],
                        [
                            "C",
                            "variable"
                        ]
                    ]
                },
                "random_state": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                },
                "max_iter": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "OneVsRestClassifier_335": {
                "variable": {
                    "value": "clf",
                    "type": "variable",
                    "possible_values": []
                },
                "estimator": {
                    "value": "LinearSVC(C=c, random_state=seed, dual=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LogisticRegression_340": {
                "variable": {
                    "value": "clf",
                    "type": "variable",
                    "possible_values": []
                },
                "C": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C",
                            "variable"
                        ],
                        [
                            "C",
                            "variable"
                        ]
                    ]
                },
                "random_state": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                },
                "max_iter": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LinearSVC_236": {
                "C": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C",
                            "variable"
                        ],
                        [
                            "C",
                            "variable"
                        ]
                    ]
                },
                "random_state": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                },
                "dual": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "LinearSVC_335": {
                "C": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C",
                            "variable"
                        ],
                        [
                            "C",
                            "variable"
                        ]
                    ]
                },
                "random_state": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                },
                "dual": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "TopicDistilBERT/src/data/data.py": {
        "sklearn": {
            "MultiLabelBinarizer_95": {
                "variable": {
                    "value": "self.label_transform",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LabelEncoder_103": {
                "variable": {
                    "value": "self.label_transform",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        },
        "tensorflow": {}
    },
    "TopicDistilBERT/src/model/model_classification_with_TM.py": {
        "sklearn": {
            "precision_recall_fscore_support_308": {
                "variable": {
                    "value": "(val_pre, val_rec, val_f1, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "validation_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "val_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_preds(val_logits, multilabel=multilabel)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            },
            "precision_recall_fscore_support_322": {
                "variable": {
                    "value": "(test_pre, test_rec, test_f1, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "test_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "test_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_preds(test_logits, multilabel=multilabel)",
                            "Call"
                        ]
                    ]
                },
                "average": {
                    "value": "macro",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "set_seed_25": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "Dense_66": {
                "variable": {
                    "value": "self.projection",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self.model.config.dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "gelu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gelu",
                            "Call"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "create_initializer(self.model.config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "projection",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_73": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self.num_labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "create_initializer(self.model.config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "classifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Mean_295": {
                "variable": {
                    "value": "loss_metric",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Adam_296": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "3e-05",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-08",
                    "type": "float",
                    "possible_values": []
                },
                "clipnorm": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_207": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.stack(input_ids, axis=0).astype(np.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_209": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.stack(input_ids, axis=0).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_212": {
                "variable": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.stack(attention_mask, axis=0).astype(np.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_214": {
                "variable": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.stack(attention_mask, axis=0).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_341": {
                "variable": {
                    "value": "x_batch_train_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_batch_train_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_train_set, TM_train_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(x_batch_train_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_342": {
                "variable": {
                    "value": "mask_batch_train_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mask_batch_train_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_train_set, TM_train_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(mask_batch_train_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_343": {
                "variable": {
                    "value": "count_batch_train_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "count_batch_train_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_train_set, TM_train_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(count_batch_train_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_384": {
                "variable": {
                    "value": "x_batch_eval_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_batch_eval_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_eval_set, TM_eval_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(x_batch_eval_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_385": {
                "variable": {
                    "value": "mask_batch_eval_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mask_batch_eval_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_eval_set, TM_eval_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(mask_batch_eval_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_386": {
                "variable": {
                    "value": "count_batch_eval_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "count_batch_eval_TM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model_TM.fetch_data(TM_eval_set, TM_eval_count, x_doc_ids)",
                            "Call"
                        ],
                        [
                            "tf.constant(count_batch_eval_TM)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_394": {
                "variable": {
                    "value": "h_concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[o_CLS, h_TM]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_399": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss_fn(y_batch_eval, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_39": {
                "x": {
                    "value": "np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_353": {
                "variable": {
                    "value": "h_concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[o_CLS, h_TM]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_358": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss_fn(y_batch_train, logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GradientTape_346": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_244": {
                "value": {
                    "value": "doc_splitted_sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self.split_docs_by_max_seq_length(doc_word_piece_tokens_list)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_248": {
                "value": {
                    "value": "doc_splitted_sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self.split_docs_by_max_seq_length(doc_word_piece_tokens_list)",
                            "Call"
                        ]
                    ]
                }
            },
            "list_physical_devices_293": {
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pow_40": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "TopicDistilBERT/src/model_TM/model_NVDM_TF2.py": {
        "sklearn": {},
        "tensorflow": {
            "truncated_normal_initializer_24": {
                "stddev": {
                    "value": "initializer_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.02",
                            "Method Argument"
                        ]
                    ]
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1234",
                            "int"
                        ]
                    ]
                }
            },
            "AdamOptimizer_156": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_174": {
                "variable": {
                    "value": "kld",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(batch_size, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "kld",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-0.5 * tf1.reduce_sum(1 - tf1.square(mean) + 2 * logsigm - tf1.exp(2 * logsigm), 1)",
                            "BinOp"
                        ],
                        [
                            "tf1.multiply(mask, kld, name='kld')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_202": {
                "variable": {
                    "value": "final_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "recons_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf1.reduce_sum(tf1.multiply(logits, input), 1)",
                            "UnaryOp"
                        ],
                        [
                            "tf1.add_n(recons_loss_list) / self.n_sample",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "kld",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-0.5 * tf1.reduce_sum(1 - tf1.square(mean) + 2 * logsigm - tf1.exp(2 * logsigm), 1)",
                            "BinOp"
                        ],
                        [
                            "tf1.multiply(mask, kld, name='kld')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_203": {
                "variable": {
                    "value": "objective_TM",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "final_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.add(recons_loss, kld, name='TM_loss_unnormed')",
                            "Call"
                        ]
                    ]
                }
            },
            "add_180": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf1.multiply(tf1.exp(logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(enc_vec, self.mean_params[0]) + self.mean_params[1]",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_softmax_182": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_186": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.random_normal((input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf1.random_normal((self.n_sample * input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "import_meta_graph_97": {
                "variable": {
                    "value": "saver_ir",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(params.TM_pretrained_model_path, 'model_ppl_nvdm_pretrain', 'model_ppl_nvdm_pretrain-1.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_110": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf1.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_146": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf1.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_167": {
                "a": {
                    "value": "enc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "self.non_linearity(tf1.matmul(enc_vec, layer_params[0]) + layer_params[1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.mean_params[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_170": {
                "a": {
                    "value": "enc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "self.non_linearity(tf1.matmul(enc_vec, layer_params[0]) + layer_params[1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.logsigm_params[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_173": {
                "input_tensor": {
                    "value": "1 - tf1.square(mean) + 2 * logsigm - tf1.exp(2 * logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_177": {
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_192": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf1.multiply(tf1.exp(logsigm), curr_eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(enc_vec, self.mean_params[0]) + self.mean_params[1]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_softmax_195": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_224": {
                "name_or_scope": {
                    "value": "scope or 'Linear'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf1.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_227": {
                "variable": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_228": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[matrix_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_240": {
                "variable": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_241": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[bias_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Session_96": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_113": {
                "name_or_scope": {
                    "value": "Linear",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf1.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_180": {
                "x": {
                    "value": "tf1.exp(logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.random_normal((input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf1.random_normal((self.n_sample * input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_181": {
                "a": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.add(tf1.multiply(tf1.exp(logsigm), eps), mean, name='doc_hidden')",
                            "Call"
                        ],
                        [
                            "tf1.add_n(doc_vec_list) / self.n_sample",
                            "BinOp"
                        ],
                        [
                            "tf1.add(tf1.multiply(tf1.exp(logsigm), curr_eps), mean)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.decoder_params[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_183": {
                "input_tensor": {
                    "value": "tf1.multiply(logits, input)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_197": {
                "inputs": {
                    "value": "doc_vec_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_198": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "get_variable_233": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[matrix_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_236": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[matrix_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_246": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[bias_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_249": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vars_dict[bias_var_name]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_initializers('TM_encoder/Linear/' + 'l' + str(l), enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/mean', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_encoder/logsigm', enc_var_values)",
                            "Call"
                        ],
                        [
                            "get_initializers('TM_decoder/projection', dec_var_values)",
                            "Call"
                        ],
                        [
                            "tf1.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf1.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_164": {
                "a": {
                    "value": "enc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "self.non_linearity(tf1.matmul(enc_vec, layer_params[0]) + layer_params[1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "layer_params[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "exp_173": {
                "x": {
                    "value": "2 * logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_180": {
                "x": {
                    "value": "logsigm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(enc_vec, self.logsigm_params[0]) + self.logsigm_params[1]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_183": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_scope_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_192": {
                "x": {
                    "value": "tf1.exp(logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "matmul_194": {
                "a": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.add(tf1.multiply(tf1.exp(logsigm), eps), mean, name='doc_hidden')",
                            "Call"
                        ],
                        [
                            "tf1.add_n(doc_vec_list) / self.n_sample",
                            "BinOp"
                        ],
                        [
                            "tf1.add(tf1.multiply(tf1.exp(logsigm), curr_eps), mean)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.decoder_params[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_collection_99": {
                "key": {
                    "value": "tf1.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_101": {
                "key": {
                    "value": "tf1.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exp_192": {
                "x": {
                    "value": "logsigm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(enc_vec, self.logsigm_params[0]) + self.logsigm_params[1]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_196": {
                "input_tensor": {
                    "value": "tf1.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_173": {
                "x": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(enc_vec, self.mean_params[0]) + self.mean_params[1]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_196": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf1.matmul(doc_vec, self.decoder_params[0]) + self.decoder_params[1]",
                            "BinOp"
                        ],
                        [
                            "tf1.nn.log_softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/model/data_lstm.py": {
        "tensorflow": {
            "set_random_seed_16": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            }
        }
    },
    "TopicBERT/topic_bert/model/softmax.py": {
        "tensorflow": {
            "set_random_seed_12": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "reshape_53": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_55": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(0, batch_len, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reshape(seq_lengths, [batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_59": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_60": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "xw_plus_b_67": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "biases": {
                    "value": "self.softmax_b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_78": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_79": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_unnormed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "xw_plus_b_91": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "biases": {
                    "value": "self.softmax_b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "xw_plus_b_96": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "biases": {
                    "value": "self.softmax_b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "xw_plus_b_101": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "biases": {
                    "value": "self.softmax_b",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "name + self.suffix",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_137": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_139": {
                "variable": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(0, batch_len, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reshape(seq_lengths, [batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_143": {
                "variable": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss_mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(loss_mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_144": {
                "variable": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(loss_mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_153": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.size(labels)]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_175": {
                "variable": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.head_w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_176": {
                "variable": {
                    "value": "head_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "head_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "variable"
                        ],
                        [
                            "tf.where(mask, ones * (self.cutoff[0] + i), head_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_179": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "head_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=head_logits, labels=head_labels)",
                            "Call"
                        ],
                        [
                            "head_loss * loss_mask",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "name + '_unnormed_flat'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_180": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_181": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_unnormed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_195": {
                "variable": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.head_w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_196": {
                "variable": {
                    "value": "head_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_206": {
                "variable": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.head_w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_207": {
                "variable": {
                    "value": "head_logsoftmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, self.head_w)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_217": {
                "variable": {
                    "value": "head_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.head_w",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_38": {
                "variable": {
                    "value": "self.softmax_b",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "b_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[output_dim]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "b_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_70": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b, name=name + self.suffix)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "divide_83": {
                "variable": {
                    "value": "loss_normed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(seq_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_normed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_92": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b, name=name + self.suffix)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name + self.suffix",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_softmax_97": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b)",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(inputs, self.softmax_w, self.softmax_b, name=name + self.suffix)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name + self.suffix",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_variable_122": {
                "variable": {
                    "value": "self.head_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "adaptive_softmax_head_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_dim, head_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_and_156": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(labels, self.cutoff[i])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(labels, self.cutoff[i + 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_159": {
                "variable": {
                    "value": "head_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "ones * (self.cutoff[0] + i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "head_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "variable"
                        ],
                        [
                            "tf.where(mask, ones * (self.cutoff[0] + i), head_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_162": {
                "variable": {
                    "value": "tail_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_163": {
                "a": {
                    "value": "tail_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(inputs, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.tail_w[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "boolean_mask_164": {
                "variable": {
                    "value": "tail_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels - self.cutoff[i]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "boolean_mask_165": {
                "variable": {
                    "value": "tail_loss_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss_mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(loss_mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_166": {
                "variable": {
                    "value": "tail_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tail_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(tail_inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "tail_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(labels - self.cutoff[i], mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "SparseTensor_169": {
                "variable": {
                    "value": "aligned_tail_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.squeeze(tf.where(mask))",
                    "type": "Call",
                    "possible_values": []
                },
                "values": {
                    "value": "tail_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=tail_logits, labels=tail_labels)",
                            "Call"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "[tf.size(labels, out_type=tf.int64)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_185": {
                "variable": {
                    "value": "loss_normed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(seq_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_normed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_199": {
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.tail_w[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_200": {
                "variable": {
                    "value": "tail_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tail_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(tail_inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_203": {
                "values": {
                    "value": "softmax_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[head_softmax[:, :self.cutoff[0]]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ],
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_210": {
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.tail_w[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "log_softmax_211": {
                "variable": {
                    "value": "tail_logsoftmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tail_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.matmul(tail_inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.matmul(inputs, self.tail_w[i][0]), self.tail_w[i][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_214": {
                "values": {
                    "value": "logsoftmax_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[head_logsoftmax[:, :self.cutoff[0]]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ],
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_220": {
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "self.tail_w[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_223": {
                "values": {
                    "value": "logits_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[head_logits[:, :self.cutoff[0]]]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ],
                        [
                            "'loss'",
                            "Method Argument"
                        ],
                        [
                            "'softmax'",
                            "Method Argument"
                        ],
                        [
                            "'log_softmax'",
                            "Method Argument"
                        ],
                        [
                            "'logits'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_18": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_27": {
                "variable": {
                    "value": "b_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_32": {
                "variable": {
                    "value": "softmax_w_additional",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V_additional",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "V_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[input_dim, output_dim]",
                            "List"
                        ],
                        [
                            "[input_dim - concat_dim, output_dim]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_34": {
                "variable": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[concat_V, softmax_w_additional]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_36": {
                "variable": {
                    "value": "self.softmax_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "V_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[input_dim, output_dim]",
                            "List"
                        ],
                        [
                            "[input_dim - concat_dim, output_dim]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_51": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_52": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_57": {
                "tensor": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_lengths",
                            "Method Argument"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_60": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_mask'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_87": {
                "input_tensor": {
                    "value": "loss_unnormed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "variable"
                        ],
                        [
                            "loss",
                            "variable"
                        ]
                    ]
                }
            },
            "variable_scope_120": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_135": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_136": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_141": {
                "tensor": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_lengths",
                            "Method Argument"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_144": {
                "condition": {
                    "value": "loss_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss_mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(loss_mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_mask'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_188": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * loss_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.sparse.to_dense(aligned_tail_loss) if i == 0 else loss + tf.sparse.to_dense(aligned_tail_loss)",
                            "IfExp"
                        ],
                        [
                            "tf.add(loss, head_loss, name=name + '_unnormed_flat')",
                            "Call"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_191": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.reduce_mean(loss) for loss in training_losses]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "ones_like_62": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_63": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_83": {
                "x": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_lengths",
                            "Method Argument"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_146": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_147": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_153": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "greater_equal_156": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "self.cutoff[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "less_156": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "self.cutoff[i + 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_169": {
                "input": {
                    "value": "tf.where(mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_dense_170": {
                "sp_input": {
                    "value": "aligned_tail_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.SparseTensor(tf.squeeze(tf.where(mask)), tail_loss, [tf.size(labels, out_type=tf.int64)])",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_185": {
                "x": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_lengths",
                            "Method Argument"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_169": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.greater_equal(labels, self.cutoff[i]), tf.less(labels, self.cutoff[i + 1]))",
                            "Call"
                        ]
                    ]
                }
            },
            "size_169": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [-1])",
                            "Call"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_dense_171": {
                "sp_input": {
                    "value": "aligned_tail_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse.SparseTensor(tf.squeeze(tf.where(mask)), tail_loss, [tf.size(labels, out_type=tf.int64)])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_129": {
                "name": {
                    "value": "'adaptive_softmax_tail{}_proj_w'.format(i + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_dim, project_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_130": {
                "name": {
                    "value": "'adaptive_softmax_tail{}_w'.format(i + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[project_dim, tail_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "TopicBERT/topic_bert/model/utils.py": {
        "tensorflow": {
            "set_random_seed_12": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "reshape_78": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_81": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(0, batch_len, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reshape(seq_lengths, [batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "np.zeros(batch_size)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_87": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_103": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_104": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_unnormed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_115": {
                "variable": {
                    "value": "const",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "xw_plus_b_141": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_softmax_V', [input.get_shape()[1].value, output_dim], dtype=tf.float32, initializer=V_initializer, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_softmax_V', dtype=tf.float32, initializer=V_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_softmax_b', [output_dim], dtype=tf.float32, initializer=const, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_softmax_b', dtype=tf.float32, initializer=b_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'logits' + suffix",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_34": {
                "variable": {
                    "value": "(clipped_gradients, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradients",
                            "Call"
                        ],
                        [
                            "opt.compute_gradients(loss, vars)",
                            "Call"
                        ],
                        [
                            "zip(*to_clip)",
                            "Call"
                        ],
                        [
                            "list(zip(clipped_gradients, variables)) + not_clipped",
                            "BinOp"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "max_gradient_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_95": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.xw_plus_b(input, w, b, name='logits' + suffix)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_108": {
                "variable": {
                    "value": "loss_normed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(seq_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_normed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_263": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Matrix', [input_size, output_size], initializer=matrix_initializer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Matrix', [input_size, output_size], initializer=matrix_initializer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Matrix', initializer=matrix_initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_76": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_77": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_84": {
                "tensor": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_87": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "np.zeros(batch_size)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_mask'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_117": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_120": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input.get_shape()[1].value, output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_129": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_137": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "const",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_139": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "b_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_234": {
                "name_or_scope": {
                    "value": "scope or 'Linear'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_238": {
                "variable": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_239": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_251": {
                "variable": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_252": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_278": {
                "name_or_scope": {
                    "value": "scope or 'Linear'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_49": {
                "name": {
                    "value": "variable.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "variable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradients",
                            "variable"
                        ]
                    ]
                }
            },
            "histogram_50": {
                "name": {
                    "value": "variable.name + '/gradients'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "grad_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradient.values",
                            "Attribute"
                        ],
                        [
                            "gradient",
                            "variable"
                        ]
                    ]
                }
            },
            "histogram_51": {
                "name": {
                    "value": "variable.name + '/gradient_norm'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "clip_ops.global_norm([grad_values])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_89": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_90": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_108": {
                "x": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_244": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_247": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_257": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_260": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "global_norm_53": {
                "t_list": {
                    "value": "[grad_values]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/modeling.py": {
        "tensorflow": {
            "set_random_seed_34": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "list_variables_349": {
                "variable": {
                    "value": "init_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "init_checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "init_checkpoint",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dropout_377": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout_prob",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "get_variable_428": {
                "variable": {
                    "value": "embedding_table",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "word_embedding_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'word_embeddings'",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[vocab_size, embedding_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_433": {
                "variable": {
                    "value": "flat_input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_ids, axis=[-1])",
                            "Call"
                        ],
                        [
                            "input_ids",
                            "Method Argument"
                        ],
                        [
                            "input_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_442": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(input_tensor, 1.0 - dropout_prob, seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "tf.matmul(one_hot_input_ids, embedding_table)",
                            "Call"
                        ],
                        [
                            "tf.gather(embedding_table, flat_input_ids)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, input_shape[0:-1] + [input_shape[-1] * embedding_size])",
                            "Call"
                        ],
                        [
                            "input_tensor",
                            "variable"
                        ],
                        [
                            "output + position_embeddings",
                            "BinOp"
                        ],
                        [
                            "layer_norm_and_dropout(output, dropout_prob)",
                            "Call"
                        ],
                        [
                            "copy.deepcopy(self.__dict__)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "input_shape[0:-1] + [input_shape[-1] * embedding_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_560": {
                "variable": {
                    "value": "to_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(to_mask, [batch_size, 1, to_seq_length])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_568": {
                "variable": {
                    "value": "broadcast_ones",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, from_seq_length, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_685": {
                "variable": {
                    "value": "query_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "from_tensor_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_to_matrix(from_tensor)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_attention_heads * size_per_head",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "query_act",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "query",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_693": {
                "variable": {
                    "value": "key_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "to_tensor_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_to_matrix(to_tensor)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_attention_heads * size_per_head",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "key_act",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "key",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_701": {
                "variable": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "to_tensor_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_to_matrix(to_tensor)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_attention_heads * size_per_head",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "value_act",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "value",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_720": {
                "variable": {
                    "value": "attention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "query_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(from_tensor_2d, num_attention_heads * size_per_head, activation=query_act, name='query', kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "transpose_for_scores(query_layer, batch_size, num_attention_heads, from_seq_length, size_per_head)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "key_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(to_tensor_2d, num_attention_heads * size_per_head, activation=key_act, name='key', kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "transpose_for_scores(key_layer, batch_size, num_attention_heads, to_seq_length, size_per_head)",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "multiply_721": {
                "variable": {
                    "value": "attention_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "attention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query_layer, key_layer, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.multiply(attention_scores, 1.0 / math.sqrt(float(size_per_head)))",
                            "Call"
                        ],
                        [
                            "attention_scores + adder",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0 / math.sqrt(float(size_per_head))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_739": {
                "variable": {
                    "value": "attention_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "attention_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query_layer, key_layer, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "tf.multiply(attention_scores, 1.0 / math.sqrt(float(size_per_head)))",
                            "Call"
                        ],
                        [
                            "attention_scores + adder",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_746": {
                "variable": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(to_tensor_2d, num_attention_heads * size_per_head, activation=value_act, name='value', kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "tf.reshape(value_layer, [batch_size, to_seq_length, num_attention_heads, size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.transpose(value_layer, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, to_seq_length, num_attention_heads, size_per_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_751": {
                "variable": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(to_tensor_2d, num_attention_heads * size_per_head, activation=value_act, name='value', kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "tf.reshape(value_layer, [batch_size, to_seq_length, num_attention_heads, size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.transpose(value_layer, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_754": {
                "variable": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "attention_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(attention_scores)",
                            "Call"
                        ],
                        [
                            "dropout(attention_probs, attention_probs_dropout_prob)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "value_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(to_tensor_2d, num_attention_heads * size_per_head, activation=value_act, name='value', kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "tf.reshape(value_layer, [batch_size, to_seq_length, num_attention_heads, size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.transpose(value_layer, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_757": {
                "variable": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(attention_probs, value_layer)",
                            "Call"
                        ],
                        [
                            "tf.transpose(context_layer, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size * from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size, from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_945": {
                "variable": {
                    "value": "dyn_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_961": {
                "variable": {
                    "value": "output_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_396": {
                "stddev": {
                    "value": "initializer_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.02",
                            "Method Argument"
                        ],
                        [
                            "0.02",
                            "Method Argument"
                        ],
                        [
                            "0.02",
                            "Method Argument"
                        ],
                        [
                            "0.02",
                            "Method Argument"
                        ],
                        [
                            "0.02",
                            "Method Argument"
                        ],
                        [
                            "0.02",
                            "Method Argument"
                        ]
                    ]
                },
                "seed": {
                    "value": "tf_op_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "expand_dims_426": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_ids, axis=[-1])",
                            "Call"
                        ],
                        [
                            "input_ids",
                            "Method Argument"
                        ],
                        [
                            "input_ids",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_435": {
                "variable": {
                    "value": "one_hot_input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vocab_size",
                            "Method Argument"
                        ],
                        [
                            "vocab_size",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_436": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "one_hot_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(flat_input_ids, depth=vocab_size)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "embedding_table",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=word_embedding_name, shape=[vocab_size, embedding_size], initializer=create_initializer(initializer_range))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_438": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding_table",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=word_embedding_name, shape=[vocab_size, embedding_size], initializer=create_initializer(initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "flat_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_ids, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_495": {
                "variable": {
                    "value": "token_type_table",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "token_type_embedding_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'token_type_embeddings'",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[token_type_vocab_size, width]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_501": {
                "variable": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "token_type_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(shape=[batch_size, seq_length], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_502": {
                "variable": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(token_type_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "token_type_vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "16",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_503": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(flat_token_type_ids, depth=token_type_vocab_size)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "token_type_table",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=token_type_embedding_name, shape=[token_type_vocab_size, width], initializer=create_initializer(initializer_range))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_504": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(one_hot_ids, token_type_table)",
                            "Call"
                        ],
                        [
                            "tf.reshape(token_type_embeddings, [batch_size, seq_length, width])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, seq_length, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assert_less_equal_509": {
                "variable": {
                    "value": "assert_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "seq_length",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "max_position_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "512",
                            "Method Argument"
                        ],
                        [
                            "512",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_650": {
                "variable": {
                    "value": "output_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ],
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, seq_length, num_attention_heads, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_653": {
                "variable": {
                    "value": "output_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_norm(input_tensor, name)",
                            "Call"
                        ],
                        [
                            "dropout(output_tensor, dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [batch_size, seq_length, num_attention_heads, width])",
                            "Call"
                        ],
                        [
                            "tf.transpose(output_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [-1, width])",
                            "Call"
                        ],
                        [
                            "output_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_726": {
                "variable": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(attention_mask, axis=[1])",
                            "Call"
                        ],
                        [
                            "create_attention_mask_from_input_mask(input_ids, input_mask)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_761": {
                "variable": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(attention_probs, value_layer)",
                            "Call"
                        ],
                        [
                            "tf.transpose(context_layer, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size * from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size, from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * from_seq_length, num_attention_heads * size_per_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_766": {
                "variable": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "context_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(attention_probs, value_layer)",
                            "Call"
                        ],
                        [
                            "tf.transpose(context_layer, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size * from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ],
                        [
                            "tf.reshape(context_layer, [batch_size, from_seq_length, num_attention_heads * size_per_head])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, from_seq_length, num_attention_heads * size_per_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_975": {
                "tensor": {
                    "value": "output_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_norm(input_tensor, name)",
                            "Call"
                        ],
                        [
                            "dropout(output_tensor, dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [batch_size, seq_length, num_attention_heads, width])",
                            "Call"
                        ],
                        [
                            "tf.transpose(output_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [-1, width])",
                            "Call"
                        ],
                        [
                            "output_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "orig_dims + [width]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_185": {
                "variable": {
                    "value": "input_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_188": {
                "variable": {
                    "value": "token_type_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, seq_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_511": {
                "variable": {
                    "value": "full_position_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "position_embedding_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'position_embeddings'",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[max_position_embeddings, width]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "slice_524": {
                "variable": {
                    "value": "position_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "full_position_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=position_embedding_name, shape=[max_position_embeddings, width], initializer=create_initializer(initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[seq_length, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_535": {
                "variable": {
                    "value": "position_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "position_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(full_position_embeddings, [0, 0], [seq_length, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(position_embeddings, position_broadcast_shape)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "position_broadcast_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reshape_561": {
                "tensor": {
                    "value": "to_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reshape(to_mask, [batch_size, 1, to_seq_length]), tf.float32)",
                            "Call"
                        ],
                        [
                            "to_mask",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1, to_seq_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "GFile_101": {
                "name": {
                    "value": "json_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "json_file",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_190": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "bert",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_246": {
                "variable": {
                    "value": "first_token_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.sequence_output[:, 0:1, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_247": {
                "variable": {
                    "value": "self.pooled_output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "first_token_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(self.sequence_output[:, 0:1, :], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "create_initializer(config.initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_294": {
                "x": {
                    "value": "np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "control_dependencies_510": {
                "control_inputs": {
                    "value": "[assert_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_846": {
                "name_or_scope": {
                    "value": "'layer_%d' % layer_idx",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dense_886": {
                "variable": {
                    "value": "intermediate_output",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "attention_heads[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(attention_heads, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(attention_output, hidden_size, kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "dropout(attention_output, hidden_dropout_prob)",
                            "Call"
                        ],
                        [
                            "layer_norm(attention_output + layer_input)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "intermediate_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3072",
                            "Method Argument"
                        ],
                        [
                            "3072",
                            "Method Argument"
                        ]
                    ]
                },
                "activation": {
                    "value": "intermediate_act_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gelu",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_894": {
                "variable": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "intermediate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(attention_output, intermediate_size, activation=intermediate_act_fn, kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ],
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_scope_1001": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_191": {
                "name_or_scope": {
                    "value": "embeddings",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_243": {
                "name_or_scope": {
                    "value": "pooler",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_731": {
                "x": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(attention_mask, axis=[1])",
                            "Call"
                        ],
                        [
                            "create_attention_mask_from_input_mask(input_ids, input_mask)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_849": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_872": {
                "variable": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "attention_heads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dense_877": {
                "variable": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "attention_heads[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(attention_heads, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(attention_output, hidden_size, kernel_initializer=create_initializer(initializer_range))",
                            "Call"
                        ],
                        [
                            "dropout(attention_output, hidden_dropout_prob)",
                            "Call"
                        ],
                        [
                            "layer_norm(attention_output + layer_input)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ],
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "create_initializer(initializer_range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_885": {
                "name_or_scope": {
                    "value": "intermediate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_893": {
                "name_or_scope": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_851": {
                "name_or_scope": {
                    "value": "self",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_876": {
                "name_or_scope": {
                    "value": "output",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pow_295": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "init_vars",
                            "variable"
                        ],
                        [
                            "expected_rank",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/data_lstm.py": {
        "tensorflow": {
            "set_random_seed_16": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/data_lstm_colab.py": {
        "tensorflow": {
            "set_random_seed_21": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/model_GSM.py": {
        "tensorflow": {
            "set_random_seed_20": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "add_245": {
                "variable": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.recons_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_246": {
                "variable": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_259": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_263": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_265": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_266": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gradients_268": {
                "variable": {
                    "value": "enc_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_269": {
                "variable": {
                    "value": "dec_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_87": {
                "variable": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_62": {
                "input": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_69": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_119": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_125": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_128": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_137": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.vocab_size, scope='projection', get_matrix=True, matrix_initializer=initializer_nvdm[3][0], bias_initializer=initializer_nvdm[3][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_195": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_85": {
                "input_tensor": {
                    "value": "1 - tf.square(self.mean) + 2 * self.logsigm - tf.exp(2 * self.logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_201": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), curr_eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_203": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add(tf.multiply(tf.exp(self.logsigm), curr_eps), self.mean)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(doc_vec, axis=1)",
                            "Call"
                        ],
                        [
                            "session.run([self.doc_vec], input_feed)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_205": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "latest_checkpoint_452": {
                "checkpoint_dir": {
                    "value": "model_dir_ppl_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ppl_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_472": {
                "checkpoint_dir": {
                    "value": "model_dir_ir_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ir_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_125": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_138": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_207": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_208": {
                "inputs": {
                    "value": "doc_vec_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "exp_85": {
                "x": {
                    "value": "2 * self.logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_125": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_138": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_199": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_201": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exp_201": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_206": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_85": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_206": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/model_NVDM.py": {
        "tensorflow": {
            "set_random_seed_24": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "add_262": {
                "variable": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.recons_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "TM_loss_unnormed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_263": {
                "variable": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.final_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_276": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_280": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_282": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_283": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gradients_285": {
                "variable": {
                    "value": "enc_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_encoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_286": {
                "variable": {
                    "value": "dec_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "self.objective_TM",
                    "type": "Attribute",
                    "possible_values": []
                },
                "xs": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ],
                        [
                            "tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope='TM_decoder')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_351": {
                "variable": {
                    "value": "enc_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_352": {
                "variable": {
                    "value": "dec_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_353": {
                "variable": {
                    "value": "self.pretrain_saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "enc_vars + dec_vars",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_95": {
                "variable": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.kld",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "kld",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_77": {
                "name_or_scope": {
                    "value": "TM_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_127": {
                "name_or_scope": {
                    "value": "TM_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_133": {
                "variable": {
                    "value": "self.doc_vec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "doc_hidden",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_softmax_142": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.nvdm_linear(self.doc_vec, self.vocab_size, scope='projection', get_matrix=True, matrix_initializer=initializer_nvdm[3][0], bias_initializer=initializer_nvdm[3][1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_213": {
                "variable": {
                    "value": "eps_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.n_sample",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_93": {
                "input_tensor": {
                    "value": "1 - tf.square(self.mean) + 2 * self.logsigm - tf.exp(2 * self.logsigm)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_219": {
                "variable": {
                    "value": "doc_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multiply(tf.exp(self.logsigm), curr_eps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_221": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "latest_checkpoint_471": {
                "checkpoint_dir": {
                    "value": "model_dir_ppl_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ppl_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_491": {
                "checkpoint_dir": {
                    "value": "model_dir_ir_nvdm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(topic_params.output_dir, 'model_ir_nvdm_pretrain')",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_133": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.random_normal((self.n_sample * self.input_batch_size, self.n_topic), mean=0.0, stddev=1.0, seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_143": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_223": {
                "inputs": {
                    "value": "recons_loss_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_224": {
                "inputs": {
                    "value": "doc_vec_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "exp_93": {
                "x": {
                    "value": "2 * self.logsigm",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_133": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_143": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_217": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_219": {
                "x": {
                    "value": "tf.exp(self.logsigm)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "curr_eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "eps_list[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exp_219": {
                "x": {
                    "value": "self.logsigm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_222": {
                "input_tensor": {
                    "value": "tf.multiply(logits, self.x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_93": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_222": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits_projected)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(utils.nvdm_linear(doc_vec, self.vocab_size, scope='projection'))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/nvdm/utils.py": {
        "tensorflow": {
            "set_random_seed_12": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "reshape_78": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_81": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(0, batch_len, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reshape(seq_lengths, [batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "np.zeros(batch_size)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_87": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_103": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_104": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_unnormed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_115": {
                "variable": {
                    "value": "const",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "xw_plus_b_141": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_softmax_V', [input.get_shape()[1].value, output_dim], dtype=tf.float32, initializer=V_initializer, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_softmax_V', dtype=tf.float32, initializer=V_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_softmax_b', [output_dim], dtype=tf.float32, initializer=const, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('output_softmax_b', dtype=tf.float32, initializer=b_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'logits' + suffix",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_34": {
                "variable": {
                    "value": "(clipped_gradients, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradients",
                            "Call"
                        ],
                        [
                            "opt.compute_gradients(loss, vars)",
                            "Call"
                        ],
                        [
                            "zip(*to_clip)",
                            "Call"
                        ],
                        [
                            "list(zip(clipped_gradients, variables)) + not_clipped",
                            "BinOp"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "max_gradient_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_95": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.xw_plus_b(input, w, b, name='logits' + suffix)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "divide_108": {
                "variable": {
                    "value": "loss_normed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "loss_function(logits, labels)",
                            "Call"
                        ],
                        [
                            "loss * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(loss, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(loss, axis=1, name=name + '_unnormed')",
                            "Call"
                        ],
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(seq_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_normed'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_295": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Matrix', [input_size, output_size], initializer=matrix_initializer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Matrix', [input_size, output_size], initializer=matrix_initializer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('Matrix', initializer=matrix_initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_76": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_77": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_84": {
                "tensor": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_87": {
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(0, batch_len, 1), tf.reshape(seq_lengths, [batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [-1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.where(mask, tf.ones_like(labels, dtype=tf.float32), tf.zeros_like(labels, dtype=tf.float32), name=name + '_mask'))",
                            "Call"
                        ],
                        [
                            "np.zeros(batch_size)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_mask'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_117": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_120": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input.get_shape()[1].value, output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_129": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_V",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "V_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_137": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "const",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_139": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_softmax_b",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "b_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_266": {
                "name_or_scope": {
                    "value": "scope or 'Linear'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_270": {
                "variable": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_271": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_283": {
                "variable": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_284": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_310": {
                "name_or_scope": {
                    "value": "scope or 'Linear'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_49": {
                "name": {
                    "value": "variable.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "variable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradients",
                            "variable"
                        ]
                    ]
                }
            },
            "histogram_50": {
                "name": {
                    "value": "variable.name + '/gradients'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "grad_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gradient.values",
                            "Attribute"
                        ],
                        [
                            "gradient",
                            "variable"
                        ]
                    ]
                }
            },
            "histogram_51": {
                "name": {
                    "value": "variable.name + '/gradient_norm'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "clip_ops.global_norm([grad_values])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_89": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_90": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_108": {
                "x": {
                    "value": "seq_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data",
                            "variable"
                        ],
                        [
                            "seq_lengths",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_276": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_279": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "matrix_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_289": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_292": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0)",
                            "Call"
                        ],
                        [
                            "tf.glorot_uniform_initializer(seed=tf_op_seed)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "global_norm_53": {
                "t_list": {
                    "value": "[grad_values]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/optimization.py": {
        "tensorflow": {
            "set_random_seed_28": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "42",
                            "int"
                        ]
                    ]
                }
            },
            "get_or_create_global_step_35": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_37": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "init_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "init_lr",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "polynomial_decay_40": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(value=init_lr, shape=[], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.train.polynomial_decay(learning_rate, global_step, num_train_steps, end_learning_rate=0.0, power=1.0, cycle=False)",
                            "Call"
                        ],
                        [
                            "(1.0 - is_warmup) * learning_rate + is_warmup * warmup_learning_rate",
                            "BinOp"
                        ],
                        [
                            "learning_rate",
                            "Method Argument"
                        ]
                    ]
                },
                "global_step": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "num_train_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_train_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "end_learning_rate": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "power": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "cycle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_78": {
                "variable": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gradients_79": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Method Argument"
                        ]
                    ]
                },
                "xs": {
                    "value": "tvars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                },
                "gate_gradients": {
                    "value": "tf.train.Optimizer.GATE_GRAPH",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_83": {
                "variable": {
                    "value": "(grads, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss, tvars, gate_gradients=tf.train.Optimizer.GATE_GRAPH)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_global_norm(grads, clip_norm=1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "group_92": {
                "variable": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.apply_gradients(zip(grads, tvars), var_exist, global_step=global_step)",
                            "Call"
                        ],
                        [
                            "tf.group(train_op, [global_step.assign(new_global_step)])",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "[global_step.assign(new_global_step)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_51": {
                "variable": {
                    "value": "global_steps_int",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_52": {
                "variable": {
                    "value": "warmup_steps_int",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "num_warmup_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_warmup_steps",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_54": {
                "variable": {
                    "value": "global_steps_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_steps_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_55": {
                "variable": {
                    "value": "warmup_steps_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "warmup_steps_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(num_warmup_steps, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_60": {
                "variable": {
                    "value": "is_warmup",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "global_steps_int < warmup_steps_int",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "CrossShardOptimizer_76": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "AdamWeightDecayOptimizer(learning_rate=learning_rate, weight_decay_rate=0.01, beta_1=0.9, beta_2=0.999, epsilon=1e-06, exclude_from_weight_decay=['LayerNorm', 'layer_norm', 'bias'])",
                            "Call"
                        ],
                        [
                            "tf.contrib.tpu.CrossShardOptimizer(optimizer)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_185": {
                "*inputs": {
                    "value": "*assignments",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'AdamWeightDecayOptimizer'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/adam_m'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_135": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/adam_v'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_144": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/adam_m_1'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_150": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/adam_v_1'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_160": {
                "x": {
                    "value": "1.0 - self.beta_1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads_and_vars",
                            "variable"
                        ]
                    ]
                }
            },
            "multiply_162": {
                "x": {
                    "value": "1.0 - self.beta_2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.square(grad)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_162": {
                "x": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads_and_vars",
                            "variable"
                        ]
                    ]
                }
            },
            "sqrt_164": {
                "x": {
                    "value": "next_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2, tf.square(grad))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_initializer_133": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_140": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_149": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_155": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/process_data_fine_tune.py": {
        "tensorflow": {
            "TFRecordWriter_651": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Feature_654": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "int64_list": {
                    "value": "tf.train.Int64List(value=list(values))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_744": {
                "msg": {
                    "value": "*** Reading from training input files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_745": {
                "msg": {
                    "value": "\\t%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "os.path.join(FLAGS.input_folder, 'training.txt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_748": {
                "msg": {
                    "value": "*** Writing to training output files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_761": {
                "msg": {
                    "value": "*** Reading from validation input files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_762": {
                "msg": {
                    "value": "\\t%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "os.path.join(FLAGS.input_folder, 'validation.txt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_765": {
                "msg": {
                    "value": "*** Writing to validation output files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_777": {
                "msg": {
                    "value": "*** Reading from test input files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_778": {
                "msg": {
                    "value": "\\t%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "os.path.join(FLAGS.input_folder, 'test.txt')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_781": {
                "msg": {
                    "value": "*** Writing to test output files ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "run_792": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Example_679": {
                "variable": {
                    "value": "tf_example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature=features)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_621": {
                "msg": {
                    "value": "*** Example ***",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_622": {
                "msg": {
                    "value": "'guid: %s' % example.guid",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_623": {
                "msg": {
                    "value": "'tokens: %s' % ' '.join([tokenization.printable_text(x) for x in tokens])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_625": {
                "msg": {
                    "value": "'input_ids: %s' % ' '.join([str(x) for x in input_ids])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_626": {
                "msg": {
                    "value": "'input_mask: %s' % ' '.join([str(x) for x in input_mask])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_627": {
                "msg": {
                    "value": "'segment_ids: %s' % ' '.join([str(x) for x in segment_ids])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_660": {
                "msg": {
                    "value": "'Writing example %d of %d' % (ex_index, len(examples))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Int64List_654": {
                "value": {
                    "value": "list(values)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Features_679": {
                "feature": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "convert_single_example(ex_index, example, label_map, max_seq_length, tokenizer, doc_id_repeating)",
                            "Call"
                        ],
                        [
                            "collections.OrderedDict()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "TopicBERT/topic_bert/tokenization.py": {
        "tensorflow": {
            "GFile_125": {
                "name": {
                    "value": "vocab_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vocab_file",
                            "Method Argument"
                        ],
                        [
                            "vocab_file",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "TopicBERT/topic_bert/topic_coherence.py": {
        "tensorflow": {
            "import_meta_graph_13": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "ppl_model_meta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_path, 'model_ppl_nvdm_pretrain/model_ppl_nvdm_pretrain-1.meta')",
                            "Call"
                        ]
                    ]
                },
                "clear_devices": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_12": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "TopicDistilBERT/huggingface_config.py": {
        "tensorflow": {}
    }
}