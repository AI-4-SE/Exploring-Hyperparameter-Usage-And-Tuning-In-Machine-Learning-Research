{
    "CIFAR10/SCNN.py": {
        "tensorflow": {
            "slice_99": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_100": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_102": {
                "variable": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_103": {
                "variable": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(tf.subtract(0.0, output))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_104": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.log(tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_26": {
                "variable": {
                    "value": "bias_layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_27": {
                "variable": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layer_in, bias_layer_in]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_28": {
                "variable": {
                    "value": "(_, input_sorted_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "-layer_in",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "k": {
                    "value": "self.in_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_gather_29": {
                "variable": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_30": {
                "variable": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(input_sorted, [batch_num, self.in_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_gather_31": {
                "variable": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_33": {
                "variable": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_34": {
                "variable": {
                    "value": "weight_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_35": {
                "variable": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(weight_sorted, input_sorted_outsize)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_36": {
                "variable": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cumsum(weight_input_mul, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_37": {
                "variable": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "weight_sumed < 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_38": {
                "variable": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_ws < input_sorted_outsize",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_40": {
                "variable": {
                    "value": "input_sorted_outsize_slice",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_num, self.in_size - 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_42": {
                "variable": {
                    "value": "input_sorted_outsize_left",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_sorted_outsize_slice, self.MAX_SPIKE_TIME * tf.ones([batch_num, 1, self.out_size])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_44": {
                "variable": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_large > input_sorted_outsize_left",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_46": {
                "variable": {
                    "value": "out_spike",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_large > input_sorted_outsize_left, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large), out_spike_large)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_51": {
                "variable": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "float"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(self.weight, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_52": {
                "variable": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "part1 > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(part1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_56": {
                "variable": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_71": {
                "variable": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "extract_image_patches_72": {
                "variable": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, self.kernel_size, self.kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, self.strides, self.strides, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_75": {
                "variable": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.extract_image_patches(images=layer_in, ksizes=[1, self.kernel_size, self.kernel_size, 1], strides=[1, self.strides, self.strides, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_77": {
                "variable": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(patches_flatten, 0.1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_79": {
                "variable": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self.kernel.forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(patches_flatten, 0.1), self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten), patches_flatten)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "img_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(self.kernel.forward, patches_infpad)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], tf.cast(tf.math.ceil(input_size[1] / self.strides), tf.int32), tf.cast(tf.math.ceil(input_size[2] / self.strides), tf.int32), self.out_channel]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_15": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.concat((tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size])), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_19": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_21": {
                "name": {
                    "value": "layer_name + '/weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_53": {
                "input_tensor": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(part1 > 0, part1, tf.zeros_like(part1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.square(self.weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_102": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output, index))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_103": {
                "x": {
                    "value": "tf.subtract(0.0, output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_105": {
                "x": {
                    "value": "tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_25": {
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_30": {
                "tensor": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(layer_in, input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_num, self.in_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_32": {
                "input": {
                    "value": "tf.reshape(self.weight, [1, self.in_size, self.out_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_36": {
                "t": {
                    "value": "weight_sumed - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_52": {
                "input": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_77": {
                "x": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_99": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_100": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_101": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_102": {
                "input_tensor": {
                    "value": "tf.multiply(output, index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_103": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_106": {
                "t": {
                    "value": "tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_15": {
                "values": {
                    "value": "(tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_32": {
                "tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.in_size, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_37": {
                "input": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_39": {
                "input": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_45": {
                "input": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_78": {
                "input": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_81": {
                "x": {
                    "value": "tf.math.ceil(input_size[1] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_82": {
                "x": {
                    "value": "tf.math.ceil(input_size[2] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_102": {
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [tf.cast(tf.shape(both)[0] / 2, tf.int32)], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_106": {
                "x": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(z2, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_43": {
                "shape": {
                    "value": "[batch_num, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ceil_81": {
                "x": {
                    "value": "input_size[1] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ceil_82": {
                "x": {
                    "value": "input_size[2] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_107": {
                "t": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(tf.subtract(0.0, output)))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_17": {
                "shape": {
                    "value": "[1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_99": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_100": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_101": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "CIFAR10/SCNN1.py": {
        "tensorflow": {
            "slice_99": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_100": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_102": {
                "variable": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_103": {
                "variable": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(tf.subtract(0.0, output))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_104": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.log(tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_26": {
                "variable": {
                    "value": "bias_layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_27": {
                "variable": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layer_in, bias_layer_in]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_28": {
                "variable": {
                    "value": "(_, input_sorted_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "-layer_in",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "k": {
                    "value": "self.in_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_gather_29": {
                "variable": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_30": {
                "variable": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(input_sorted, [batch_num, self.in_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_gather_31": {
                "variable": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_33": {
                "variable": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_34": {
                "variable": {
                    "value": "weight_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_35": {
                "variable": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(weight_sorted, input_sorted_outsize)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_36": {
                "variable": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cumsum(weight_input_mul, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_37": {
                "variable": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "weight_sumed < 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_38": {
                "variable": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_ws < input_sorted_outsize",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_40": {
                "variable": {
                    "value": "input_sorted_outsize_slice",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_num, self.in_size - 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_42": {
                "variable": {
                    "value": "input_sorted_outsize_left",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_sorted_outsize_slice, self.MAX_SPIKE_TIME * tf.ones([batch_num, 1, self.out_size])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_44": {
                "variable": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_large > input_sorted_outsize_left",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_46": {
                "variable": {
                    "value": "out_spike",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_large > input_sorted_outsize_left, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large), out_spike_large)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_51": {
                "variable": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "float"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(self.weight, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_52": {
                "variable": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "part1 > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(part1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_56": {
                "variable": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_71": {
                "variable": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "extract_image_patches_72": {
                "variable": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, self.kernel_size, self.kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, self.strides, self.strides, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_75": {
                "variable": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.extract_image_patches(images=layer_in, ksizes=[1, self.kernel_size, self.kernel_size, 1], strides=[1, self.strides, self.strides, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_77": {
                "variable": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(patches_flatten, 0.1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_79": {
                "variable": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self.kernel.forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(patches_flatten, 0.1), self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten), patches_flatten)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "img_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(self.kernel.forward, patches_infpad)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], tf.cast(tf.math.ceil(input_size[1] / self.strides), tf.int32), tf.cast(tf.math.ceil(input_size[2] / self.strides), tf.int32), self.out_channel]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_15": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.concat((tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size])), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_19": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_21": {
                "name": {
                    "value": "layer_name + '/weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_53": {
                "input_tensor": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(part1 > 0, part1, tf.zeros_like(part1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.square(self.weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_102": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output, index))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_103": {
                "x": {
                    "value": "tf.subtract(0.0, output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_105": {
                "x": {
                    "value": "tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_113": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_25": {
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_30": {
                "tensor": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(layer_in, input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_num, self.in_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_32": {
                "input": {
                    "value": "tf.reshape(self.weight, [1, self.in_size, self.out_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_36": {
                "t": {
                    "value": "weight_sumed - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_52": {
                "input": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_77": {
                "x": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_99": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_100": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_101": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_102": {
                "input_tensor": {
                    "value": "tf.multiply(output, index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_103": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_106": {
                "t": {
                    "value": "tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MaxPool2D_114": {
                "pool_size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_15": {
                "values": {
                    "value": "(tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_32": {
                "tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.in_size, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_37": {
                "input": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_39": {
                "input": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_45": {
                "input": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_78": {
                "input": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_81": {
                "x": {
                    "value": "tf.math.ceil(input_size[1] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_82": {
                "x": {
                    "value": "tf.math.ceil(input_size[2] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_102": {
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [tf.cast(tf.shape(both)[0] / 2, tf.int32)], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_106": {
                "x": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(z2, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_43": {
                "shape": {
                    "value": "[batch_num, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ceil_81": {
                "x": {
                    "value": "input_size[1] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ceil_82": {
                "x": {
                    "value": "input_size[2] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_107": {
                "t": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(tf.subtract(0.0, output)))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_17": {
                "shape": {
                    "value": "[1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_99": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_100": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_101": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "CIFAR10/TestCifar_L.py": {
        "tensorflow": {
            "placeholder_12": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_13": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_15": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_16": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_20": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ConfigProto_111": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_114": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_20": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_105": {
                "tensor": {
                    "value": "maxpool5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "SCNN1.max_pool_layer(layerout13, (2, 2), (2, 2), 'maxpool5')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 1024]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_115": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_143": {
                "variable": {
                    "value": "accurate1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "CIFAR10/TestCifar_M.py": {
        "tensorflow": {
            "placeholder_14": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_15": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_17": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_18": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_22": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ConfigProto_65": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_68": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_22": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_60": {
                "tensor": {
                    "value": "layerout4",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer4.forward(layerout3)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 16384]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_96": {
                "variable": {
                    "value": "accurate1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "CIFAR10/TestCifar_S.py": {
        "tensorflow": {
            "placeholder_16": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_18": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_20": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_21": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_25": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_57": {
                "variable": {
                    "value": "nnout",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "layerout5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer5.forward(layerout4)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_61": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_64": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_25": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_53": {
                "tensor": {
                    "value": "layerout3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer3.forward(layerout2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_65": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_93": {
                "variable": {
                    "value": "accurate1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "CIFAR10/TrainCifar_L.py": {
        "tensorflow": {
            "placeholder_21": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_22": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_23": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_25": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_26": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_30": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_162": {
                "variable": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layerout17, output_real]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_163": {
                "variable": {
                    "value": "output_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.map_fn(SCNN1.loss_func, layerout_groundtruth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_169": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_174": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_177": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_184": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_185": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "./logs_cfar_a",
                    "type": "str",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_167": {
                "name": {
                    "value": "cost",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K * wsc + K2 * l2 + output_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_30": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_115": {
                "tensor": {
                    "value": "maxpool5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "SCNN1.max_pool_layer(layerout13, (2, 2), (2, 2), 'maxpool5')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 1024]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_163": {
                "fn": {
                    "value": "SCNN1.loss_func",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layerout17, output_real], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_178": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "CIFAR10/TrainCifar_M.py": {
        "tensorflow": {
            "placeholder_20": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_21": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_22": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_24": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_25": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_29": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_91": {
                "variable": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layerout7, output_real]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_92": {
                "variable": {
                    "value": "output_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.map_fn(SCNN.loss_func, layerout_groundtruth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_98": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_103": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_106": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_113": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_114": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "./logs_cfar_b",
                    "type": "str",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_96": {
                "name": {
                    "value": "cost",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K * wsc + K2 * l2 + output_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_29": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_65": {
                "tensor": {
                    "value": "layerout4",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer4.forward(layerout3)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 16384]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_92": {
                "fn": {
                    "value": "SCNN.loss_func",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layerout7, output_real], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "CIFAR10/TrainCifar_S.py": {
        "tensorflow": {
            "placeholder_20": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_21": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_22": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_24": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_25": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_29": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_79": {
                "variable": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layerout5, output_real]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_80": {
                "variable": {
                    "value": "output_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.map_fn(SCNN.loss_func, layerout_groundtruth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_86": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_91": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_94": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_101": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_102": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "./logs_cfar_f2",
                    "type": "str",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_84": {
                "name": {
                    "value": "cost",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K * wsc + K2 * l2 + output_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_29": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_58": {
                "tensor": {
                    "value": "layerout3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer3.forward(layerout2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_80": {
                "fn": {
                    "value": "SCNN.loss_func",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layerout5, output_real], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_95": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "ImageNet/SCNN1.py": {
        "tensorflow": {
            "slice_130": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_131": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_133": {
                "variable": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_134": {
                "variable": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(tf.subtract(0.0, output))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_135": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.log(tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_26": {
                "variable": {
                    "value": "bias_layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_27": {
                "variable": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layer_in, bias_layer_in]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_28": {
                "variable": {
                    "value": "(_, input_sorted_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "-layer_in",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "k": {
                    "value": "self.in_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_gather_29": {
                "variable": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_30": {
                "variable": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(input_sorted, [batch_num, self.in_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_gather_31": {
                "variable": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_33": {
                "variable": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_34": {
                "variable": {
                    "value": "weight_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_35": {
                "variable": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(weight_sorted, input_sorted_outsize)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_36": {
                "variable": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cumsum(weight_input_mul, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_37": {
                "variable": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "weight_sumed < 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_38": {
                "variable": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_ws < input_sorted_outsize",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_40": {
                "variable": {
                    "value": "input_sorted_outsize_slice",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_num, self.in_size - 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_42": {
                "variable": {
                    "value": "input_sorted_outsize_left",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_sorted_outsize_slice, self.MAX_SPIKE_TIME * tf.ones([batch_num, 1, self.out_size])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_44": {
                "variable": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_large > input_sorted_outsize_left",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_46": {
                "variable": {
                    "value": "out_spike",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_large > input_sorted_outsize_left, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large), out_spike_large)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_51": {
                "variable": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "float"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(self.weight, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_52": {
                "variable": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "part1 > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(part1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_56": {
                "variable": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_71": {
                "variable": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "extract_image_patches_72": {
                "variable": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, self.kernel_size, self.kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, self.strides, self.strides, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_75": {
                "variable": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.extract_image_patches(images=layer_in, ksizes=[1, self.kernel_size, self.kernel_size, 1], strides=[1, self.strides, self.strides, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_77": {
                "variable": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(patches_flatten, 0.1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_79": {
                "variable": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self.kernel.forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(patches_flatten, 0.1), self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten), patches_flatten)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "img_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(self.kernel.forward, patches_infpad)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], tf.cast(tf.math.ceil(input_size[1] / self.strides), tf.int32), tf.cast(tf.math.ceil(input_size[2] / self.strides), tf.int32), self.out_channel]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_99": {
                "variable": {
                    "value": "input_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.MaxPool2D(size, stride, padding='SAME')(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.AveragePooling2D(size, stride, padding='SAME')(x)",
                            "Call"
                        ],
                        [
                            "x / scale",
                            "BinOp"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_100": {
                "variable": {
                    "value": "input_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.square(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(input_sqr, [[0, 0], [half_n, half_n], [0, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [half_n, half_n], [0, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_16": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.concat((tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size])), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_20": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_22": {
                "name": {
                    "value": "layer_name + '/weights'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_53": {
                "input_tensor": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(part1 > 0, part1, tf.zeros_like(part1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_57": {
                "input_tensor": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.square(self.weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_133": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output, index))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_134": {
                "x": {
                    "value": "tf.subtract(0.0, output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_136": {
                "x": {
                    "value": "tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_144": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_150": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_25": {
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_30": {
                "tensor": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(layer_in, input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_num, self.in_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_32": {
                "input": {
                    "value": "tf.reshape(self.weight, [1, self.in_size, self.out_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_36": {
                "t": {
                    "value": "weight_sumed - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_52": {
                "input": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_77": {
                "x": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_130": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_131": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_132": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_133": {
                "input_tensor": {
                    "value": "tf.multiply(output, index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_134": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_137": {
                "t": {
                    "value": "tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "MaxPool2D_145": {
                "pool_size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size",
                            "Method Argument"
                        ],
                        [
                            "size",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AveragePooling2D_151": {
                "pool_size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size",
                            "Method Argument"
                        ],
                        [
                            "size",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_16": {
                "values": {
                    "value": "(tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_32": {
                "tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.in_size, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_37": {
                "input": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_39": {
                "input": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_45": {
                "input": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_78": {
                "input": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_81": {
                "x": {
                    "value": "tf.math.ceil(input_size[1] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_82": {
                "x": {
                    "value": "tf.math.ceil(input_size[2] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_133": {
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [tf.cast(tf.shape(both)[0] / 2, tf.int32)], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_137": {
                "x": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(z2, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_43": {
                "shape": {
                    "value": "[batch_num, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ceil_81": {
                "x": {
                    "value": "input_size[1] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ceil_82": {
                "x": {
                    "value": "input_size[2] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_138": {
                "t": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(tf.subtract(0.0, output)))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_18": {
                "shape": {
                    "value": "[1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_130": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_131": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_132": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "ImageNet/TestImageNet.py": {
        "tensorflow": {
            "placeholder_13": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_14": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_16": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_17": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_21": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TESTING_BATCH, 224, 224, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_168": {
                "variable": {
                    "value": "inception_3a_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_3a_1x1, inception_3a_3x3, inception_3a_5x5, inception_3a_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_177": {
                "variable": {
                    "value": "inception_3b_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_3b_1x1, inception_3b_3x3, inception_3b_5x5, inception_3b_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_189": {
                "variable": {
                    "value": "inception_4a_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_4a_1x1, inception_4a_3x3, inception_4a_5x5, inception_4a_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_198": {
                "variable": {
                    "value": "inception_4b_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_4b_1x1, inception_4b_3x3, inception_4b_5x5, inception_4b_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_207": {
                "variable": {
                    "value": "inception_4c_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_4c_1x1, inception_4c_3x3, inception_4c_5x5, inception_4c_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_216": {
                "variable": {
                    "value": "inception_4d_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_4d_1x1, inception_4d_3x3, inception_4d_5x5, inception_4d_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_225": {
                "variable": {
                    "value": "inception_4e_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_4e_1x1, inception_4e_3x3, inception_4e_5x5, inception_4e_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_237": {
                "variable": {
                    "value": "inception_5a_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_5a_1x1, inception_5a_3x3, inception_5a_5x5, inception_5a_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_246": {
                "variable": {
                    "value": "inception_5b_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inception_5b_1x1, inception_5b_3x3, inception_5b_5x5, inception_5b_pool_proj]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ConfigProto_254": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_257": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_21": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "MaxPool2D_154": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_159": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_166": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_175": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ZeroPadding2D_179": {
                "padding": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "MaxPool2D_180": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_187": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_196": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_205": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_214": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_223": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ZeroPadding2D_227": {
                "padding": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "MaxPool2D_228": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_235": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_244": {
                "pool_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                }
            },
            "AveragePooling2D_248": {
                "pool_size": {
                    "value": "(7, 7)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_250": {
                "tensor": {
                    "value": "pool5_7x7_s1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.AveragePooling2D(pool_size=(7, 7), strides=(1, 1), padding='valid')(inception_5b_output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TESTING_BATCH, 1024]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_258": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_286": {
                "variable": {
                    "value": "accurate1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "MNIST/SNN.py": {
        "tensorflow": {
            "slice_186": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_187": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                },
                "begin": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.cast(tf.shape(both)[0] / 2, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_189": {
                "variable": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_190": {
                "variable": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(tf.subtract(0.0, output))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_191": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.log(tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_113": {
                "variable": {
                    "value": "bias_layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layer_in, bias_layer_in]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_115": {
                "variable": {
                    "value": "(_, input_sorted_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "-layer_in",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "k": {
                    "value": "self.in_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_gather_116": {
                "variable": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_117": {
                "variable": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(input_sorted, [batch_num, self.in_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_gather_118": {
                "variable": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "input_sorted_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(-layer_in, self.in_size, False)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_120": {
                "variable": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_121": {
                "variable": {
                    "value": "weight_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(tf.tile(tf.reshape(self.weight, [1, self.in_size, self.out_size]), [batch_num, 1, 1]), input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_122": {
                "variable": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_mul",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(weight_sorted, input_sorted_outsize)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_123": {
                "variable": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_input_sumed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cumsum(weight_input_mul, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_124": {
                "variable": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "weight_sumed < 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_125": {
                "variable": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_ws < input_sorted_outsize",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_127": {
                "variable": {
                    "value": "input_sorted_outsize_slice",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "input_sorted_outsize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(input_sorted, [batch_num, self.in_size, 1]), [1, 1, self.out_size])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[batch_num, self.in_size - 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_129": {
                "variable": {
                    "value": "input_sorted_outsize_left",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_sorted_outsize_slice, self.MAX_SPIKE_TIME * tf.ones([batch_num, 1, self.out_size])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_131": {
                "variable": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_spike_large > input_sorted_outsize_left",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_133": {
                "variable": {
                    "value": "out_spike",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_spike_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_large > input_sorted_outsize_left, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_large), out_spike_large)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_138": {
                "variable": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "float"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reduce_sum(self.weight, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_139": {
                "variable": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "part1 > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(part1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_143": {
                "variable": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_158": {
                "variable": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "extract_image_patches_159": {
                "variable": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "[1, self.kernel_size, self.kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, self.strides, self.strides, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_162": {
                "variable": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "patches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.extract_image_patches(images=layer_in, ksizes=[1, self.kernel_size, self.kernel_size, 1], strides=[1, self.strides, self.strides, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_164": {
                "variable": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(patches_flatten, 0.1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_166": {
                "variable": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "self.kernel.forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "patches_infpad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.less(patches_flatten, 0.1), self.MAX_SPIKE_TIME * tf.ones_like(patches_flatten), patches_flatten)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_167": {
                "variable": {
                    "value": "img_reshaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "img_raw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(self.kernel.forward, patches_infpad)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[input_size[0], tf.cast(tf.math.ceil(input_size[1] / self.strides), tf.int32), tf.cast(tf.math.ceil(input_size[2] / self.strides), tf.int32), self.out_channel]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_105": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.concat((tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size])), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_109": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_140": {
                "input_tensor": {
                    "value": "part2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(part1 > 0, part1, tf.zeros_like(part1))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_144": {
                "input_tensor": {
                    "value": "w_sqr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.square(self.weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_189": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.multiply(output, index))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_190": {
                "x": {
                    "value": "tf.subtract(0.0, output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_192": {
                "x": {
                    "value": "tf.clip_by_value(tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0)), 1e-10, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_112": {
                "input": {
                    "value": "layer_in",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layer_in, bias_layer_in], 1)",
                            "Call"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ],
                        [
                            "layer_in",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_117": {
                "tensor": {
                    "value": "input_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_gather(layer_in, input_sorted_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_num, self.in_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_119": {
                "input": {
                    "value": "tf.reshape(self.weight, [1, self.in_size, self.out_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_num, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_123": {
                "t": {
                    "value": "weight_sumed - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_138": {
                "input_tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_139": {
                "input": {
                    "value": "part1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(threshold, tf.reduce_sum(self.weight, 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_164": {
                "x": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_186": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_187": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_188": {
                "x": {
                    "value": "tf.shape(both)[0] / 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_189": {
                "input_tensor": {
                    "value": "tf.multiply(output, index)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "subtract_190": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_193": {
                "t": {
                    "value": "tf.divide(z1, tf.clip_by_value(z2, 1e-10, 10000000000.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_105": {
                "values": {
                    "value": "(tf.random_uniform([self.in_size - 1, self.out_size], 0.0 / self.in_size, 8.0 / self.in_size, tf.float32), tf.zeros([1, self.out_size]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_119": {
                "tensor": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.in_size, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_124": {
                "input": {
                    "value": "out_spike_all",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.divide(weight_input_sumed, tf.clip_by_value(weight_sumed - 1, 1e-10, 10000000000.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_126": {
                "input": {
                    "value": "out_spike_ws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(weight_sumed < 1, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_all), out_spike_all)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_132": {
                "input": {
                    "value": "out_spike_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(out_spike_ws < input_sorted_outsize, self.MAX_SPIKE_TIME * tf.ones_like(out_spike_ws), out_spike_ws)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_165": {
                "input": {
                    "value": "patches_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(patches, [input_size[0], -1, self.in_channel * self.kernel_size * self.kernel_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_168": {
                "x": {
                    "value": "tf.math.ceil(input_size[1] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_169": {
                "x": {
                    "value": "tf.math.ceil(input_size[2] / self.strides)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_189": {
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [0], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(both, [tf.cast(tf.shape(both)[0] / 2, tf.int32)], [tf.cast(tf.shape(both)[0] / 2, tf.int32)])",
                            "Call"
                        ],
                        [
                            "np.random.randint(self.datasize, size=batch_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_193": {
                "x": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(tf.subtract(0.0, tf.reduce_sum(tf.multiply(output, index))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.clip_by_value(z2, 1e-10, 10000000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_130": {
                "shape": {
                    "value": "[batch_num, 1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ceil_168": {
                "x": {
                    "value": "input_size[1] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ceil_169": {
                "x": {
                    "value": "input_size[2] / self.strides",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "clip_by_value_194": {
                "t": {
                    "value": "z2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(tf.subtract(0.0, output)))",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "10000000000.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_107": {
                "shape": {
                    "value": "[1, self.out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_186": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_187": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_188": {
                "input": {
                    "value": "both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "both",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "MNIST/TestSCNN.py": {
        "tensorflow": {
            "placeholder_13": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_14": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_16": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_17": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_21": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 28, 28, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_42": {
                "variable": {
                    "value": "nnout",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "layerout3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer3.forward(tf.reshape(layerout2, [TRAINING_BATCH, 784]))",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_45": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_48": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 0})",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_21": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_39": {
                "tensor": {
                    "value": "layerout2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer2.forward(layerout1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 784]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_49": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "variable": {
                    "value": "accurate1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "MNIST/TrainSCNN.py": {
        "tensorflow": {
            "placeholder_16": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_18": {
                "variable": {
                    "value": "output_real",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_20": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_21": {
                "variable": {
                    "value": "step_inc_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(1, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_25": {
                "variable": {
                    "value": "input_real_resize",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.exp(input_real)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 28, 28, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_59": {
                "variable": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layerout3, output_real]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_60": {
                "variable": {
                    "value": "output_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.map_fn(SNN.loss_func, layerout_groundtruth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_64": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "ConfigProto_69": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_72": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(device_count={'GPU': 1})",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_76": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_77": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "./logs",
                    "type": "str",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_25": {
                "x": {
                    "value": "input_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_43": {
                "tensor": {
                    "value": "layerout2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer2.forward(layerout1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[TRAINING_BATCH, 784]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_fn_60": {
                "fn": {
                    "value": "SNN.loss_func",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layerout3, output_real], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_73": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "MNIST/trainMNIST.py": {
        "tensorflow": {
            "placeholder_9": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_10": {
                "variable": {
                    "value": "input_exp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_11": {
                "variable": {
                    "value": "groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_20": {
                "variable": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[layerout_out, groundtruth]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_21": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.map_fn(SNN.loss_func, layerout_groundtruth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_35": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0001",
                            "float"
                        ]
                    ]
                }
            },
            "ConfigProto_38": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'GPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "Session_42": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "map_fn_21": {
                "fn": {
                    "value": "SNN.loss_func",
                    "type": "Attribute",
                    "possible_values": []
                },
                "elems": {
                    "value": "layerout_groundtruth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([layerout_out, groundtruth], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}