{
    "main.py": {
        "sklearn": {
            "train_test_split_28": {
                "variable": {
                    "value": "(train_paths, test_paths)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "all_images",
                    "type": "variable",
                    "possible_values": []
                },
                "random_state": {
                    "value": "2018",
                    "type": "int",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.4",
                    "type": "float",
                    "possible_values": []
                }
            },
            "train_test_split_141": {
                "variable": {
                    "value": "(x_train, x_val, y_train, y_val)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "x_data",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "y_data",
                    "type": "variable",
                    "possible_values": []
                },
                "test_size": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Session_22": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(log_device_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_22": {
                "log_device_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "loss_functions.py": {
        "tensorflow": {
            "clip_by_value_27": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(y_pred, tf.keras.backend.epsilon(), 1 - tf.keras.backend.epsilon())",
                            "Call"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ],
                        [
                            "y_pred",
                            "Method Argument"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "tf.keras.backend.epsilon()",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1 - tf.keras.backend.epsilon()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_28": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y_pred / (1 - y_pred)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_32": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "focal_loss_with_logits(logits=logits, targets=y_true, alpha=alpha, gamma=gamma, y_pred=y_pred)",
                            "Call"
                        ],
                        [
                            "1 - dsc(y_true, y_pred)",
                            "BinOp"
                        ],
                        [
                            "binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "epsilon_27": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log1p_23": {
                "x": {
                    "value": "tf.exp(-tf.abs(logits))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_23": {
                "features": {
                    "value": "-logits",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_23": {
                "x": {
                    "value": "-tf.abs(logits)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "abs_23": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(y_pred / (1 - y_pred))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}