{
    "create_dataset.py": {
        "torch": {}
    },
    "model_vgg_human.py": {
        "torch": {
            "DataLoader_119": {
                "variable": {
                    "value": "cifar100_train_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_train_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=True, transform=trans_train, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataLoader_124": {
                "variable": {
                    "value": "cifar100_test_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_test_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=False, transform=trans_test, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_131": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0 if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "SGD_133": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "VGG16.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_134": {
                "variable": {
                    "value": "scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(VGG16.parameters(), lr=0.01)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_24": {
                "variable": {
                    "value": "self.classifier1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_31": {
                "variable": {
                    "value": "self.classifier2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_82": {
                "variable": {
                    "value": "t1_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.classifier1(g_block5.view(g_block5.size(0), -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_83": {
                "variable": {
                    "value": "t2_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.classifier2(g_block5.view(g_block5.size(0), -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_89": {
                "variable": {
                    "value": "x_output_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(x_output), num_ouput)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "mean_175": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(train_pred1, train_label[:, 2], num_ouput=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_177": {
                "variable": {
                    "value": "cost[2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(train_pred2, train_label[:, 3], num_ouput=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_51": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_61": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_94": {
                "input": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_available_131": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_184": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_203": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "test_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(test_pred1, test_label[:, 2], 20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_205": {
                "variable": {
                    "value": "cost[2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "test_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(test_pred2, test_label[:, 3], 100)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_25": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_26": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_27": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_32": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_33": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_34": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_93": {
                "input": {
                    "value": "x_pred + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_163": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(train_pred2, train_label[:, 3], num_ouput=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv2d_52": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_53": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_54": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_55": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_56": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_57": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_58": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_62": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_63": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_64": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_65": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_66": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_67": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_68": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_69": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_70": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_71": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model_vgg_maxl.py": {
        "torch": {
            "DataLoader_279": {
                "variable": {
                    "value": "cifar100_train_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_train_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=True, transform=trans_train, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataLoader_284": {
                "variable": {
                    "value": "cifar100_test_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_test_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=False, transform=trans_test, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_292": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0 if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "SGD_294": {
                "variable": {
                    "value": "gen_optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "LabelGenerator.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "0.0005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_295": {
                "variable": {
                    "value": "gen_scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "gen_optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(LabelGenerator.parameters(), lr=0.001, weight_decay=0.0005)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "SGD_304": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_305": {
                "variable": {
                    "value": "scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(VGG16_model.parameters(), lr=0.01)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_32": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_117": {
                "variable": {
                    "value": "self.classifier1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_125": {
                "variable": {
                    "value": "self.classifier2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_205": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['classifier{:d}.0.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['classifier{:d}.0.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "relu_206": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "linear_207": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['classifier{:d}.2.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['classifier{:d}.2.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_208": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_253": {
                "variable": {
                    "value": "x_pred1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_pred1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mean(x_pred1, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "grad_337": {
                "variable": {
                    "value": "grads1",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "torch.mean(train_loss1)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "retain_graph": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_unused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "grad_338": {
                "variable": {
                    "value": "grads2",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "torch.mean(train_loss2)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "retain_graph": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_unused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "mean_354": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_385": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "grad_392": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "train_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ]
                    ]
                },
                "inputs": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "create_graph": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "mean_410": {
                "variable": {
                    "value": "cost[2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_52": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_62": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_146": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_156": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_173": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.0.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.0.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_174": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "torch.zeros(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "running_var": {
                    "value": "torch.ones(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.1.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.1.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_177": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_178": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['block{:d}.3.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.3.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_179": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "torch.zeros(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "running_var": {
                    "value": "torch.ones(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.4.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.4.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_182": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "max_pool2d_183": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_185": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.0.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.0.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_186": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "torch.zeros(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "running_var": {
                    "value": "torch.ones(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.1.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.1.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_189": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_190": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['block{:d}.3.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.3.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_191": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "torch.zeros(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "running_var": {
                    "value": "torch.ones(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.4.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.4.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_194": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_195": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weights['block{:d}.6.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.6.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_norm_196": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "running_mean": {
                    "value": "torch.zeros(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "running_var": {
                    "value": "torch.ones(net.data.size()[1]).to(device)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weights['block{:d}.7.weight'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "bias": {
                    "value": "weights['block{:d}.7.bias'.format(index)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_199": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "max_pool2d_200": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.conv2d(input, weights['block{:d}.0.weight'.format(index)], weights['block{:d}.0.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.1.weight'.format(index)], weights['block{:d}.1.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.3.weight'.format(index)], weights['block{:d}.3.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.4.weight'.format(index)], weights['block{:d}.4.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.conv2d(net, weights['block{:d}.6.weight'.format(index)], weights['block{:d}.6.bias'.format(index)], padding=1)",
                            "Call"
                        ],
                        [
                            "F.batch_norm(net, torch.zeros(net.data.size()[1]).to(device), torch.ones(net.data.size()[1]).to(device), weights['block{:d}.7.weight'.format(index)], weights['block{:d}.7.bias'.format(index)], training=True)",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.max_pool2d(net, kernel_size=2, stride=2)",
                            "Call"
                        ],
                        [
                            "F.linear(input, weights['classifier{:d}.0.weight'.format(index)], weights['classifier{:d}.0.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.relu(net, inplace=True)",
                            "Call"
                        ],
                        [
                            "F.linear(net, weights['classifier{:d}.2.weight'.format(index)], weights['classifier{:d}.2.bias'.format(index)])",
                            "Call"
                        ],
                        [
                            "F.softmax(net, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_244": {
                "variable": {
                    "value": "x_output_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(x_output), num_output)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "sum_249": {
                "input": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_255": {
                "input": {
                    "value": "loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_pred1 * torch.log(x_pred1 + 1e-20)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "is_available_292": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_416": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_429": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "test_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(test_pred1, test_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_33": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_34": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_35": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "int(np.sum(self.class_nb))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_78": {
                "input": {
                    "value": "torch.exp(x) * mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_89": {
                "*size": {
                    "value": "[len(self.class_nb), np.sum(self.class_nb)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Linear_118": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_119": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_120": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "len(psi)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Softmax_121": {
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_126": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_127": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_128": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "int(np.sum(psi))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Softmax_129": {
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_248": {
                "input": {
                    "value": "x_pred + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_254": {
                "input": {
                    "value": "x_pred1 + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_337": {
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_338": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_346": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_380": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv2d_53": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_54": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_55": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_56": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_57": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_58": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_59": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_63": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_64": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_65": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_66": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_67": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_68": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_69": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_70": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_71": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_72": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_78": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Conv2d_147": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_148": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_149": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_150": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_151": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_152": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_153": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_157": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_158": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_159": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_160": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_161": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_162": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_163": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_164": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_165": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_166": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_174": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_174": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_179": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_179": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_186": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_186": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_191": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_191": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_196": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_196": {
                "*size": {
                    "value": "net.data.size()[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "mean_343": {
                "input": {
                    "value": "F.cosine_similarity(grads1_, grads2_, dim=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cosine_similarity_343": {
                "x1": {
                    "value": "grads1_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads1[l].view(grads1[l].shape[0], -1)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "grads2_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads2[l].view(grads2[l].shape[0], -1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mean_403": {
                "input": {
                    "value": "train_loss3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_entropy(train_pred3)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model_vgg_maxl_firstorder.py": {
        "torch": {
            "DataLoader_324": {
                "variable": {
                    "value": "cifar100_train_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_train_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=True, transform=trans_train, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataLoader_329": {
                "variable": {
                    "value": "cifar100_test_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_test_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=False, transform=trans_test, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_337": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0 if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "SGD_339": {
                "variable": {
                    "value": "gen_optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "LabelGenerator.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                },
                "weight_decay": {
                    "value": "0.0005",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_340": {
                "variable": {
                    "value": "gen_scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "gen_optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(LabelGenerator.parameters(), lr=0.001, weight_decay=0.0005)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "SGD_349": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_350": {
                "variable": {
                    "value": "scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(VGG16_model.parameters(), lr=0.01)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_36": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_121": {
                "variable": {
                    "value": "self.classifier1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_129": {
                "variable": {
                    "value": "self.classifier2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_200": {
                "variable": {
                    "value": "x_pred1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_pred1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mean(x_pred1, dim=0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "grad_230": {
                "variable": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_output_onehot * (1 - x_pred) ** 2 * torch.log(x_pred + 1e-20)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + 0 * torch.mean(train_loss2) + 0.2 * torch.mean(train_loss3)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ]
                    ]
                },
                "inputs": {
                    "value": "self.multi_task_net.parameters()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mse_loss_248": {
                "variable": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "train_pred2",
                    "type": "variable",
                    "possible_values": []
                },
                "target": {
                    "value": "torch.zeros_like(train_pred2, device=train_x.device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "grad_256": {
                "variable": {
                    "value": "d_model",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_output_onehot * (1 - x_pred) ** 2 * torch.log(x_pred + 1e-20)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + 0 * torch.mean(train_loss2) + 0.2 * torch.mean(train_loss3)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ]
                    ]
                },
                "inputs": {
                    "value": "model_weights_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tuple(self.multi_task_net_.parameters())",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_265": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[w.view(-1) for w in d_model]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "norm_265": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "grad_279": {
                "variable": {
                    "value": "d_weight_p",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_output_onehot * (1 - x_pred) ** 2 * torch.log(x_pred + 1e-20)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + 0 * torch.mean(train_loss2) + 0.2 * torch.mean(train_loss3)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ]
                    ]
                },
                "inputs": {
                    "value": "self.label_generator.parameters()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "grad_292": {
                "variable": {
                    "value": "d_weight_n",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_output_onehot * (1 - x_pred) ** 2 * torch.log(x_pred + 1e-20)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + 0 * torch.mean(train_loss2) + 0.2 * torch.mean(train_loss3)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(train_loss1) + torch.mean(train_loss2)",
                            "BinOp"
                        ]
                    ]
                },
                "inputs": {
                    "value": "self.label_generator.parameters()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "grad_380": {
                "variable": {
                    "value": "grads1",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "torch.mean(train_loss1)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "retain_graph": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_unused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "grad_381": {
                "variable": {
                    "value": "grads2",
                    "type": "variable",
                    "possible_values": []
                },
                "outputs": {
                    "value": "torch.mean(train_loss2)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "VGG16_model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "retain_graph": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_unused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "mean_397": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_56": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_66": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_150": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_160": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_191": {
                "variable": {
                    "value": "x_output_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(x_output), num_output)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "sum_196": {
                "input": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_202": {
                "input": {
                    "value": "loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_pred1 * torch.log(x_pred1 + 1e-20)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "is_available_337": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_419": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_432": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "test_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(test_pred1, test_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_37": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_38": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_39": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "int(np.sum(self.class_nb))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_82": {
                "input": {
                    "value": "torch.exp(x) * mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_93": {
                "*size": {
                    "value": "[len(self.class_nb), np.sum(self.class_nb)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Linear_122": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_123": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_124": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "len(psi)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Softmax_125": {
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_130": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_131": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_132": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "int(np.sum(psi))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Softmax_133": {
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_195": {
                "input": {
                    "value": "x_pred + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_201": {
                "input": {
                    "value": "x_pred1 + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_227": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_233": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_248": {
                "input": {
                    "value": "train_pred2",
                    "type": "variable",
                    "possible_values": []
                },
                "device": {
                    "value": "train_x.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_260": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_269": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_278": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_282": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_291": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_295": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_380": {
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred1, train_label[:, 2], pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred1, train_y, pri=True, num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_381": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_389": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv2d_57": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_58": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_59": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_60": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_61": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_62": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_63": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_67": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_68": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_69": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_70": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_71": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_72": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_73": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_74": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_75": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_76": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_82": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Conv2d_151": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_152": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_153": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_154": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_155": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_156": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_157": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_161": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_162": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_163": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_164": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_165": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_166": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_167": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_168": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_169": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_170": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_252": {
                "input": {
                    "value": "train_loss2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16_model.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "F.mse_loss(train_pred2, torch.zeros_like(train_pred2, device=train_x.device))",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ],
                        [
                            "self.multi_task_net.model_fit(train_pred2, train_pred3, pri=False, num_output=100)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_386": {
                "input": {
                    "value": "F.cosine_similarity(grads1_, grads2_, dim=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cosine_similarity_386": {
                "x1": {
                    "value": "grads1_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads1[l].view(grads1[l].shape[0], -1)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "grads2_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads2[l].view(grads2[l].shape[0], -1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "model_vgg_single.py": {
        "torch": {
            "DataLoader_112": {
                "variable": {
                    "value": "cifar100_train_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_train_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=True, transform=trans_train, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "DataLoader_117": {
                "variable": {
                    "value": "cifar100_test_loader",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "cifar100_test_set",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CIFAR100(root='dataset', train=False, transform=trans_test, download=False)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Constant"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_124": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0 if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "SGD_126": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "VGG16.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "StepLR_127": {
                "variable": {
                    "value": "scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.SGD(VGG16.parameters(), lr=0.01)",
                            "Call"
                        ]
                    ]
                },
                "step_size": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "gamma": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Sequential_25": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(filter[-1], filter[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_77": {
                "variable": {
                    "value": "t1_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "t1_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.classifier(g_block5.view(g_block5.size(0), -1))",
                            "Call"
                        ],
                        [
                            "F.softmax(t1_pred, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_83": {
                "variable": {
                    "value": "x_output_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(x_output), num_output)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "mean_153": {
                "variable": {
                    "value": "train_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(train_pred1, train_label[:, 2], num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_163": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "train_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(train_pred1, train_label[:, 2], num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_45": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_55": {
                "variable": {
                    "value": "conv_block",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=3, padding=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_88": {
                "input": {
                    "value": "-loss",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_available_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_185": {
                "variable": {
                    "value": "cost[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "test_loss1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "VGG16.model_fit(test_pred1, test_label[:, 2], num_output=20)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_26": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ReLU_27": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_28": {
                "in_features": {
                    "value": "filter[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out_features": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_87": {
                "input": {
                    "value": "x_pred + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Conv2d_46": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_47": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_48": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_49": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_50": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_51": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_52": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2d_56": {
                "in_channels": {
                    "value": "in_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_57": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_58": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_59": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_60": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_61": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2d_62": {
                "in_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_63": {
                "num_features": {
                    "value": "out_channel",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ReLU_64": {
                "inplace": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "MaxPool2d_65": {
                "kernel_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "stride": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}